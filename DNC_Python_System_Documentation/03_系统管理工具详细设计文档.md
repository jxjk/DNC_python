# DNC系统管理工具详细设计文档

## 1. 系统管理模块详细设计

### 1.1 初始化系统技术实现

**系统初始化器 (Frm_main_Load)**
```python
class SystemInitializer:
    def __init__(self, config_manager: ConfigManager, data_manager: DataManager):
        self.config_manager = config_manager
        self.data_manager = data_manager
        self.initialization_steps = [
            self._load_configuration,
            self._load_master_data,
            self._initialize_ui,
            self._setup_communication
        ]
    
    async def initialize_system(self):
        """异步初始化系统"""
        for step in self.initialization_steps:
            try:
                await step()
            except Exception as e:
                logger.error(f"初始化步骤失败: {e}")
                raise
    
    async def _load_configuration(self):
        """加载系统配置"""
        self.config = await self.config_manager.load_config()
    
    async def _load_master_data(self):
        """加载Master数据"""
        self.master_data = await self.data_manager.load_master_data()
    
    async def _initialize_ui(self):
        """初始化用户界面"""
        # 创建主窗口和控件
        pass
    
    async def _setup_communication(self):
        """设置通信连接"""
        # 初始化NC通信和命名管道
        pass
```

### 1.2 显示管理功能设计

**控件状态管理器 (ControlStateManager)**
```python
class ControlStateManager:
    def __init__(self):
        self.control_states = {}
        self.control_groups = {}
    
    def set_controls_enabled(self, control_ids: List[str], enabled: bool):
        """设置控件启用状态"""
        for control_id in control_ids:
            if control_id in self.control_states:
                self.control_states[control_id].setEnabled(enabled)
    
    def set_controls_visible(self, control_ids: List[str], visible: bool):
        """设置控件可见性"""
        for control_id in control_ids:
            if control_id in self.control_states:
                self.control_states[control_id].setVisible(visible)
    
    def add_control_group(self, group_name: str, control_ids: List[str]):
        """添加控件组"""
        self.control_groups[group_name] = control_ids
    
    def set_group_enabled(self, group_name: str, enabled: bool):
        """设置控件组启用状态"""
        if group_name in self.control_groups:
            self.set_controls_enabled(self.control_groups[group_name], enabled)
```

### 1.3 配置管理技术方案

**INI配置管理器 (IniConfigManager)**
```python
class IniConfigManager:
    def __init__(self, ini_file_path: str):
        self.ini_file_path = ini_file_path
        self.config = {}
    
    def load_config(self) -> Dict:
        """加载INI配置文件"""
        config = configparser.ConfigParser()
        config.read(self.ini_file_path, encoding='utf-8')
        
        for section in config.sections():
            self.config[section] = dict(config.items(section))
        
        return self.config
    
    def save_config(self, config: Dict):
        """保存INI配置文件"""
        config_parser = configparser.ConfigParser()
        
        for section, options in config.items():
            config_parser[section] = options
        
        with open(self.ini_file_path, 'w', encoding='utf-8') as f:
            config_parser.write(f)
    
    def get_value(self, section: str, key: str, default=None):
        """获取配置值"""
        return self.config.get(section, {}).get(key, default)
```

## 2. 工具方法详细设计

### 2.1 字符串处理技术实现

**字符串工具类 (StringUtils)**
```python
class StringUtils:
    @staticmethod
    def len_b(text: str) -> int:
        """计算字符串字节长度（兼容VB.NET的LenB函数）"""
        return len(text.encode('utf-8'))
    
    @staticmethod
    def make_format_str(format_pattern: str, *args) -> str:
        """创建格式化字符串"""
        try:
            return format_pattern.format(*args)
        except Exception as e:
            logger.error(f"字符串格式化失败: {e}")
            return format_pattern
    
    @staticmethod
    def to_half_adjust(value: float, decimal_places: int = 0) -> float:
        """四舍五入处理（兼容VB.NET的ToHalfAdjust）"""
        factor = 10 ** decimal_places
        return round(value * factor) / factor
    
    @staticmethod
    def get_operator_name(operator_id: str) -> str:
        """获取操作员名称"""
        operator_map = {
            '001': '操作员A',
            '002': '操作员B',
            '003': '操作员C'
        }
        return operator_map.get(operator_id, '未知操作员')
```

### 2.2 系统工具功能设计

**系统工具类 (SystemUtils)**
```python
class SystemUtils:
    @staticmethod
    def get_all_controls(parent_widget: QWidget) -> List[QWidget]:
        """获取所有子控件"""
        controls = []
        
        def collect_controls(widget):
            for child in widget.children():
                if isinstance(child, QWidget):
                    controls.append(child)
                    collect_controls(child)
        
        collect_controls(parent_widget)
        return controls
    
    @staticmethod
    def change_form_size(form: QWidget, width: int, height: int):
        """改变窗体大小"""
        form.resize(width, height)
    
    @staticmethod
    def show_info_form(title: str, message: str):
        """显示信息窗体"""
        msg_box = QMessageBox()
        msg_box.setWindowTitle(title)
        msg_box.setText(message)
        msg_box.setIcon(QMessageBox.Information)
        msg_box.exec_()
```

### 2.3 数值处理工具

**公差计算器 (ToleranceCalculator)**
```python
class ToleranceCalculator:
    @staticmethod
    def get_shafts_tolerance(diameter: float, tolerance_class: str) -> Tuple[float, float]:
        """获取轴公差"""
        tolerance_tables = {
            'h6': {10: (-0.009, 0), 18: (-0.011, 0), 30: (-0.013, 0)},
            'h7': {10: (-0.015, 0), 18: (-0.018, 0), 30: (-0.021, 0)},
            'h8': {10: (-0.022, 0), 18: (-0.027, 0), 30: (-0.033, 0)}
        }
        
        for max_diameter, tolerance in tolerance_tables.get(tolerance_class, {}).items():
            if diameter <= max_diameter:
                return tolerance
        
        return (0, 0)
    
    @staticmethod
    def get_length_tolerance(length: float, tolerance_class: str) -> Tuple[float, float]:
        """获取长度公差"""
        tolerance_tables = {
            'fine': {100: (-0.1, 0.1), 400: (-0.2, 0.2), 1000: (-0.3, 0.3)},
            'medium': {100: (-0.2, 0.2), 400: (-0.4, 0.4), 1000: (-0.6, 0.6)},
            'coarse': {100: (-0.4, 0.4), 400: (-0.8, 0.8), 1000: (-1.2, 1.2)}
        }
        
        for max_length, tolerance in tolerance_tables.get(tolerance_class, {}).items():
            if length <= max_length:
                return tolerance
        
        return (0, 0)
```

## 3. 系统管理功能扩展设计

### 3.1 系统监控功能

**系统状态监控器**
```python
class SystemMonitor:
    def __init__(self):
        self.metrics = {}
        self.alert_thresholds = {
            'memory_usage': 0.8,  # 80%
            'cpu_usage': 0.9,     # 90%
            'disk_space': 0.1     # 10% 剩余
        }
    
    def collect_system_metrics(self) -> Dict:
        """收集系统指标"""
        import psutil
        
        metrics = {
            'memory_usage': psutil.virtual_memory().percent / 100,
            'cpu_usage': psutil.cpu_percent(interval=1) / 100,
            'disk_space': psutil.disk_usage('/').free / psutil.disk_usage('/').total
        }
        
        self.metrics = metrics
        return metrics
    
    def check_alerts(self) -> List[str]:
        """检查系统告警"""
        alerts = []
        
        for metric, value in self.metrics.items():
            if value > self.alert_thresholds.get(metric, 1.0):
                alerts.append(f"系统告警: {metric} = {value:.1%}")
        
        return alerts
```

### 3.2 日志管理功能

**日志管理器**
```python
class LogManager:
    def __init__(self, log_directory: str = "./logs"):
        self.log_directory = log_directory
        self.setup_logging()
    
    def setup_logging(self):
        """设置日志系统"""
        import logging
        import os
        
        if not os.path.exists(self.log_directory):
            os.makedirs(self.log_directory)
        
        # 配置根日志记录器
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(os.path.join(self.log_directory, 'dnc_system.log')),
                logging.StreamHandler()
            ]
        )
    
    def log_operation(self, operator_id: str, operation: str, details: str):
        """记录操作日志"""
        logger = logging.getLogger('operation')
        logger.info(f"操作员: {operator_id}, 操作: {operation}, 详情: {details}")
```

### 3.3 备份恢复功能

**数据备份管理器**
```python
class BackupManager:
    def __init__(self, backup_directory: str = "./backups"):
        self.backup_directory = backup_directory
    
    def create_backup(self, data_files: List[str]) -> str:
        """创建数据备份"""
        import shutil
        import datetime
        
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = os.path.join(self.backup_directory, f"backup_{timestamp}")
        
        os.makedirs(backup_path, exist_ok=True)
        
        for file_path in data_files:
            if os.path.exists(file_path):
                shutil.copy2(file_path, backup_path)
        
        return backup_path
    
    def restore_backup(self, backup_path: str):
        """恢复数据备份"""
        import shutil
        
        if not os.path.exists(backup_path):
            raise FileNotFoundError(f"备份路径不存在: {backup_path}")
        
        for file_name in os.listdir(backup_path):
            source_path = os.path.join(backup_path, file_name)
            target_path = os.path.join("./data", file_name)
            
            if os.path.exists(target_path):
                # 备份当前文件
                backup_name = f"{file_name}.backup"
                shutil.copy2(target_path, backup_name)
            
            shutil.copy2(source_path, target_path)
```

## 4. 工具方法扩展设计

### 4.1 文件操作工具

**文件工具类**
```python
class FileUtils:
    @staticmethod
    def safe_read_csv(file_path: str, encoding: str = 'utf-8') -> pd.DataFrame:
        """安全读取CSV文件"""
        encodings_to_try = [encoding, 'shift_jis', 'cp932', 'latin1']
        
        for enc in encodings_to_try:
            try:
                return pd.read_csv(file_path, encoding=enc)
            except UnicodeDecodeError:
                continue
        
        raise UnicodeDecodeError(f"无法解码文件: {file_path}")
    
    @staticmethod
    def backup_file(file_path: str) -> str:
        """备份文件"""
        import shutil
        import datetime
        
        if not os.path.exists(file_path):
            return None
        
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_path = f"{file_path}.backup_{timestamp}"
        
        shutil.copy2(file_path, backup_path)
        return backup_path
```

### 4.2 数据验证工具

**数据验证工具类**
```python
class DataValidationUtils:
    @staticmethod
    def validate_csv_structure(file_path: str, expected_columns: List[str]) -> bool:
        """验证CSV文件结构"""
        try:
            df = pd.read_csv(file_path, nrows=1)
            return all(col in df.columns for col in expected_columns)
        except Exception:
            return False
    
    @staticmethod
    def check_data_integrity(data_tables: Dict[str, pd.DataFrame]) -> Dict[str, List[str]]:
        """检查数据完整性"""
        issues = {}
        
        for table_name, df in data_tables.items():
            table_issues = []
            
            # 检查空值
            if df.isnull().any().any():
                table_issues.append("存在空值")
            
            # 检查重复行
            if df.duplicated().any():
                table_issues.append("存在重复行")
            
            if table_issues:
                issues[table_name] = table_issues
        
        return issues
```

### 4.3 性能监控工具

**性能监控器**
```python
class PerformanceMonitor:
    def __init__(self):
        self.operation_times = {}
    
    def measure_time(self, operation_name: str):
        """测量操作时间装饰器"""
        def decorator(func):
            def wrapper(*args, **kwargs):
                start_time = time.time()
                result = func(*args, **kwargs)
                end_time = time.time()
                
                execution_time = end_time - start_time
                self.operation_times[operation_name] = execution_time
                
                logger.info(f"操作 {operation_name} 耗时: {execution_time:.3f}秒")
                return result
            return wrapper
        return decorator
    
    def get_performance_report(self) -> Dict:
        """获取性能报告"""
        return {
            'operation_times': self.operation_times,
            'slow_operations': {
                op: time for op, time in self.operation_times.items() 
                if time > 1.0  # 超过1秒的操作
            }
        }
```

---

**文档版本**: 1.0  
**最后更新**: 2025/10/23  
**维护者**: DNC开发团队
