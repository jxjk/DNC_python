## 基于VB.NET功能的测试用例

### 控件系统测试

#### ControlManager 测试
```python
class TestControlManager:
    """控件管理器测试 - 基于VB.NET控件管理逻辑"""
    
    def test_create_control(self):
        """测试动态创建控件"""
        from src.ui.control_manager import ControlManager
        
        control_manager = ControlManager()
        
        # 测试创建文本框控件
        textbox = control_manager.create_control(
            "TextBox", "test_textbox", 
            {"text": "测试文本", "width": 100, "height": 25}
        )
        
        assert textbox is not None
        assert textbox.objectName() == "test_textbox"
    
    def test_control_group_management(self):
        """测试控件组管理"""
        from src.ui.control_manager import ControlManager
        
        control_manager = ControlManager()
        
        # 创建控件组
        control_ids = ["control1", "control2", "control3"]
        control_manager.manage_control_group("test_group", control_ids)
        
        # 测试启用/禁用控件组
        control_manager.set_group_enabled("test_group", False)
        
        # 验证控件状态
        for control_id in control_ids:
            control = control_manager.controls.get(control_id)
            if control:
                assert not control.isEnabled()
```

#### 8种核心控件类型测试

**LoadControl 测试**
```python
class TestLoadControl:
    """Load控件测试 - 基于makeCntrlLoad"""
    
    def test_load_data_from_csv(self):
        """测试从CSV文件加载数据"""
        from src.ui.controls.load_control import LoadControl
        
        load_control = LoadControl("data/master/load.csv", {"field1": "NO", "field2": "TYPE"})
        data = load_control.load_data()
        
        assert not data.empty
        assert "NO" in data.columns
        assert "TYPE" in data.columns
    
    def test_data_validation(self):
        """测试数据验证"""
        from src.ui.controls.load_control import LoadControl
        
        load_control = LoadControl("data/master/load.csv", {})
        is_valid = load_control.validate_data()
        
        assert isinstance(is_valid, bool)
```

**InputControl 测试**
```python
class TestInputControl:
    """Input控件测试 - 基于makeCntrlInput"""
    
    def test_text_change_handling(self):
        """测试文本变更处理"""
        from src.ui.controls.input_control import InputControl
        
        input_control = InputControl("test_input", "numeric", {"min": 0, "max": 100})
        
        # 模拟文本变更
        input_control.handle_text_change("50")
        value = input_control.get_value()
        
        assert value == 50.0
    
    def test_input_validation(self):
        """测试输入验证"""
        from src.ui.controls.input_control import InputControl
        
        input_control = InputControl("test_input", "numeric", {"min": 0, "max": 100})
        
        # 测试有效输入
        assert input_control.validate_input("50") is True
        
        # 测试无效输入
        assert input_control.validate_input("abc") is False
        assert input_control.validate_input("-10") is False
        assert input_control.validate_input("150") is False
```

### 计算引擎测试扩展

#### ExpressionCalculator 测试
```python
class TestExpressionCalculator:
    """表达式计算器测试 - 基于getCalcResult"""
    
    def test_basic_calculation(self):
        """测试基本计算"""
        from src.utils.expression_calculator import ExpressionCalculator
        
        calculator = ExpressionCalculator()
        variables = {"x": 10, "y": 5}
        
        result = calculator.calculate("x + y", variables)
        assert result == 15.0
        
        result = calculator.calculate("x * y", variables)
        assert result == 50.0
    
    def test_function_calculation(self):
        """测试函数计算"""
        from src.utils.expression_calculator import ExpressionCalculator
        
        calculator = ExpressionCalculator()
        variables = {"values": [1, 2, 3, 4, 5]}
        
        result = calculator.calculate("MAX(values)", variables)
        assert result == 5.0
        
        result = calculator.calculate("MIN(values)", variables)
        assert result == 1.0
        
        result = calculator.calculate("ROUND(3.14159, 2)", {})
        assert result == 3.14
```

#### RelationJudge 测试
```python
class TestRelationJudge:
    """关系判断器测试 - 基于judgeRelation"""
    
    def test_relation_judgment(self):
        """测试关系判断"""
        from src.utils.relation_judge import RelationJudge
        
        judge = RelationJudge()
        
        # 测试等于关系
        assert judge.judge("=", 10, 10) is True
        assert judge.judge("=", 10, 5) is False
        
        # 测试不等于关系
        assert judge.judge("<>", 10, 5) is True
        assert judge.judge("<>", 10, 10) is False
        
        # 测试大于关系
        assert judge.judge(">", 10, 5) is True
        assert judge.judge(">", 5, 10) is False
        
        # 测试小于关系
        assert judge.judge("<", 5, 10) is True
        assert judge.judge("<", 10, 5) is False
```

#### PrecisionController 测试
```python
class TestPrecisionController:
    """精度控制器测试 - 基于四舍五入处理"""
    
    def test_rounding_operations(self):
        """测试四舍五入操作"""
        from src.utils.precision_controller import PrecisionController
        
        controller = PrecisionController(decimal_places=2)
        
        # 测试四舍五入
        assert controller.round_value(3.14159) == 3.14
        assert controller.round_value(2.71828) == 2.72
        assert controller.round_value(1.23456) == 1.23
    
    def test_display_formatting(self):
        """测试显示格式化"""
        from src.utils.precision_controller import PrecisionController
        
        controller = PrecisionController(decimal_places=4)
        
        formatted = controller.format_display(3.1415926535)
        assert formatted == "3.1416"
```

### 通信模块测试

#### NCProtocolHandler 测试
```python
class TestNCProtocolHandler:
    """NC协议处理器测试 - 基于makeSendTxt"""
    
    def test_rexroth_protocol_formatting(self):
        """测试Rexroth协议格式化"""
        from src.communication.nc_protocol_handler import NCProtocolHandler
        
        handler = NCProtocolHandler("rexroth")
        command = "MOVE"
        parameters = {"X": 100.0, "Y": 50.0, "Z": 25.0}
        
        message = handler.format_message(command, parameters)
        
        assert message is not None
        assert "X100.000" in message
        assert "Y50.000" in message
        assert "Z25.000" in message
    
    def test_brother_protocol_formatting(self):
        """测试Brother协议格式化"""
        from src.communication.nc_protocol_handler import NCProtocolHandler
        
        handler = NCProtocolHandler("brother")
        command = "G01"
        parameters = {"F": 1000, "X": 200.0}
        
        message = handler.format_message(command, parameters)
        
        assert message is not None
        assert "G01" in message
        assert "F1000" in message
```

#### NamedPipeClient 测试
```python
class TestNamedPipeClient:
    """命名管道客户端测试 - 基于NamedPipeAsyncClient"""
    
    @pytest.mark.asyncio
    async def test_pipe_connection(self):
        """测试管道连接"""
        from src.communication.named_pipe_client import NamedPipeClient
        
        client = NamedPipeClient("test_pipe")
        
        # 测试异步连接
        await client.connect()
        assert client.connected is True
    
    @pytest.mark.asyncio
    async def test_data_sending(self):
        """测试数据发送"""
        from src.communication.named_pipe_client import NamedPipeClient
        
        client = NamedPipeClient("test_pipe")
        await client.connect()
        
        # 测试异步发送数据
        test_data = "测试数据"
        await client.send_data(test_data)
        
        # 验证数据发送成功
        assert True  # 实际测试中需要验证数据是否成功发送
```

### 数据处理测试扩展

#### CSVLoader 测试
```python
class TestCSVLoader:
    """CSV文件加载器测试 - 基于LoadFileToTBL"""
    
    def test_csv_loading_with_encoding_detection(self):
        """测试带编码检测的CSV加载"""
        from src.data.csv_loader import CSVLoader
        from src.utils.encoding_detector import EncodingDetector
        
        encoding_detector = EncodingDetector()
        loader = CSVLoader(encoding_detector)
        
        data = loader.load_file("data/master/ini.csv")
        
        assert not data.empty
        assert isinstance(data, pd.DataFrame)
    
    def test_data_cleaning(self):
        """测试数据清理"""
        from src.data.csv_loader import CSVLoader
        from src.utils.encoding_detector import EncodingDetector
        
        encoding_detector = EncodingDetector()
        loader = CSVLoader(encoding_detector)
        
        # 创建测试数据
        test_data = pd.DataFrame({
            'col1': ['value1', ' value2 ', '', 'value3'],
            'col2': [1, 2, None, 4]
        })
        
        cleaned_data = loader._clean_data(test_data)
        
        assert cleaned_data is not None
        assert len(cleaned_data) == 3  # 空值和None应该被清理
```

#### TableSearcher 测试
```python
class TestTableSearcher:
    """表搜索引擎测试 - 基于searchT_relation"""
    
    def test_table_search(self):
        """测试表搜索"""
        from src.data.table_searcher import TableSearcher
        
        # 创建测试数据表
        test_tables = {
            "relation": pd.DataFrame({
                "NO": [1, 2, 3],
                "TYPE": ["A", "B", "C"],
                "VALUE": [10, 20, 30]
            })
        }
        
        searcher = TableSearcher(test_tables)
        
        # 测试搜索
        criteria = {"TYPE": "A"}
        results = searcher.search_table("relation", criteria)
        
        assert not results.empty
        assert len(results) == 1
        assert results.iloc[0]["VALUE"] == 10
    
    def test_search_cache(self):
        """测试搜索缓存"""
        from src.data.table_searcher import TableSearcher
        
        test_tables = {
            "relation": pd.DataFrame({
                "NO": [1, 2],
                "TYPE": ["A", "B"]
            })
        }
        
        searcher = TableSearcher(test_tables)
        
        # 第一次搜索
        results1 = searcher.search_table("relation", {"TYPE": "A"})
        
        # 第二次搜索相同条件，应该使用缓存
        results2 = searcher.search_table("relation", {"TYPE": "A"})
        
        assert len(searcher.search_cache) == 1
```

### 系统管理测试

#### SystemInitializer 测试
```python
class TestSystemInitializer:
    """系统初始化器测试 - 基于Frm_main_Load"""
    
    @pytest.mark.asyncio
    async def test_system_initialization(self):
        """测试系统初始化"""
        from src.system.system_initializer import SystemInitializer
        from src.config.config_manager import ConfigManager
        from src.data.data_manager import DataManager
        
        config_manager = ConfigManager()
        data_manager = DataManager()
        initializer = SystemInitializer(config_manager, data_manager)
        
        # 测试异步初始化
        await initializer.initialize_system()
        
        # 验证初始化完成
        assert True  # 实际测试中需要验证各组件是否初始化完成
    
    @pytest.mark.asyncio
    async def test_configuration_loading(self):
        """测试配置加载"""
        from src.system.system_initializer import SystemInitializer
        from src.config.config_manager import ConfigManager
        from src.data.data_manager import DataManager
        
        config_manager = ConfigManager()
        data_manager = DataManager()
        initializer = SystemInitializer(config_manager, data_manager)
        
        await initializer._load_configuration()
        
        # 验证配置已加载
        assert config_manager.config is not None
```

#### ControlStateManager 测试
```python
class TestControlStateManager:
    """控件状态管理器测试"""
    
    def test_control_state_management(self):
        """测试控件状态管理"""
        from src.system.control_state_manager import ControlStateManager
        
        state_manager = ControlStateManager()
        
        # 测试控件启用状态
        control_ids = ["btn_calc", "btn_save", "btn_export"]
        state_manager.set_controls_enabled(control_ids, False)
        
        # 验证控件状态
        for control_id in control_ids:
            state = state_manager.control_states.get(control_id)
            if state:
                assert state["enabled"] is False
    
    def test_control_group_operations(self):
        """测试控件组操作"""
        from src.system.control_state_manager import ControlStateManager
        
        state_manager = ControlStateManager()
        
        # 添加控件组
        group_controls = ["input1", "input2", "input3"]
        state_manager.add_control_group("input_group", group_controls)
        
        # 设置控件组状态
        state_manager.set_group_enabled("input_group", True)
        
        # 验证控件组状态
        assert "input_group" in state_manager.control_groups
```

### 工具方法测试

#### StringUtils 测试
```python
class TestStringUtils:
    """字符串工具类测试 - 基于VB.NET字符串处理函数"""
    
    def test_len_b_function(self):
        """测试LenB函数"""
        from src.utils.string_utils import StringUtils
        
        # 测试ASCII字符
        assert StringUtils.len_b("hello") == 5
        
        # 测试中文字符
        assert StringUtils.len_b("你好") == 4  # 每个中文字符2字节
    
    def test_to_half_adjust(self):
        """测试四舍五入处理"""
        from src.utils.string_utils import StringUtils
        
        assert StringUtils.to_half_adjust(3.14159, 2) == 3.14
        assert StringUtils.to_half_adjust(2.71828, 3) == 2.718
        assert StringUtils.to_half_adjust(1.23456, 0) == 1.0
    
    def test_make_format_str(self):
        """测试格式化字符串"""
        from src.utils.string_utils import StringUtils
        
        formatted = StringUtils.make_format_str("结果: {0:.2f}", 3.14159)
        assert formatted == "结果: 3.14"
```

#### SystemUtils 测试
```python
class TestSystemUtils:
    """系统工具类测试"""
    
    def test_get_all_controls(self):
        """测试获取所有子控件"""
        from src.utils.system_utils import SystemUtils
        from PyQt5.QtWidgets import QWidget, QVBoxLayout, QPushButton, QLineEdit
        
        parent = QWidget()
        layout = QVBoxLayout(parent)
        
        # 添加子控件
        button = QPushButton("测试按钮")
        line_edit = QLineEdit()
        layout.addWidget(button)
        layout.addWidget(line_edit)
        
        # 获取所有子控件
        controls = SystemUtils.get_all_controls(parent)
        
        assert len(controls) >= 2
        assert any(isinstance(ctrl, QPushButton) for ctrl in controls)
        assert any(isinstance(ctrl, QLineEdit) for ctrl in controls)
```

### 验证模块测试

#### NumericValidator 测试
```python
class TestNumericValidator:
    """数值验证器测试 - 基于chkTxtIsNumeric"""
    
    def test_numeric_validation(self):
        """测试数值验证"""
        from src.validation.numeric_validator import NumericValidator
        
        validator = NumericValidator()
        
        # 测试有效数值
        assert validator.validate("123") is True
        assert validator.validate("123.45") is True
        assert validator.validate("-123.45") is True
        
        # 测试无效数值
        assert validator.validate("abc") is False
        assert validator.validate("123abc") is False
        assert validator.validate("") is False
    
    def test_range_validation(self):
        """测试范围验证"""
        from src.validation.numeric_validator import NumericValidator
        
        validator = NumericValidator()
        
        # 测试范围内数值
# DNC参数计算系统 - 测试文档

## 测试概述

### 测试目标
确保DNC参数计算系统的功能正确性、性能稳定性和用户体验。

### 测试范围
- 单元测试：验证单个模块的功能
- 集成测试：验证模块间的协作
- 系统测试：验证整个系统的功能
- 性能测试：验证系统的性能指标
- 用户验收测试：验证用户需求满足度

### 测试环境
- **操作系统**: Windows 10/11, Linux, macOS
- **Python版本**: 3.8+
- **测试框架**: pytest
- **测试数据**: 包含在项目中的测试数据文件

## 单元测试

### 数据管理模块测试

#### DataManager 测试
```python
import pytest
from src.data.data_manager import DataManager

class TestDataManager:
    
    def test_load_master_data(self):
        """测试加载Master数据"""
        data_manager = DataManager("data/master")
        master_data = data_manager.load_master_data()
        
        assert isinstance(master_data, dict)
        assert "type_define.csv" in master_data
        assert "load.csv" in master_data
    
    def test_batch_read_large_csv(self):
        """测试分批读取大文件"""
        data_manager = DataManager()
        result = data_manager.batch_read_large_csv("data/master/load.csv", 1000)
        
        assert not result.empty
        assert len(result) > 0
    
    def test_validate_data_integrity(self):
        """测试数据完整性验证"""
        data_manager = DataManager()
        validation_results = data_manager.validate_data_integrity()
        
        assert isinstance(validation_results, dict)
        assert all(isinstance(v, bool) for v in validation_results.values())
```

#### CSVProcessor 测试
```python
class TestCSVProcessor:
    
    def test_read_csv_with_encoding_detection(self):
        """测试带编码检测的CSV读取"""
        from src.data.csv_processor import CSVProcessor
        
        processor = CSVProcessor()
        data = processor.read_csv_with_encoding_detection("data/master/ini.csv")
        
        assert not data.empty
    
    def test_fix_encoding_issues(self):
        """测试编码问题修复"""
        from src.data.csv_processor import CSVProcessor
        
        processor = CSVProcessor()
        fixed_data = processor.fix_encoding_issues("data/master/math.csv")
        
        assert not fixed_data.empty
```

### 计算引擎测试

#### CalculationEngine 测试
```python
class TestCalculationEngine:
    
    def test_calculate_parameters(self):
        """测试参数计算"""
        from src.utils.calculation import CalculationEngine
        from src.data.data_manager import DataManager
        
        data_manager = DataManager()
        calc_engine = CalculationEngine(data_manager)
        
        input_data = {
            "Teeth_num": 20,
            "Module": 2.5,
            "Pressure_angle": 20.0
        }
        
        results = calc_engine.calculate_parameters(input_data)
        
        assert isinstance(results, dict)
        assert "calculated_values" in results
        assert "macro_variables" in results
    
    def test_validate_relations(self):
        """测试关系验证"""
        from src.utils.calculation import CalculationEngine
        from src.data.data_manager import DataManager
        
        data_manager = DataManager()
        calc_engine = CalculationEngine(data_manager)
        
        test_data = {
            "value1": 10.0,
            "value2": 5.0
        }
        
        is_valid, errors = calc_engine.validate_relations(test_data)
        
        assert isinstance(is_valid, bool)
        assert isinstance(errors, list)
```

### 配置管理测试

#### ConfigManager 测试
```python
class TestConfigManager:
    
    def test_get_set_config(self):
        """测试配置获取和设置"""
        from src.config.config_manager import ConfigManager
        
        config_manager = ConfigManager("config/config.ini")
        
        # 测试设置配置
        config_manager.set_config("TEST", "test_key", "test_value")
        
        # 测试获取配置
        value = config_manager.get_config("TEST", "test_key")
        
        assert value == "test_value"
    
    def test_save_config(self):
        """测试配置保存"""
        from src.config.config_manager import ConfigManager
        
        config_manager = ConfigManager("config/config.ini")
        
        # 修改配置
        config_manager.set_config("TEST", "save_test", "saved_value")
        
        # 保存配置
        config_manager.save_config()
        
        # 重新加载验证
        new_config_manager = ConfigManager("config/config.ini")
        value = new_config_manager.get_config("TEST", "save_test")
        
        assert value == "saved_value"
```

## 集成测试

### 数据流集成测试
```python
class TestDataFlowIntegration:
    
    def test_complete_data_processing_flow(self):
        """测试完整的数据处理流程"""
        from src.data.data_manager import DataManager
        from src.utils.calculation import CalculationEngine
        from src.data.models import ProductType
        
        # 初始化组件
        data_manager = DataManager()
        calc_engine = CalculationEngine(data_manager)
        
        # 加载数据
        master_data = data_manager.load_master_data()
        
        # 验证数据完整性
        validation_results = data_manager.validate_data_integrity()
        
        # 执行计算
        input_params = {
            "Teeth_num": 25,
            "Module": 3.0,
            "Pressure_angle": 20.0
        }
        
        results = calc_engine.calculate_parameters(input_params)
        
        # 验证结果
        assert results is not None
        assert "calculated_values" in results
        assert "macro_variables" in results
        assert len(results["macro_variables"]) > 0
```

### 程序生成集成测试
```python
class TestProgramGenerationIntegration:
    
    def test_program_generation_flow(self):
        """测试程序生成流程"""
        from src.data.data_manager import DataManager
        from src.utils.calculation import CalculationEngine
        from src.ui.main_window import ProgramGenerator
        
        # 初始化组件
        data_manager = DataManager()
        calc_engine = CalculationEngine(data_manager)
        program_generator = ProgramGenerator(data_manager)
        
        # 计算参数
        input_params = {
            "Teeth_num": 30,
            "Module": 2.5,
            "Pressure_angle": 20.0
        }
        
        calculated_params = calc_engine.calculate_parameters(input_params)
        
        # 生成程序
        program_code = program_generator.generate_nc_program(
            "GPA18GT15040-A", 
            calculated_params
        )
        
        # 验证程序
        assert program_code is not None
        assert len(program_code) > 0
        assert "O0001" in program_code  # 程序头
```

## 系统测试

### 功能测试用例

#### 测试用例1: 基本参数计算
```python
def test_basic_parameter_calculation():
    """测试基本参数计算功能"""
    # 测试步骤
    # 1. 启动系统
    # 2. 选择产品类型 GPA18GT15040-A
    # 3. 输入基本参数: 齿数=20, 模数=2.5
    # 4. 执行计算
    # 5. 验证计算结果
    
    expected_results = {
        "outer_diameter": 52.5,
        "root_diameter": 47.5,
        "base_diameter": 46.98
    }
    
    # 执行测试并验证
    actual_results = execute_calculation_test("GPA18GT15040-A", 20, 2.5)
    
    for key, expected_value in expected_results.items():
        assert abs(actual_results[key] - expected_value) < 0.01
```

#### 测试用例2: 程序生成功能
```python
def test_program_generation():
    """测试程序生成功能"""
    # 测试步骤
    # 1. 计算参数
    # 2. 选择程序类型 prg1
    # 3. 生成程序
    # 4. 验证程序语法
    # 5. 验证程序内容
    
    program_code = generate_program_test("GPA18GT15040-A", "prg1")
    
    # 验证程序头
    assert program_code.startswith("O0001")
    
    # 验证程序尾
    assert program_code.strip().endswith("M30")
    
    # 验证包含必要的G代码
    assert "G00" in program_code
    assert "G01" in program_code
```

#### 测试用例3: 数据导出功能
```python
def test_data_export():
    """测试数据导出功能"""
    # 测试步骤
    # 1. 计算参数
    # 2. 导出为CSV格式
    # 3. 验证导出文件
    # 4. 验证数据完整性
    
    export_file = export_data_test("test_export.csv")
    
    # 验证文件存在
    assert os.path.exists(export_file)
    
    # 验证文件内容
    with open(export_file, 'r', encoding='utf-8') as f:
        content = f.read()
        assert "Teeth_num" in content
        assert "Module" in content
        assert "20" in content  # 测试数据
```

### 边界测试用例

#### 测试用例4: 边界值测试
```python
def test_boundary_values():
    """测试边界值情况"""
    test_cases = [
        {"Teeth_num": 1, "Module": 0.5},   # 最小齿数
        {"Teeth_num": 200, "Module": 10.0}, # 最大齿数
        {"Teeth_num": 0, "Module": 2.5},    # 无效齿数
        {"Teeth_num": 20, "Module": 0},     # 无效模数
    ]
    
    for i, test_case in enumerate(test_cases):
        try:
            results = execute_calculation_test(
                "GPA18GT15040-A", 
                test_case["Teeth_num"], 
                test_case["Module"]
            )
            
            # 对于有效测试用例，验证结果
            if i < 2:  # 前两个是有效测试用例
                assert results is not None
            else:  # 后两个是无效测试用例
                assert False, "应该抛出异常"
                
        except ValueError as e:
            # 对于无效测试用例，期望抛出异常
            if i >= 2:
                assert "无效" in str(e) or "错误" in str(e)
```

## 性能测试

### 数据加载性能测试
```python
class TestPerformance:
    
    def test_data_loading_performance(self):
        """测试数据加载性能"""
        import time
        
        data_manager = DataManager()
        
        start_time = time.time()
        master_data = data_manager.load_master_data()
        load_time = time.time() - start_time
        
        # 性能要求：加载时间 < 5秒
        assert load_time < 5.0, f"数据加载时间过长: {load_time:.2f}秒"
        
        print(f"数据加载时间: {load_time:.2f}秒")
    
    def test_calculation_performance(self):
        """测试计算性能"""
        import time
        
        data_manager = DataManager()
        calc_engine = CalculationEngine(data_manager)
        
        # 测试批量计算性能
        test_cases = [
            {"Teeth_num": 20, "Module": 2.5},
            {"Teeth_num": 30, "Module": 3.0},
            {"Teeth_num": 40, "Module": 2.0},
            {"Teeth_num": 50, "Module": 2.5},
        ]
        
        start_time = time.time()
        
        for test_case in test_cases:
            results = calc_engine.calculate_parameters(test_case)
            assert results is not None
        
        total_time = time.time() - start_time
        
        # 性能要求：平均计算时间 < 0.5秒
        avg_time = total_time / len(test_cases)
        assert avg_time < 0.5, f"平均计算时间过长: {avg_time:.2f}秒"
        
        print(f"平均计算时间: {avg_time:.2f}秒")
```

### 内存使用测试
```python
def test_memory_usage():
    """测试内存使用情况"""
    import psutil
    import os
    
    process = psutil.Process(os.getpid())
    
    # 记录初始内存
    initial_memory = process.memory_info().rss / 1024 / 1024  # MB
    
    # 执行内存密集型操作
    data_manager = DataManager()
    master_data = data_manager.load_master_data()
    
    # 记录峰值内存
    peak_memory = process.memory_info().rss / 1024 / 1024  # MB
    
    memory_increase = peak_memory - initial_memory
    
    # 内存要求：内存增加 < 500MB
    assert memory_increase < 500, f"内存使用过多: {memory_increase:.2f}MB"
    
    print(f"内存增加: {memory_increase:.2f}MB")
```

## 用户界面测试

### 界面响应测试
```python
class TestUIResponsiveness:
    
    def test_ui_loading_time(self):
        """测试界面加载时间"""
        import time
        
        start_time = time.time()
        
        # 模拟界面加载
        main_window = MainWindow()
        main_window.show()
        
        load_time = time.time() - start_time
        
        # 性能要求：界面加载时间 < 3秒
        assert load_time < 3.0, f"界面加载时间过长: {load_time:.2f}秒"
        
        print(f"界面加载时间: {load_time:.2f}秒")
    
    def test_ui_interaction_responsiveness(self):
        """测试界面交互响应性"""
        import time
        
        main_window = MainWindow()
        
        # 测试按钮点击响应
        start_time = time.time()
        main_window.calculate_button.click()
        response_time = time.time() - start_time
        
        # 性能要求：响应时间 < 0.1秒
        assert response_time < 0.1, f"界面响应时间过长: {response_time:.2f}秒"
        
        print(f"界面响应时间: {response_time:.2f}秒")
```

## 测试数据

### 测试数据文件
测试数据位于 `tests/test_data/` 目录：

- `test_type_define.csv` - 测试产品类型定义
- `test_load.csv` - 测试主数据
- `test_calc.csv` - 测试计算定义
- `test_relation.csv` - 测试关系验证

### 测试数据生成
```python
def generate_test_data():
    """生成测试数据"""
    test_data = {
        "type_define.csv": [
            ["NO", "TYPE", "DEFINE1", "DEFINE2"],
            [1, "TEST001", "测试类型1", "测试定义1"],
            [2, "TEST002", "测试类型2", "测试定义2"]
        ],
        "load.csv": [
            ["NO", "TYPE", "DRAWING", "DISPFLG", "#1", "#2"],
            [1, "TEST001", "TEST001.dwg", "1", "20", "2.5"],
            [2, "TEST002", "TEST002.dwg", "1", "30", "3.0"]
        ]
    }
    
    for filename, data in test_data.items():
        filepath = f"tests/test_data/{filename}"
        with open(filepath, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerows(data)
```

## 测试报告

### 测试执行
```bash
# 运行所有测试
pytest tests/ -v

# 运行特定测试类别
pytest tests/unit/ -v
pytest tests/integration/ -v
pytest tests/performance/ -v

# 生成测试报告
pytest tests/ --html=reports/test_report.html
```

### 测试覆盖率
```bash
# 生成测试覆盖率报告
pytest tests/ --cov=src --cov-report=html
```

### 测试结果分析
测试结果将生成以下报告：
- `reports/test_report.html` - 测试执行报告
- `reports/coverage/` - 代码覆盖率报告
- `reports/performance/` - 性能测试报告

## 持续集成

### GitHub Actions 配置
```yaml
name: DNC System Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        python-version: [3.8, 3.9, 3.10]
    
    steps:
    - uses: actions/checkout@v2
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
    
    - name: Run tests
      run: |
        pytest tests/ -v --cov=src --cov-report=xml
    
    - name: Upload coverage
      uses: codecov/codecov-action@v2
```

---

**测试文档版本**: 1.0  
**最后更新**: 2025/10/23  
**测试负责人**: DNC测试团队
