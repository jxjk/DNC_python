# DNC系统算法设计文档

## 1. 型号识别算法

### 1.1 QR码识别算法

#### 1.1.1 固定字符删除模式 (Qrmode=0)

**算法描述**:
从QR码字符串开头删除固定数量的字符，剩余部分作为型号。

**算法步骤**:
1. 读取QR码字符串
2. 获取配置的删除字符数 `BarCodeHeaderStrNum`
3. 从字符串开头删除指定数量的字符
4. 剩余字符串即为型号

**伪代码**:
```
function fixed_char_delete_mode(qr_code):
    delete_chars = config.get('BarCodeHeaderStrNum', 11)
    if len(qr_code) <= delete_chars:
        raise ValueError("QR码长度不足")
    model = qr_code[delete_chars:]
    return process_model(model)
```

**示例**:
```
输入: "PO@C-CCC10-20A-P5-30"
删除前11字符: "PO@C-CCC10" (11字符)
剩余: "C-CCC10-20A-P5-30"
```

#### 1.1.2 分隔符分割模式 (Qrmode=1)

**算法描述**:
使用分隔符分割QR码字符串，按位置提取型号、PO和数量信息。

**算法步骤**:
1. 读取QR码字符串
2. 使用配置的分隔符 `QRspltStr` 分割字符串
3. 按配置位置提取各部分信息:
   - `MODELplc`: 型号位置
   - `POplc`: PO位置  
   - `QTYplc`: 数量位置
4. 返回提取的信息

**伪代码**:
```
function splitter_mode(qr_code):
    splitter = config.get('QRspltStr', '@')
    parts = qr_code.split(splitter)
    
    model_place = config.get('MODELplc', 2)
    po_place = config.get('POplc', 1)
    qty_place = config.get('QTYplc', 3)
    
    if len(parts) < max(model_place, po_place, qty_place):
        raise ValueError("QR码格式不正确")
    
    return ModelInfo(
        model=parts[model_place - 1],
        po=parts[po_place - 1],
        quantity=parts[qty_place - 1]
    )
```

**示例**:
```
输入: "PO@C-CCC10-20A-P5-30@100"
分割: ["PO", "C-CCC10-20A-P5-30", "100"]
型号位置2: "C-CCC10-20A-P5-30"
PO位置1: "PO"
数量位置3: "100"
```

### 1.2 型号分割算法

#### 1.2.1 基础分割算法

**算法描述**:
使用"-"字符分割型号字符串，并进行前缀处理。

**算法步骤**:
1. 使用"-"分割型号字符串
2. 检查第一个分割部分是否在header.csv中定义为删除
3. 如果是删除前缀，则移除该部分
4. 识别内部定义(size1, size2等)

**伪代码**:
```
function process_model(model):
    parts = model.split('-')
    
    # 前缀处理
    first_part = parts[0]
    if header_config.get(first_part) == 'del':
        parts = parts[1:]
    
    # 内部定义识别
    definitions = []
    size_count = 0
    
    for part in parts:
        if part[0].isdigit():
            size_count += 1
            definitions.append(f"size{size_count}")
        else:
            definitions.append("-")
    
    return {
        'original_model': model,
        'processed_parts': parts,
        'definitions': definitions
    }
```

**示例**:
```
输入: "C-CCC10-20A-P5-30"
分割: ["C", "CCC10", "20A", "P5", "30"]
前缀处理: "C"在header.csv中定义为del → 移除
处理后: ["CCC10", "20A", "P5", "30"]
内部定义: ["-", "size1", "-", "size2"]
```

## 2. 程序匹配算法

### 2.1 反向字符删除匹配算法

#### 2.1.1 算法原理

**核心思想**:
从完整型号字符串的末尾开始，逐个删除字符，在type_define.csv中搜索匹配项。

**算法优势**:
- 支持模糊匹配
- 处理型号变体
- 容错性强

#### 2.1.2 算法实现

**伪代码**:
```
function match_program(model):
    for i in range(len(model), 0, -1):
        search_str = model[:i]
        matched_no = search_type_define(search_str)
        
        if matched_no:
            program_order = get_program_order(matched_no)
            return ProgramInfo(
                program_no=matched_no,
                program_order=program_order,
                matched_string=search_str
            )
    
    raise ValueError("未找到匹配的程序")
```

**搜索函数**:
```
function search_type_define(search_str):
    for row in type_define_data:
        if row['TYPE'] == search_str:
            return int(row['NO'])
    return None
```

**匹配过程示例**:
```
搜索字符串: "C-CCC10-20A-P5S-30"
匹配过程:
"C-CCC10-20A-P5S-30" → 无匹配
"C-CCC10-20A-P5S-3" → 无匹配
"C-CCC10-20A-P5S-" → 无匹配
...
"C-CCC" → 匹配type_define.csv中NO=3的记录
```

### 2.2 程序顺序获取算法

#### 2.2.1 算法描述

从type_prg.csv中获取程序的显示顺序。

**伪代码**:
```
function get_program_order(program_no):
    row = search_in_dataframe(type_prg_data, 'NO', program_no)
    if not row:
        raise ValueError(f"未找到程序顺序: {program_no}")
    
    return [
        row['prg1'],
        row['prg2'], 
        row['prg3']
    ]
```

## 3. 参数计算算法

### 3.1 多层计算逻辑

#### 3.1.1 计算流程

**整体流程**:
```
程序确定 → 加载参数 → 变量替换 → 值转换 → 计算执行 → 结果显示
```

**详细步骤**:
1. 从load.csv加载程序参数
2. 对每个参数值进行处理:
   - 如果是直接值: 直接使用
   - 如果是define: 执行define处理流程
   - 如果是size: 从型号分割中获取
3. 执行多层计算:
   - 变量替换 (define.csv)
   - 值转换 (chngValue.csv) 
   - 计算执行 (calc.csv)

#### 3.1.2 Define处理算法

**伪代码**:
```
function process_define(define_name, model_parts):
    define_rules = get_define_rules(define_name)
    
    for rule in define_rules:
        for part in model_parts:
            if part.startswith(rule['STR']):
                result = part.replace(rule['BEFORE'], rule['AFTER'])
                
                # 值转换处理
                if rule['CHNGVL']:
                    result = process_chng_value(rule['CHNGVL'], result)
                
                # 计算处理
                if rule['CALC']:
                    result = process_calc(rule['CALC'], result)
                
                return result
    
    return ""  # 未找到匹配
```

**Define规则示例** (define.csv):
```csv
DEFINE,STR,BEFORE,AFTER,CHNGVL,CALC
define3-2,P,P0,0,chngS,
define3-2,P,P1,1,chngS,
define3-2,P,P2,2,chngS,
define3-2,P,P5,5,chngS,calc2-2
```

**处理示例**:
```
输入型号部分: "P5"
匹配规则: P5 → 5
值转换: chngS处理 "5" → "5" (无变化)
计算: calc2-2处理 "5" → "5 + 1" = "6"
最终结果: "6"
```

### 3.2 值转换算法

#### 3.2.1 算法描述

根据chngValue.csv进行值转换。

**伪代码**:
```
function process_chng_value(chng_name, value):
    chng_rules = get_chng_rules(chng_name)
    
    for rule in chng_rules:
        if rule['BEFORE'] in value:
            return value.replace(rule['BEFORE'], rule['AFTER'])
    
    return value  # 无匹配规则，返回原值
```

**值转换示例** (chngValue.csv):
```csv
DEFINE,BEFORE,AFTER
chngS,S,1
```

**处理示例**:
```
输入值: "5S"
匹配规则: "S" → "1"
转换结果: "51"
```

### 3.3 计算执行算法

#### 3.3.1 表达式计算

**算法描述**:
支持变量替换和数学表达式计算。

**伪代码**:
```
function process_calc(calc_name, value):
    calc_rules = get_calc_rules(calc_name)
    
    # 构建计算表达式
    expression = build_expression(calc_rules, value)
    
    try:
        result = eval_expression(expression)
        return str(result)
    except Exception as e:
        logger.error(f"计算错误: {expression}, 错误: {e}")
        return value  # 计算失败返回原值
```

**计算规则示例** (calc.csv):
```csv
DEFINE,1,2,3,4,5,6,7,8,9,10
calc2-2,=,calc2-2,+,1,,,,,,,
```

**处理示例**:
```
输入值: "51"
计算表达式: "51 + 1"
计算结果: "52"
```

## 4. 关系验证算法

### 4.1 条件判断算法

#### 4.1.1 算法描述

根据relation.csv中的条件进行验证。

**伪代码**:
```
function judge_relation(relation_name, parameters):
    relation_rules = get_relation_rules(relation_name)
    
    for rule in relation_rules:
        if evaluate_condition(rule, parameters):
            return rule['VALUE']
    
    return None  # 无匹配条件
```

#### 4.1.2 条件评估算法

**伪代码**:
```
function evaluate_condition(rule, parameters):
    conditions = parse_conditions(rule)
    result = True
    
    for condition in conditions:
        if not evaluate_single_condition(condition, parameters):
            result = False
            break
    
    return result
```

**关系规则示例** (relation.csv):
```csv
DEFINE,VALUE,1,2,3,4,5,6,7,8
relation10,1,and,#505M,>=,0,and,#505M,<=,1
relation10,#505M,and,#505M,>,1
```

**条件解析**:
```
规则1: #505M >= 0 and #505M <= 1 → 返回 "1"
规则2: #505M > 1 → 返回 #505M的值
```

## 5. 控件管理算法

### 5.1 动态控件创建算法

#### 5.1.1 控件工厂算法

**伪代码**:
```
class ControlFactory:
    def create_control(self, config):
        control_type = config['KIND']
        
        if control_type == 'load':
            return self.create_load_control(config)
        elif control_type == 'input':
            return self.create_input_control(config)
        # ... 其他控件类型
    
    def create_load_control(self, config):
        widget = QWidget()
        layout = QHBoxLayout(widget)
        
        label = QLabel(f"{config['MACRO']}: ")
        value_label = QLabel()
        
        layout.addWidget(label)
        layout.addWidget(value_label)
        
        return widget
```

#### 5.1.2 控件布局算法

**算法描述**:
根据cntrl.csv配置动态创建和布局控件。

**伪代码**:
```
function setup_controls(program_no):
    # 清空现有控件
    clear_controls()
    
    # 加载控件配置
    controls_config = load_controls_config(program_no)
    
    # 创建控件
    for config in controls_config:
        if config['DISPFLG'] == '1':  # 显示标志为1才创建
            control = control_factory.create_control(config)
            add_control_to_layout(control)
```

## 6. 性能优化算法

### 6.1 缓存算法

#### 6.1.1 数据缓存策略

**算法描述**:
使用LRU(最近最少使用)缓存策略缓存频繁访问的数据。

**伪代码**:
```
class DataCache:
    def __init__(self, max_size=1000):
        self.cache = OrderedDict()
        self.max_size = max_size
    
    def get(self, key):
        if key in self.cache:
            # 移动到最近使用位置
            value = self.cache.pop(key)
            self.cache[key] = value
            return value
        return None
    
    def set(self, key, value):
        if key in self.cache:
            self.cache.pop(key)
        elif len(self.cache) >= self.max_size:
            # 移除最久未使用的项
            self.cache.popitem(last=False)
        self.cache[key] = value
```

#### 6.1.2 文件缓存算法

**伪代码**:
```
class FileCache:
    def load_csv(self, file_path):
        if file_path in self.cache:
            return self.cache[file_path]
        
        df = pd.read_csv(file_path)
        self.cache[file_path] = df
        return df
```

### 6.2 懒加载算法

#### 6.2.1 按需加载算法

**算法描述**:
只在需要时加载数据文件，减少内存占用。

**伪代码**:
```
class LazyDataLoader:
    def __init__(self):
        self.loaded_files = {}
    
    def get_data(self, file_path):
        if file_path not in self.loaded_files:
            self.loaded_files[file_path] = self.load_file(file_path)
        return self.loaded_files[file_path]
```

## 7. 错误处理算法

### 7.1 异常处理算法

#### 7.1.1 分级异常处理

**算法描述**:
根据异常类型采取不同的处理策略。

**伪代码**:
```
function handle_exception(exception):
    if isinstance(exception, FileNotFoundError):
        logger.error(f"文件未找到: {exception.filename}")
        show_user_error(f"配置文件缺失: {exception.filename}")
        
    elif isinstance(exception, ValueError):
        logger.warning(f"数据格式错误: {exception}")
        show_user_warning(f"输入数据格式不正确")
        
    elif isinstance(exception, CalculationError):
        logger.error(f"计算错误: {exception}")
        show_user_error("参数计算失败，请检查输入")
        
    else:
        logger.critical(f"未知错误: {exception}")
        show_user_error("系统发生未知错误")
```

#### 7.1.2 优雅降级算法

**算法描述**:
在异常情况下提供基本功能。

**伪代码**:
```
function safe_calculate(program_no, model_parts):
    try:
        return calculation_engine.calculate(program_no, model_parts)
    except CalculationError:
        # 返回默认值或简化计算
        return get_default_parameters(program_no)
```

## 8. 通信协议算法

### 8.1 消息格式化算法

#### 8.1.1 NC协议消息生成

**算法描述**:
根据参数生成NC机床可识别的消息。

**伪代码**:
```
function generate_nc_message(parameters, protocol_type):
    if protocol_type == 'rexroth':
        return generate_rexroth_message(parameters)
    elif protocol_type == 'brother':
        return generate_brother_message(parameters)
    else:
        raise ValueError(f"不支持的协议: {protocol_type}")

function generate_rexroth_message(parameters):
    commands = []
    for macro, value in parameters.items():
        command = f"{macro}={value}"
        commands.append(command)
    return "\n".join(commands)
```

### 8.2 数据校验算法

#### 8.2.1 通信数据校验

**算法描述**:
验证发送和接收数据的完整性。

**伪代码**:
```
function validate_send_data(parameters):
    for macro, value in parameters.items():
        if not is_valid_macro(macro):
            raise ValueError(f"无效的宏变量: {macro}")
        if not is_valid_value(value):
            raise ValueError(f"无效的值: {value}")
    
    return True
```

---

**文档版本**: v1.0  
**最后更新**: 2025年10月24日  
**维护者**: DNC开发团队
