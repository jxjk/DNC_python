# DNC系统测试策略和用例

## 1. 测试策略

### 1.1 测试目标

#### 1.1.1 质量目标
- **功能正确性**: 确保所有功能按需求正确实现
- **性能要求**: 满足系统性能指标要求
- **稳定性**: 保证系统长期稳定运行
- **兼容性**: 支持多种操作系统和NC协议

#### 1.1.2 测试范围
- 型号识别功能测试
- 参数计算功能测试
- 用户界面测试
- NC通信测试
- 数据文件处理测试
- 系统集成测试

### 1.2 测试方法

#### 1.2.1 单元测试
- **测试对象**: 单个函数、类、方法
- **测试工具**: pytest, unittest
- **覆盖率目标**: 80%以上代码覆盖率

#### 1.2.2 集成测试
- **测试对象**: 模块间接口和交互
- **测试方法**: 接口测试、数据流测试
- **测试重点**: 模块集成和数据传递

#### 1.2.3 系统测试
- **测试对象**: 完整系统功能
- **测试环境**: 模拟生产环境
- **测试内容**: 端到端业务流程

#### 1.2.4 验收测试
- **测试对象**: 用户需求满足度
- **测试人员**: 最终用户
- **测试标准**: 用户验收标准

### 1.3 测试环境

#### 1.3.1 开发环境
- **操作系统**: Windows 10/11, Linux, macOS
- **Python版本**: 3.8+
- **测试工具**: pytest, coverage, mock

#### 1.3.2 测试环境
- **硬件配置**: 模拟生产环境硬件
- **网络环境**: 隔离的测试网络
- **数据环境**: 测试专用数据文件

#### 1.3.3 生产环境
- **硬件配置**: 实际生产硬件
- **网络环境**: 生产网络环境
- **数据环境**: 生产数据备份

## 2. 单元测试用例

### 2.1 型号识别模块测试

#### 2.1.1 固定字符删除模式测试

**测试用例**: test_fixed_char_delete_mode
```python
def test_fixed_char_delete_mode():
    """测试固定字符删除模式"""
    recognizer = ModelRecognizer()
    
    # 测试正常情况
    qr_code = "PO@C-CCC10-20A-P5-30"
    result = recognizer._fixed_char_delete_mode(qr_code)
    assert result.model == "C-CCC10-20A-P5-30"
    
    # 测试QR码长度不足
    with pytest.raises(ValueError):
        recognizer._fixed_char_delete_mode("short")
```

**测试用例**: test_fixed_char_delete_mode_with_config
```python
def test_fixed_char_delete_mode_with_config():
    """测试带配置的固定字符删除模式"""
    config = {'BarCodeHeaderStrNum': '5'}
    recognizer = ModelRecognizer(config)
    
    qr_code = "12345ABCDE"
    result = recognizer._fixed_char_delete_mode(qr_code)
    assert result.model == "ABCDE"
```

#### 2.1.2 分隔符分割模式测试

**测试用例**: test_splitter_mode
```python
def test_splitter_mode():
    """测试分隔符分割模式"""
    config = {
        'QRspltStr': '@',
        'MODELplc': '2',
        'POplc': '1', 
        'QTYplc': '3'
    }
    recognizer = ModelRecognizer(config)
    
    qr_code = "PO12345@C-CCC10-20A-P5-30@100"
    result = recognizer._splitter_mode(qr_code)
    
    assert result.model == "C-CCC10-20A-P5-30"
    assert result.po == "PO12345"
    assert result.quantity == "100"
```

**测试用例**: test_splitter_mode_invalid_format
```python
def test_splitter_mode_invalid_format():
    """测试分隔符分割模式格式错误"""
    config = {
        'QRspltStr': '@',
        'MODELplc': '5'  # 位置超出范围
    }
    recognizer = ModelRecognizer(config)
    
    qr_code = "PO@MODEL@100"
    with pytest.raises(ValueError):
        recognizer._splitter_mode(qr_code)
```

#### 2.1.3 型号分割算法测试

**测试用例**: test_model_split_algorithm
```python
def test_model_split_algorithm():
    """测试型号分割算法"""
    processor = ModelProcessor()
    
    # 测试正常分割
    model = "C-CCC10-20A-P5-30"
    result = processor.split_model(model)
    
    expected_parts = ["CCC10", "20A", "P5", "30"]
    expected_definitions = ["-", "size1", "-", "size2"]
    
    assert result['processed_parts'] == expected_parts
    assert result['definitions'] == expected_definitions
```

**测试用例**: test_model_split_with_header
```python
def test_model_split_with_header():
    """测试带前缀处理的型号分割"""
    header_config = {'C': 'del'}
    processor = ModelProcessor(header_config)
    
    model = "C-CCC10-20A-P5-30"
    result = processor.split_model(model)
    
    # 验证前缀C被删除
    assert "C" not in result['processed_parts']
    assert result['processed_parts'][0] == "CCC10"
```

### 2.2 程序匹配模块测试

#### 2.2.1 反向字符删除匹配测试

**测试用例**: test_reverse_char_delete_match
```python
def test_reverse_char_delete_match():
    """测试反向字符删除匹配算法"""
    type_define_data = [
        {'NO': '1', 'TYPE': 'AAA'},
        {'NO': '2', 'TYPE': 'C-CCC'},
        {'NO': '3', 'TYPE': 'C-CCC10'}
    ]
    matcher = ProgramMatcher(type_define_data)
    
    # 测试精确匹配
    model = "C-CCC10-20A-P5-30"
    result = matcher.match_program(model)
    assert result.program_no == 3
    assert result.matched_string == "C-CCC10"
    
    # 测试模糊匹配
    model = "C-CCC10-20A-P5S-30"  # 变体型号
    result = matcher.match_program(model)
    assert result.program_no == 2  # 匹配到C-CCC
    assert result.matched_string == "C-CCC"
```

**测试用例**: test_no_match_found
```python
def test_no_match_found():
    """测试无匹配情况"""
    type_define_data = [{'NO': '1', 'TYPE': 'AAA'}]
    matcher = ProgramMatcher(type_define_data)
    
    model = "UNKNOWN-MODEL"
    with pytest.raises(ValueError, match="未找到匹配的程序"):
        matcher.match_program(model)
```

#### 2.2.2 程序顺序获取测试

**测试用例**: test_get_program_order
```python
def test_get_program_order():
    """测试程序顺序获取"""
    type_prg_data = [
        {'NO': '1', 'prg1': '程序A', 'prg2': '程序B', 'prg3': '程序C'}
    ]
    matcher = ProgramMatcher(type_prg_data=type_prg_data)
    
    result = matcher._get_program_order(1)
    expected = ['程序A', '程序B', '程序C']
    assert result == expected
```

### 2.3 参数计算模块测试

#### 2.3.1 Define处理测试

**测试用例**: test_define_processing
```python
def test_define_processing():
    """测试Define处理"""
    define_rules = [
        {'DEFINE': 'define3-2', 'STR': 'P', 'BEFORE': 'P5', 'AFTER': '5', 'CHNGVL': 'chngS', 'CALC': 'calc2-2'}
    ]
    engine = CalculationEngine(define_rules=define_rules)
    
    model_parts = ["CCC10", "20A", "P5", "30"]
    result = engine._process_define('define3-2', model_parts)
    
    assert result == "6"  # P5 → 5 → 5+1=6
```

**测试用例**: test_define_no_match
```python
def test_define_no_match():
    """测试Define无匹配情况"""
    define_rules = [{'DEFINE': 'define1', 'STR': 'X', 'BEFORE': 'X1', 'AFTER': '1'}]
    engine = CalculationEngine(define_rules=define_rules)
    
    model_parts = ["A", "B", "C"]
    result = engine._process_define('define1', model_parts)
    
    assert result == ""  # 无匹配返回空字符串
```

#### 2.3.2 值转换测试

**测试用例**: test_value_conversion
```python
def test_value_conversion():
    """测试值转换"""
    chng_rules = [
        {'DEFINE': 'chngS', 'BEFORE': 'S', 'AFTER': '1'}
    ]
    engine = CalculationEngine(chng_rules=chng_rules)
    
    result = engine._process_chng_value('chngS', '5S')
    assert result == "51"
```

**测试用例**: test_value_conversion_no_match
```python
def test_value_conversion_no_match():
    """测试值转换无匹配"""
    chng_rules = [{'DEFINE': 'chngS', 'BEFORE': 'S', 'AFTER': '1'}]
    engine = CalculationEngine(chng_rules=chng_rules)
    
    result = engine._process_chng_value('chngS', '5A')
    assert result == "5A"  # 无匹配返回原值
```

#### 2.3.3 计算执行测试

**测试用例**: test_calculation_execution
```python
def test_calculation_execution():
    """测试计算执行"""
    calc_rules = [
        {'DEFINE': 'calc2-2', '1': '=', '2': 'calc2-2', '3': '+', '4': '1'}
    ]
    engine = CalculationEngine(calc_rules=calc_rules)
    
    result = engine._process_calc('calc2-2', '5')
    assert result == "6"  # 5 + 1 = 6
```

**测试用例**: test_calculation_error
```python
def test_calculation_error():
    """测试计算错误处理"""
    calc_rules = [
        {'DEFINE': 'invalid_calc', '1': '=', '2': 'invalid', '3': '+', '4': '1'}
    ]
    engine = CalculationEngine(calc_rules=calc_rules)
    
    # 无效表达式应返回原值
    result = engine._process_calc('invalid_calc', '5')
    assert result == "5"
```

### 2.4 关系验证模块测试

#### 2.4.1 条件判断测试

**测试用例**: test_relation_judgment
```python
def test_relation_judgment():
    """测试关系判断"""
    relation_rules = [
        {'DEFINE': 'relation10', 'VALUE': '1', '1': 'and', '2': '#505M', '3': '>=', '4': '0', '5': 'and', '6': '#505M', '7': '<=', '8': '1'},
        {'DEFINE': 'relation10', 'VALUE': '#505M', '1': 'and', '2': '#505M', '3': '>', '4': '1'}
    ]
    validator = RelationValidator(relation_rules)
    
    # 测试条件1: 0 <= #505M <= 1
    parameters = {'#505M': '0.5'}
    result = validator.judge_relation('relation10', parameters)
    assert result == "1"
    
    # 测试条件2: #505M > 1
    parameters = {'#505M': '2'}
    result = validator.judge_relation('relation10', parameters)
    assert result == "2"
```

**测试用例**: test_no_relation_match
```python
def test_no_relation_match():
    """测试无关系匹配"""
    relation_rules = [{'DEFINE': 'relation1', 'VALUE': '1', '1': 'and', '2': '#500', '3': '==', '4': '10'}]
    validator = RelationValidator(relation_rules)
    
    parameters = {'#500': '20'}
    result = validator.judge_relation('relation1', parameters)
    assert result is None
```

## 3. 集成测试用例

### 3.1 型号识别集成测试

**测试用例**: test_model_recognition_integration
```python
def test_model_recognition_integration():
    """测试型号识别完整流程"""
    # 设置测试配置
    config = {
        'QRmode': '1',
        'QRspltStr': '@',
        'MODELplc': '2',
        'POplc': '1',
        'QTYplc': '3'
    }
    
    # 创建完整处理链
    recognizer = ModelRecognizer(config)
    processor = ModelProcessor()
    matcher = ProgramMatcher()
    
    # 执行完整流程
    qr_code = "PO12345@C-CCC10-20A-P5-30@100"
    model_info = recognizer.recognize_model(qr_code)
    processed_model = processor.process_model(model_info.model)
    program_info = matcher.match_program(processed_model['original_model'])
    
    # 验证结果
    assert model_info.po == "PO12345"
    assert model_info.quantity == "100"
    assert program_info.program_no is not None
```

### 3.2 参数计算集成测试

**测试用例**: test_parameter_calculation_integration
```python
def test_parameter_calculation_integration():
    """测试参数计算完整流程"""
    # 准备测试数据
    program_no = 1
    model_parts = ["CCC10", "20A", "P5", "30"]
    
    # 创建计算引擎
    engine = CalculationEngine()
    
    # 执行计算
    parameters = engine.calculate(program_no, model_parts)
    
    # 验证计算结果
    assert isinstance(parameters, dict)
    assert len(parameters) > 0
    for key, value in parameters.items():
        assert key.startswith('#')
        assert value is not None
```

### 3.3 控件管理集成测试

**测试用例**: test_control_management_integration
```python
def test_control_management_integration():
    """测试控件管理完整流程"""
    # 创建控件工厂和配置
    factory = ControlFactory()
    controls_config = [
        {'KIND': 'load', 'MACRO': '#500', 'DISPFLG': '1'},
        {'KIND': 'input', 'MACRO': '#501', 'DISPFLG': '1'}
    ]
    
    # 创建控件
    controls = []
    for config in controls_config:
        if config['DISPFLG'] == '1':
            control = factory.create_control(config)
            controls.append(control)
    
    # 验证控件创建
    assert len(controls) == 2
    assert all(isinstance(control, QWidget) for control in controls)
```

## 4. 系统测试用例

### 4.1 端到端业务流程测试

**测试用例**: test_end_to_end_workflow
```python
def test_end_to_end_workflow():
    """测试端到端业务流程"""
    # 启动应用
    app = Application()
    app.initialize()
    
    # 模拟用户操作
    # 1. 输入型号
    qr_code = "PO12345@C-CCC10-20A-P5-30@100"
    app.ui_manager.input_model(qr_code)
    
    # 2. 验证型号识别
    current_model = app.ui_manager.get_current_model()
    assert current_model == "C-CCC10-20A-P5-30"
    
    # 3. 验证程序匹配
    programs = app.ui_manager.get_available_programs()
    assert len(programs) > 0
    
    # 4. 选择程序
    app.ui_manager.select_program(programs[0])
    
    # 5. 验证参数计算
    parameters = app.ui_manager.get_calculated_parameters()
    assert len(parameters) > 0
    
    # 6. 验证界面更新
    assert app.ui_manager.are_parameters_displayed()
```

### 4.2 性能测试用例

**测试用例**: test_performance_model_recognition
```python
def test_performance_model_recognition():
    """测试型号识别性能"""
    recognizer = ModelRecognizer()
    
    # 测试大量型号识别
    test_cases = [
        "PO@AAA-10-20-30@100",
        "PO@BBB-15-25-35@200", 
        "PO@CCC-20-30-40@300"
    ] * 1000  # 3000个测试用例
    
    start_time = time.time()
    
    for qr_code in test_cases:
        recognizer.recognize_model(qr_code)
    
    end_time = time.time()
    execution_time = end_time - start_time
    
    # 性能要求: 3000个型号识别在10秒内完成
    assert execution_time < 10.0
    print(f"型号识别性能: {len(test_cases)}个型号用时{execution_time:.2f}秒")
```

**测试用例**: test_performance_parameter_calculation
```python
def test_performance_parameter_calculation():
    """测试参数计算性能"""
    engine = CalculationEngine()
    
    # 准备测试数据
    test_cases = []
    for i in range(1000):
        program_no = (i % 3) + 1  # 循环使用程序1-3
        model_parts = [f"MODEL{i}", f"SIZE{i%10}", f"TYPE{i%5}"]
        test_cases.append((program_no, model_parts))
    
    start_time = time.time()
    
    for program_no, model_parts in test_cases:
        engine.calculate(program_no, model_parts)
    
    end_time = time.time()
    execution_time = end_time - start_time
    
    # 性能要求: 1000次参数计算在5秒内完成
    assert execution_time < 5.0
    print(f"参数计算性能: {len(test_cases)}次计算用时{execution_time:.2f}秒")
```

### 4.3 兼容性测试用例

**测试用例**: test_os_compatibility
```python
def test_os_compatibility():
    """测试操作系统兼容性"""
    # 测试在不同操作系统上的基本功能
    app = Application()
    
    # 验证系统初始化
    try:
        app.initialize()
        assert app.is_initialized()
    except Exception as e:
        pytest.fail(f"系统初始化失败: {e}")
    
    # 验证基本功能
    try:
        qr_code = "PO12345@TEST-MODEL@100"
        model_info = app.model_recognizer.recognize_model(qr_code)
        assert model_info.model == "TEST-MODEL"
    except Exception as e:
        pytest.fail(f"型号识别失败: {e}")
```

**测试用例**: test_nc_protocol_compatibility
```python
def test_nc_protocol_compatibility():
    """测试NC协议兼容性"""
    protocols = ['rexroth', 'brother', 'fanuc']
    
    for protocol in protocols:
        try:
            nc_protocol = ProtocolFactory.create_protocol(protocol)
            test_parameters = {'#500': '10', '#501': '20'}
            
            # 测试消息生成
            message = nc_protocol.generate_message(test_parameters)
            assert message is not None
            assert isinstance(message, str)
            
        except Exception as e:
            pytest.fail(f"协议{protocol}测试失败: {e}")
```

## 5. 验收测试用例

### 5.1 用户功能验收测试

**测试用例**: test_user_workflow_acceptance
```python
def test_user_workflow_acceptance():
    """测试用户工作流程验收"""
    # 模拟用户完整工作流程
    app = Application()
    app.initialize()
    
    # 1. 扫描QR码
    qr_code = "PO12345@C-CCC10-20A-P5-30@100"
    app.scan_qr_code(qr_code)
    
    # 2. 验证型号显示
    assert app.get_displayed_model() == "C-CCC10-20A-P5-30"
    assert app.get_displayed_po() == "PO12345"
    assert app.get_displayed_quantity() == "100"
    
    # 3. 验证程序显示
    programs = app.get_available_programs()
    assert len(programs) >= 1
    
    # 4. 选择程序并验证参数计算
    app.select_program(programs[0])
    parameters = app.get_calculated_parameters()
    assert len(parameters) > 0
    
    # 5. 验证参数显示
    for macro, value in parameters.items():
        displayed_value = app.get_parameter_display(macro)
        assert displayed_value == str(value)
    
    # 6. 验证发送功能
    send_result = app.send_parameters()
    assert send_result in [True, False]  # 发送可能成功或失败(测试环境)
```

### 5.2 性能验收测试

**测试用例**: test_performance_acceptance
```python
def test_performance_acceptance():
    """测试性能验收标准"""
    # 型号识别性能验收
    recognizer = ModelRecognizer()
    start_time = time.time()
    
    for i in range(100):
        qr_code = f"PO{i}@MODEL-{i}@100"
        recognizer.recognize_model(qr_code)
    
    recognition_time = time.time() - start_time
    assert recognition_time < 2.0  # 100次识别在2秒内
    
    # 参数计算性能验收
    engine = CalculationEngine()
    start_time = time.time()
    
    for i in range(100):
        program_no = (i % 3) + 1
        model_parts = [f"PART{i}", f"SIZE{i%10}"]
        engine.calculate(program_no, model_parts)
    
    calculation_time = time.time() - start_time
    assert calculation_time < 3.0  # 100次计算在3秒内
```

## 6. 测试数据管理

### 6.1 测试数据准备

#### 6.1.1 型号测试数据
```python
TEST_MODELS = [
    "PO12345@C-CCC10-20A-P5-30@100",
    "PO67890@AAA-15-25-35@200",
    "PO11111@BBB-20-30-40@50",
    "PO22222@C-CCC-10-20-30@150"
]
```

#### 6.1.2 参数测试数据
```python
TEST_PARAMETERS = {
    'program_1': {
        '#500': '10',
        '#501': 'size1', 
        '#502': 'define1-1'
    },
    'program_2': {
        '#500': '20',
        '#501': 'size2',
        '#502': 'define2-1'
    }
}
```

### 6.2 测试环境配置

#### 6.2.1 测试配置文件
```python
TEST_CONFIG = {
    'QRmode': '1',
    'QRspltStr': '@',
    'MODELplc': '2',
    'POplc': '1',
    'QTYplc': '3',
    'BarCodeHeaderStrNum': '11'
}
```

#### 6.2.2 模拟NC设备
```python
class MockNCDevice:
    """模拟NC设备用于测试"""
    
    def __init__(self):
        self.received_messages = []
    
    def send_message(self, message):
        self.received_messages.append(message)
        return True
    
    def get_received_messages(self):
        return self.received_messages
```

## 7. 测试执行和报告

### 7.1 测试执行流程

#### 7.1.1 自动化测试执行
```bash
# 运行所有测试
pytest tests/ -v

# 运行特定模块测试
pytest tests/unit/test_model_recognizer.py -v

# 生成测试覆盖率报告
pytest tests/ --cov=src --cov-report=html

# 运行性能测试
pytest tests/performance/ -v
```

#### 7.1.2 测试结果分析
- **通过率**: 目标95%以上
- **覆盖率**: 目标80%以上
- **性能指标**: 满足性能要求
- **缺陷统计**: 跟踪和修复缺陷

### 7.2 测试报告模板

#### 7.2.1 测试执行报告
```
测试执行报告
============

测试周期: 2025-10-24
测试环境: Windows 11, Python 3.9

测试结果统计:
- 总测试用例: 150
- 通过: 145 (96.7%)
- 失败: 5 (3.3%)
- 跳过: 0 (0%)

代码覆盖率:
- 语句覆盖率: 85%
- 分支覆盖率: 78%
- 函数覆盖率: 92%

性能测试结果:
- 型号识别: 3000次/8.5秒 ✓
- 参数计算: 1000次/4.2秒 ✓
- 内存使用: 稳定在150MB ✓

关键问题:
1. 型号识别在特定格式下失败
2. NC通信超时处理需要优化
```

---

**文档版本**: v1.0  
**最后更新**: 2025年10月24日  
**测试负责人**: DNC测试团队
