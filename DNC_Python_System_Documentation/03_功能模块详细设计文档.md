# DNC功能模块详细设计文档

## 1. 控件系统详细设计

### 1.1 8种核心控件类型实现

#### 1.1.1 Load控件 (makeCntrlLoad)
```python
class LoadControl:
    def __init__(self, data_source: str, field_mapping: Dict):
        self.data_source = data_source
        self.field_mapping = field_mapping
        self.data_table = None
    
    def load_data(self) -> pd.DataFrame:
        """从CSV文件加载数据"""
        try:
            self.data_table = pd.read_csv(self.data_source, encoding='utf-8')
            return self.data_table
        except Exception as e:
            logger.error(f"加载数据失败: {e}")
            return None
    
    def validate_data(self) -> bool:
        """验证数据完整性"""
        required_fields = ['NO', 'TYPE', 'DRAWING']
        return all(field in self.data_table.columns for field in required_fields)
```

#### 1.1.2 Input控件 (makeCntrlInput)
```python
class InputControl:
    def __init__(self, control_id: str, data_type: str, validation_rules: Dict):
        self.control_id = control_id
        self.data_type = data_type
        self.validation_rules = validation_rules
        self.value = None
    
    def handle_text_change(self, new_value: str):
        """处理文本变更事件"""
        if self.validate_input(new_value):
            self.value = self.convert_value(new_value)
            self.trigger_calculation()
    
    def validate_input(self, value: str) -> bool:
        """验证输入值"""
        if self.data_type == 'numeric':
            return self._validate_numeric(value)
        elif self.data_type == 'string':
            return self._validate_string(value)
        return False
```

#### 1.1.3 基础控件创建方法Python实现

**文本框创建 (makeTextBox)**
```python
def create_text_box(name: str, location: Tuple[int, int], size: Tuple[int, int], 
                   text_change_handler: Callable) -> QLineEdit:
    """创建文本框控件"""
    text_box = QLineEdit()
    text_box.setObjectName(name)
    text_box.setGeometry(location[0], location[1], size[0], size[1])
    text_box.textChanged.connect(text_change_handler)
    return text_box
```

**标签创建 (makeLabel)**
```python
def create_label(name: str, text: str, location: Tuple[int, int], 
                size: Tuple[int, int]) -> QLabel:
    """创建标签控件"""
    label = QLabel(text)
    label.setObjectName(name)
    label.setGeometry(location[0], location[1], size[0], size[1])
    return label
```

#### 1.1.4 动态控件管理技术细节

**控件生命周期管理**
```python
class ControlManager:
    def __init__(self):
        self.controls = {}
        self.control_groups = {}
    
    def add_control(self, control_id: str, control: QWidget):
        """添加控件到管理器"""
        self.controls[control_id] = control
    
    def remove_control(self, control_id: str):
        """移除控件"""
        if control_id in self.controls:
            self.controls[control_id].deleteLater()
            del self.controls[control_id]
    
    def enable_controls(self, control_ids: List[str], enabled: bool):
        """批量启用/禁用控件"""
        for control_id in control_ids:
            if control_id in self.controls:
                self.controls[control_id].setEnabled(enabled)
```

## 2. 计算引擎详细设计

### 2.1 表达式计算具体算法

**表达式解析器 (getCalcResult)**
```python
class ExpressionCalculator:
    def __init__(self):
        self.variables = {}
        self.functions = {
            'MAX': max,
            'MIN': min,
            'ROUND': round,
            'ABS': abs
        }
    
    def calculate(self, expression: str, variables: Dict) -> float:
        """计算表达式值"""
        try:
            # 变量替换
            expr = self._replace_variables(expression, variables)
            # 表达式求值
            result = eval(expr, {"__builtins__": None}, self.functions)
            return float(result)
        except Exception as e:
            logger.error(f"表达式计算错误: {expression}, 错误: {e}")
            return 0.0
    
    def _replace_variables(self, expression: str, variables: Dict) -> str:
        """替换表达式中的变量"""
        for var_name, var_value in variables.items():
            expression = expression.replace(f"@{var_name}", str(var_value))
        return expression
```

### 2.2 条件判断系统实现逻辑

**关系判断引擎 (judgeRelation)**
```python
class RelationJudge:
    def judge(self, condition: str, left_value: Any, right_value: Any) -> bool:
        """判断关系条件"""
        operators = {
            '=': lambda x, y: x == y,
            '<>': lambda x, y: x != y,
            '>': lambda x, y: x > y,
            '<': lambda x, y: x < y,
            '>=': lambda x, y: x >= y,
            '<=': lambda x, y: x <= y
        }
        
        for op, func in operators.items():
            if op in condition:
                return func(left_value, right_value)
        
        return False
```

### 2.3 精度控制技术方案

**数值精度管理**
```python
class PrecisionController:
    def __init__(self, decimal_places: int = 4):
        self.decimal_places = decimal_places
    
    def round_value(self, value: float) -> float:
        """四舍五入处理"""
        return round(value, self.decimal_places)
    
    def format_display(self, value: float) -> str:
        """格式化显示值"""
        return f"{value:.{self.decimal_places}f}".rstrip('0').rstrip('.')
```

## 3. 数据处理模块详细设计

### 3.1 文件加载系统实现细节

**CSV文件加载器 (LoadFileToTBL)**
```python
class CSVLoader:
    def __init__(self, encoding_detector: EncodingDetector):
        self.encoding_detector = encoding_detector
    
    def load_file(self, file_path: str) -> pd.DataFrame:
        """加载CSV文件"""
        encoding = self.encoding_detector.detect_encoding(file_path)
        
        try:
            df = pd.read_csv(file_path, encoding=encoding)
            return self._clean_data(df)
        except Exception as e:
            logger.error(f"文件加载失败: {file_path}, 错误: {e}")
            return pd.DataFrame()
    
    def _clean_data(self, df: pd.DataFrame) -> pd.DataFrame:
        """数据清理"""
        # 移除空行
        df = df.dropna(how='all')
        # 处理NaN值
        df = df.fillna('')
        return df
```

### 3.2 数据搜索功能算法设计

**表搜索引擎 (searchT_relation)**
```python
class TableSearcher:
    def __init__(self, data_tables: Dict[str, pd.DataFrame]):
        self.data_tables = data_tables
        self.search_cache = {}
    
    def search_table(self, table_name: str, search_criteria: Dict) -> pd.DataFrame:
        """搜索数据表"""
        cache_key = f"{table_name}_{str(search_criteria)}"
        if cache_key in self.search_cache:
            return self.search_cache[cache_key]
        
        if table_name not in self.data_tables:
            return pd.DataFrame()
        
        table = self.data_tables[table_name]
        result = table.copy()
        
        for column, value in search_criteria.items():
            if column in table.columns:
                result = result[result[column] == value]
        
        self.search_cache[cache_key] = result
        return result
```

### 3.3 数据操作技术实现

**数据转换器 (searchT_ChngValue)**
```python
class DataConverter:
    def __init__(self, conversion_rules: Dict):
        self.conversion_rules = conversion_rules
    
    def convert_value(self, value: Any, conversion_type: str) -> Any:
        """转换数据值"""
        if conversion_type in self.conversion_rules:
            rule = self.conversion_rules[conversion_type]
            return rule(value)
        return value
    
    def add_conversion_rule(self, conversion_type: str, rule: Callable):
        """添加转换规则"""
        self.conversion_rules[conversion_type] = rule
```

## 4. 通信模块详细设计

### 4.1 通信协议支持技术实现

**NC通信协议处理器 (makeSendTxt)**
```python
class NCProtocolHandler:
    def __init__(self, protocol_type: str):
        self.protocol_type = protocol_type
        self.message_formatters = {
            'rexroth': self._format_rexroth_message,
            'brother': self._format_brother_message
        }
    
    def format_message(self, command: str, parameters: Dict) -> str:
        """格式化NC命令消息"""
        if self.protocol_type in self.message_formatters:
            return self.message_formatters[self.protocol_type](command, parameters)
        return command
    
    def _format_rexroth_message(self, command: str, parameters: Dict) -> str:
        """格式化Rexroth协议消息"""
        # Rexroth协议特定格式化逻辑
        return f"{command} {self._format_parameters(parameters)}"
    
    def _format_brother_message(self, command: str, parameters: Dict) -> str:
        """格式化Brother协议消息"""
        # Brother协议特定格式化逻辑
        return f"{command};{self._format_parameters(parameters)}"
```

### 4.2 进程间通信机制设计

**连接状态管理器 (ConnectionChange)**
```python
class ConnectionManager:
    def __init__(self):
        self.connections = {}
        self.connection_callbacks = []
    
    def add_connection(self, connection_id: str, connection: object):
        """添加连接"""
        self.connections[connection_id] = connection
        self._notify_connection_change(connection_id, 'connected')
    
    def remove_connection(self, connection_id: str):
        """移除连接"""
        if connection_id in self.connections:
            del self.connections[connection_id]
            self._notify_connection_change(connection_id, 'disconnected')
    
    def _notify_connection_change(self, connection_id: str, status: str):
        """通知连接状态变更"""
        for callback in self.connection_callbacks:
            callback(connection_id, status)
```

### 4.3 命名管道通信具体实现

**异步命名管道客户端 (NamedPipeAsyncClient)**
```python
class NamedPipeClient:
    def __init__(self, pipe_name: str):
        self.pipe_name = pipe_name
        self.connected = False
        self.data_received_callbacks = []
    
    async def connect(self):
        """异步连接命名管道"""
        try:
            # Windows命名管道连接实现
            self.connected = True
            await self._start_listening()
        except Exception as e:
            logger.error(f"命名管道连接失败: {e}")
            self.connected = False
    
    async def send_data(self, data: str):
        """异步发送数据"""
        if self.connected:
            # 实现数据发送逻辑
            pass
    
    def add_data_received_callback(self, callback: Callable):
        """添加数据接收回调"""
        self.data_received_callbacks.append(callback)
```

## 5. 用户界面交互详细设计

### 5.1 事件处理系统架构设计

**事件分发器**
```python
class EventDispatcher:
    def __init__(self):
        self.event_handlers = {}
    
    def register_handler(self, event_type: str, handler: Callable):
        """注册事件处理器"""
        if event_type not in self.event_handlers:
            self.event_handlers[event_type] = []
        self.event_handlers[event_type].append(handler)
    
    def dispatch_event(self, event_type: str, event_data: Dict):
        """分发事件"""
        if event_type in self.event_handlers:
            for handler in self.event_handlers[event_type]:
                try:
                    handler(event_data)
                except Exception as e:
                    logger.error(f"事件处理错误: {e}")
```

### 5.2 输入处理技术实现

**文本变更处理器 (txt_change)**
```python
class TextChangeHandler:
    def __init__(self, validation_rules: Dict, calculation_trigger: Callable):
        self.validation_rules = validation_rules
        self.calculation_trigger = calculation_trigger
        self.change_event_flag = False
    
    def handle_text_change(self, control_id: str, new_text: str):
        """处理文本变更"""
        if self.change_event_flag:
            return
        
        self.change_event_flag = True
        
        try:
            # 数据验证
            if self._validate_text(control_id, new_text):
                # 触发计算
                self.calculation_trigger(control_id, new_text)
        finally:
            self.change_event_flag = False
    
    def _validate_text(self, control_id: str, text: str) -> bool:
        """验证文本内容"""
        if control_id in self.validation_rules:
            rule = self.validation_rules[control_id]
            return rule(text)
        return True
```

### 5.3 操作员管理功能设计

**操作员管理器 (TB_OpeID_TextChanged)**
```python
class OperatorManager:
    def __init__(self):
        self.current_operator = None
        self.operator_database = {}
    
    def set_operator(self, operator_id: str):
        """设置当前操作员"""
        if operator_id in self.operator_database:
            self.current_operator = self.operator_database[operator_id]
            logger.info(f"操作员已切换: {self.current_operator.name}")
        else:
            logger.warning(f"未知操作员ID: {operator_id}")
    
    def get_operator_name(self, operator_id: str) -> str:
        """获取操作员名称"""
        if operator_id in self.operator_database:
            return self.operator_database[operator_id].name
        return "未知操作员"
```

## 6. 数据验证模块详细设计

### 6.1 验证方法具体实现

**数值验证器 (chkTxtIsNumeric)**
```python
class NumericValidator:
    def validate(self, text: str, min_value: float = None, 
                max_value: float = None, decimal_places: int = None) -> bool:
        """验证数值文本"""
        try:
            value = float(text)
            
            if min_value is not None and value < min_value:
                return False
            
            if max_value is not None and value > max_value:
                return False
            
            if decimal_places is not None:
                # 检查小数位数
                decimal_part = str(value).split('.')
                if len(decimal_part) > 1 and len(decimal_part[1]) > decimal_places:
                    return False
            
            return True
        except ValueError:
            return False
```

### 6.2 验证规则技术设计

**业务规则验证器 (chkAddControls)**
```python
class BusinessRuleValidator:
    def __init__(self, validation_rules: Dict):
        self.validation_rules = validation_rules
    
    def validate_controls(self, control_values: Dict) -> Dict[str, str]:
        """验证控件组业务规则"""
        errors = {}
        
        for rule_name, rule in self.validation_rules.items():
            if not rule(control_values):
                errors[rule_name] = f"业务规则验证失败: {rule_name}"
        
        return errors
    
    def add_validation_rule(self, rule_name: str, rule: Callable):
        """添加验证规则"""
        self.validation_rules[rule_name] = rule
```

### 6.3 错误处理机制

**验证错误处理器**
```python
class ValidationErrorHandler:
    def __init__(self):
        self.error_messages = {}
    
    def add_error(self, control_id: str, message: str):
        """添加错误信息"""
        if control_id not in self.error_messages:
            self.error_messages[control_id] = []
        self.error_messages[control_id].append(message)
    
    def clear_errors(self, control_id: str = None):
        """清除错误信息"""
        if control_id:
            if control_id in self.error_messages:
                del self.error_messages[control_id]
        else:
            self.error_messages.clear()
    
    def has_errors(self) -> bool:
        """检查是否有错误"""
        return len(self.error_messages) > 0
```

---

**文档版本**: 1.0  
**最后更新**: 2025/10/23  
**维护者**: DNC开发团队
