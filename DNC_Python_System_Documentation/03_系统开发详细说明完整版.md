1. 项目概述
1.1 系统简介
DNC（Direct Numerical Control）系统是一个数控设备参数管理软件，用于从电脑直接传送参数到NC机的宏变量系统。该系统解决了传统NC机手动输入参数的时间和错误问题。

1.2 系统架构 - 基于VB.NET源码分析
原系统: VB.NET DNC2.05 (基于Frm_main.vb主窗体)

新系统: Python重写版本 (基于VB.NET源码完整重构)

系统构成: PC + NC机 + LAN线 + DNC软件 + 命名管道通信

数据格式: CSV文件存储Master数据 + 动态控件系统

核心架构: 8种控件系统 + 计算引擎 + 通信模块 + 数据处理

2. 系统功能模块
2.1 核心功能模块
2.1.1 产品型号管理
产品类型定义 (type_define.csv)

程序类型映射 (type_prg.csv)

产品参数配置 (load.csv)

2.1.2 参数计算引擎
几何参数计算 (calc.csv)

关系验证逻辑 (relation.csv)

变量定义管理 (define.csv)

2.1.3 程序生成器
程序定义 (prg.csv)

控制参数 (cntrl_rex.csv)

选择逻辑 (select.csv)

2.2 数据流处理
2.2.1 输入处理
text
输入 → 参数验证 → 计算引擎 → 程序生成 → 输出
2.2.2 宏变量映射
#500-#600: 系统参数

#1-#100: 用户参数

特殊变量: 计算中间值

3. 数据结构详细说明
3.1 核心数据文件
3.1.1 type_define.csv (产品类型定义)
文件大小: 988.60 KB

数据结构:

NO: 序号

TYPE: 产品型号 (如: GPA18GT15040-A)

DEFINE1: 定义1

DEFINE2: 定义2

3.1.2 type_prg.csv (程序类型映射)
文件大小: 480.92 KB

数据结构:

NO: 序号

prg1: 程序1编号

prg2: 程序2编号

3.1.3 load.csv (主数据文件)
文件大小: 8.5 MB

数据结构:

NO: 序号

TYPE: 产品型号

DRAWING: 图纸文件

DISPFLG: 显示标志

#1-#12: 定义变量

#500-#550: 系统参数

#602-#603: 开关控制

3.1.4 cntrl_rex.csv (参数控制)
文件大小: 1.10 KB

数据结构:

PARAMETER: 参数名称 (如: Work_plan, Teeth_num)

DATATYPE: 数据类型 (int, real, boolean)

MACRO: 宏变量映射 (如: #510, #511)

3.2 计算逻辑文件
3.2.1 calc.csv (计算定义)
csv
DEFINE,1,2,3,4,5,6,7,8,9,10,11,12,13
calcABC,=,#528,-,#510,*,2,NaN,NaN,NaN,NaN,NaN,NaN,NaN
calcABCD,=,(,#528,-,#513,),/,2.0,NaN,NaN,NaN,NaN,NaN
3.2.2 relation.csv (关系验证)
csv
DEFINE,VALUE,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28
relationHPN,#1,and,#1,>,0.0,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN
3.2.3 define.csv (变量定义)
csv
DEFINE,STR,BEFORE,AFTER,CHNGVL,CALC
defineP,P,P0,0,NaN,NaN
defineH,H,H0,0,NaN,NaN
4. 技术架构设计
4.1 系统架构图
text
┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐
│ 用户界面层     │ │ 业务逻辑层     │ │ 数据访问层     │
│               │ │               │ │               │
│ - 主窗口      │◄──►│ - 参数计算    │◄──►│ - CSV处理器   │
│ - 输入表单    │ │ - 程序生成     │ │ - 数据验证     │
│ - 结果显示    │ │ - 关系验证     │ │ - 编码处理     │
└─────────────────┘ └─────────────────┘ └─────────────────┘
│
▼
┌─────────────────────────────────────────────────────────────────┐
│ 数据存储层                                                       │
│                                                                 │
│ - Master数据文件 (CSV格式)                                       │
│ - 配置文件 (INI格式)                                              │
│ - 日志文件                                                       │
└─────────────────────────────────────────────────────────────────┘
4.2 系统架构图 - 基于8种控件系统
text
┌─────────────────────────────────────────────────────────────────┐
│ DNC系统架构图                                                  │
├─────────────────┬─────────────────┬─────────────────┬───────────┤
│ 用户界面层     │ 业务逻辑层     │ 数据处理层     │ 通信层    │
│               │               │               │           │
│ - 主窗口      │ - 计算引擎     │ - CSV加载器    │ - 命名管道│
│ - 8种控件系统 │ - 关系验证     │ - 数据验证     │ - NC协议  │
│ - 事件处理    │ - 程序生成     │ - 编码处理     │ - 连接管理│
│               │ - 精度控制     │ - 缓存管理     │           │
└─────────────────┴─────────────────┴─────────────────┴───────────┘
│
▼
┌─────────────────────────────────────────────────────────────────┐
│ 数据存储层                                                     │
│                                                               │
│ - Master数据文件 (CSV格式)                                    │
│ - 配置文件 (INI格式)                                          │
│ - 日志文件                                                    │
└─────────────────────────────────────────────────────────────────┘
4.3 核心类设计
4.3.1 DataManager (数据管理器)
python
class DataManager:
    def load_master_data(self) -> Dict[str, pd.DataFrame]
    def batch_read_large_csv(self, file_path: str, batch_size: int = 1000)
    def validate_data_integrity(self) -> bool
    def fix_encoding_issues(self, file_path: str) -> pd.DataFrame
4.3.2 CalculationEngine (计算引擎)
python
class CalculationEngine:
    def calculate_parameters(self, input_data: Dict) -> Dict
    def validate_relations(self, calculated_data: Dict) -> bool
    def generate_macro_variables(self, params: Dict) -> List[str]
4.3.3 ProgramGenerator (程序生成器)
python
class ProgramGenerator:
    def generate_nc_program(self, product_type: str, params: Dict) -> str
    def apply_program_template(self, template: str, variables: Dict) -> str
    def validate_program_syntax(self, program: str) -> bool
5. 数据处理流程
5.1 数据加载流程
扫描目录: 递归扫描master目录下的所有CSV文件

分类处理: 根据文件大小分类为小文件和大文件

编码检测: 自动检测文件编码 (UTF-8, Shift-JIS, CP932)

分批读取: 大文件使用分批读取机制

数据验证: 检查数据完整性和一致性

5.2 参数计算流程
输入验证: 验证用户输入参数的有效性

变量替换: 根据define.csv进行变量替换

计算执行: 执行calc.csv中定义的计算逻辑

关系验证: 验证relation.csv中定义的关系条件

结果生成: 生成最终的宏变量值

5.3 基于VB.NET业务流程的完整处理流程
5.3.1 Master数据加载流程
python
class MasterDataLoader:
    def __init__(self):
        self.csv_loader = CSVLoader()
        self.encoding_detector = EncodingDetector()
        self.data_validator = DataValidator()

    def load_master_data(self) -> Dict[str, pd.DataFrame]:
        """加载Master数据 - 基于VB.NET数据加载流程"""
        master_data = {}
        # 1. 扫描master目录
        master_files = self._scan_master_directory()
        # 2. 分类处理文件
        for file_path in master_files:
            file_name = os.path.basename(file_path)
            # 3. 检测编码
            encoding = self.encoding_detector.detect_encoding(file_path)
            # 4. 分批读取大文件
            if self._is_large_file(file_path):
                data = self._batch_read_large_csv(file_path, encoding)
            else:
                data = pd.read_csv(file_path, encoding=encoding)
            # 5. 数据验证
            if self.data_validator.validate_data(data, file_name):
                master_data[file_name] = data
        return master_data
5.3.2 实时计算流程
python
class RealTimeCalculationFlow:
    def __init__(self):
        self.calculation_engine = CalculationEngine()
        self.variable_manager = VariableManager()
        self.relation_validator = RelationValidator()

    def process_input_change(self, control_id: str, new_value: str):
        """处理输入变更 - 基于实时计算流程"""
        # 1. 输入验证
        if not self._validate_input(control_id, new_value):
            return
        # 2. 变量替换
        processed_value = self._apply_variable_substitution(control_id, new_value)
        # 3. 更新变量管理器
        self.variable_manager.update_variable(control_id, processed_value)
        # 4. 执行计算
        calculation_results = self.calculation_engine.calculate_all(
            self.variable_manager.get_all_variables()
        )
        # 5. 关系验证
        validation_passed = self.relation_validator.validate_all_relations(
            calculation_results
        )
        # 6. 更新显示
        if validation_passed:
            self._update_display(calculation_results)
        else:
            self._show_validation_errors()
5.4 数据流详细说明
5.4.1 输入到输出完整数据流
text
用户输入
↓
输入验证 (chkTxtIsNumeric, chkAddControls)
↓
变量替换 (define.csv逻辑)
↓
计算执行 (calc.csv表达式计算)
↓
关系验证 (relation.csv条件判断)
↓
精度控制 (四舍五入处理)
↓
程序生成 (prg.csv模板应用)
↓
NC协议格式化 (makeSendTxt)
↓
命名管道传输
↓
NC机接收执行
6. 文件编码处理
6.1 编码问题文件列表
ini.csv: 958字节，编码问题

math.csv: 1.08KB，编码问题

cntrl.csv: 1.38KB，编码问题

switch.csv: 106字节，编码问题

6.2 编码处理策略
python
def detect_encoding(file_path: str) -> str:
    encodings = ['utf-8', 'shift_jis', 'cp932', 'latin1']
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as f:
                f.read()
            return encoding
        except UnicodeDecodeError:
            continue
    return 'unknown'
7. 性能优化策略
7.1 大文件处理优化
分批读取: 使用pandas的chunksize参数

内存管理: 及时释放不需要的数据

缓存机制: 缓存频繁访问的数据

7.2 计算优化
预编译: 预编译计算表达式

并行处理: 使用多线程处理独立计算

结果缓存: 缓存重复计算结果

7.3 性能优化数据处理
7.3.1 缓存机制
python
class DataCache:
    def __init__(self, max_size: int = 1000):
        self.cache = {}
        self.max_size = max_size
        self.access_count = {}

    def get(self, key: str) -> Optional[Any]:
        """获取缓存数据"""
        if key in self.cache:
            self.access_count[key] = self.access_count.get(key, 0) + 1
            return self.cache[key]
        return None

    def set(self, key: str, value: Any):
        """设置缓存数据"""
        if len(self.cache) >= self.max_size:
            self._evict_least_used()
        self.cache[key] = value
        self.access_count[key] = 1
7.3.2 预编译优化
python
class ExpressionPrecompiler:
    def __init__(self):
        self.compiled_expressions = {}

    def precompile_expression(self, expression: str) -> Callable:
        """预编译表达式"""
        if expression in self.compiled_expressions:
            return self.compiled_expressions[expression]
        try:
            # 安全编译表达式
            compiled = compile(expression, '<string>', 'eval')
            self.compiled_expressions[expression] = compiled
            return compiled
        except Exception as e:
            logger.warning(f"表达式预编译失败: {expression}, 错误: {e}")
            return None
8. 错误处理机制
8.1 数据验证错误
文件不存在错误

编码错误处理

数据格式错误

完整性检查失败

8.2 计算错误
除零错误处理

变量未定义错误

关系验证失败

程序生成错误

8.3 错误处理流程
python
class ErrorHandlingFlow:
    def __init__(self):
        self.error_handler = ValidationErrorHandler()
        self.logger = logging.getLogger(__name__)

    def handle_data_loading_error(self, file_path: str, error: Exception):
        """处理数据加载错误"""
        self.logger.error(f"数据加载失败: {file_path}, 错误: {error}")
        # 尝试修复编码问题
        if isinstance(error, UnicodeDecodeError):
            fixed_data = self._fix_encoding_issue(file_path)
            if fixed_data is not None:
                return fixed_data
        # 记录错误并返回空数据
        self.error_handler.add_error("data_loading", f"文件加载失败: {file_path}")
        return pd.DataFrame()
9. 部署和配置
9.1 环境要求
Python 3.8+

pandas >= 1.3.0

PyQt5/PySide6

操作系统: Windows 10/11

9.2 系统配置管理
9.2.1 配置文件结构
ini
[system]
data_directory = ./data/master
log_level = INFO
batch_size = 1000
max_cache_size = 1000
default_encoding = utf-8

[communication]
pipe_name = DNC_Pipe
protocol_type = rexroth
timeout_seconds = 30

[calculation]
decimal_places = 4
enable_precompilation = true
enable_caching = true

[ui]
window_width = 1024
window_height = 768
theme = default

[encoding]
default_encoding = utf-8
fallback_encodings = shift_jis,cp932,latin1
9.2.2 环境配置检查
python
class EnvironmentChecker:
    def check_system_requirements(self) -> Dict[str, bool]:
        """检查系统要求"""
        requirements = {
            'python_version': self._check_python_version(),
            'pandas_installed': self._check_pandas(),
            'pyqt_installed': self._check_pyqt(),
            'data_directory_exists': self._check_data_directory(),
            'master_files_exist': self._check_master_files()
        }
        return requirements
10. 测试策略
10.1 单元测试
数据加载测试

计算逻辑测试

程序生成测试

错误处理测试

10.2 集成测试
端到端流程测试

性能测试

兼容性测试

10.3 基于VB.NET功能的测试用例
10.3.1 控件系统测试
python
class ControlSystemTests:
    def test_load_control_creation(self):
        """测试Load控件创建"""
        control_manager = ControlManager()
        load_control = control_manager.create_control("Load", "test_load", {})
        assert isinstance(load_control, LoadControl)

    def test_input_control_validation(self):
        """测试Input控件验证"""
        input_control = InputControl("test_input", "numeric", {})
        assert input_control.validate_input("123.45") == True
        assert input_control.validate_input("abc") == False
11. 功能模块详细设计
11.1 控件系统详细设计
11.1.1 8种核心控件类型实现
Load控件 (makeCntrlLoad)

python
class LoadControl:
    def __init__(self, data_source: str, field_mapping: Dict):
        self.data_source = data_source
        self.field_mapping = field_mapping
        self.data_table = None

    def load_data(self) -> pd.DataFrame:
        """从CSV文件加载数据"""
        try:
            self.data_table = pd.read_csv(self.data_source, encoding='utf-8')
            return self.data_table
        except Exception as e:
            logger.error(f"加载数据失败: {e}")
            return None

    def validate_data(self) -> bool:
        """验证数据完整性"""
        required_fields = ['NO', 'TYPE', 'DRAWING']
        return all(field in self.data_table.columns for field in required_fields)
Input控件 (makeCntrlInput)

python
class InputControl:
    def __init__(self, control_id: str, data_type: str, validation_rules: Dict):
        self.control_id = control_id
        self.data_type = data_type
        self.validation_rules = validation_rules
        self.value = None

    def handle_text_change(self, new_value: str):
        """处理文本变更事件"""
        if self.validate_input(new_value):
            self.value = self.convert_value(new_value)
            self.trigger_calculation()

    def validate_input(self, value: str) -> bool:
        """验证输入值"""
        if self.data_type == 'numeric':
            return self._validate_numeric(value)
        elif self.data_type == 'string':
            return self._validate_string(value)
        return False
11.1.2 基础控件创建方法Python实现
文本框创建 (makeTextBox)

python
def create_text_box(name: str, location: Tuple[int, int], size: Tuple[int, int],
                   text_change_handler: Callable) -> QLineEdit:
    """创建文本框控件"""
    text_box = QLineEdit()
    text_box.setObjectName(name)
    text_box.setGeometry(location[0], location[1], size[0], size[1])
    text_box.textChanged.connect(text_change_handler)
    return text_box
标签创建 (makeLabel)

python
def create_label(name: str, text: str, location: Tuple[int, int],
                size: Tuple[int, int]) -> QLabel:
    """创建标签控件"""
    label = QLabel(text)
    label.setObjectName(name)
    label.setGeometry(location[0], location[1], size[0], size[1])
    return label
11.1.3 动态控件管理技术细节
控件生命周期管理

python
class DynamicControlManager:
    def __init__(self):
        self.controls = {}
        self.control_templates = {}
        self.control_groups = {}

    def create_control(self, control_type: str, control_id: str,
                      properties: Dict) -> QWidget:
        """动态创建控件 - 基于VB.NET控件创建方法"""
        if control_type == "TextBox":
            return self._create_text_box(control_id, properties)
        elif control_type == "Label":
            return self._create_label(control_id, properties)
        elif control_type == "Button":
            return self._create_button(control_id, properties)
        # 其他控件类型...
11.2 计算引擎详细设计
11.2.1 表达式计算具体算法
表达式解析器 (getCalcResult)

python
class ExpressionCalculator:
    def __init__(self):
        self.variables = {}
        self.functions = {
            'MAX': max,
            'MIN': min,
            'ROUND': round,
            'ABS': abs
        }

    def calculate(self, expression: str, variables: Dict) -> float:
        """计算表达式值"""
        try:
            # 变量替换
            expr = self._replace_variables(expression, variables)
            # 表达式求值
            result = eval(expr, {"__builtins__": None}, self.functions)
            return float(result)
        except Exception as e:
            logger.error(f"表达式计算错误: {expression}, 错误: {e}")
            return 0.0
11.2.2 条件判断系统实现逻辑
关系判断引擎 (judgeRelation)

python
class RelationJudge:
    def judge(self, condition: str, left_value: Any, right_value: Any) -> bool:
        """判断关系条件"""
        operators = {
            '=': lambda x, y: x == y,
            '<>': lambda x, y: x != y,
            '>': lambda x, y: x > y,
            '<': lambda x, y: x < y,
            '>=': lambda x, y: x >= y,
            '<=': lambda x, y: x <= y
        }
        for op, func in operators.items():
            if op in condition:
                return func(left_value, right_value)
        return False
11.3 数据处理模块详细设计
11.3.1 文件加载系统实现细节
CSV文件加载器 (LoadFileToTBL)

python
class CSVLoader:
    def __init__(self, encoding_detector: EncodingDetector):
        self.encoding_detector = encoding_detector

    def load_file(self, file_path: str) -> pd.DataFrame:
        """加载CSV文件"""
        encoding = self.encoding_detector.detect_encoding(file_path)
        try:
            df = pd.read_csv(file_path, encoding=encoding)
            return self._clean_data(df)
        except Exception as e:
            logger.error(f"文件加载失败: {file_path}, 错误: {e}")
            return pd.DataFrame()
11.3.2 数据搜索功能算法设计
表搜索引擎 (searchT_relation)

python
class TableSearcher:
    def __init__(self, data_tables: Dict[str, pd.DataFrame]):
        self.data_tables = data_tables
        self.search_cache = {}

    def search_table(self, table_name: str, search_criteria: Dict) -> pd.DataFrame:
        """搜索数据表"""
        cache_key = f"{table_name}_{str(search_criteria)}"
        if cache_key in self.search_cache:
            return self.search_cache[cache_key]
        if table_name not in self.data_tables:
            return pd.DataFrame()
        table = self.data_tables[table_name]
        result = table.copy()
        for column, value in search_criteria.items():
            if column in table.columns:
                result = result[result[column] == value]
        self.search_cache[cache_key] = result
        return result
11.4 通信模块详细设计
11.4.1 通信协议支持技术实现
NC通信协议处理器 (makeSendTxt)

python
class NCProtocolHandler:
    def __init__(self, protocol_type: str):
        self.protocol_type = protocol_type
        self.message_formatters = {
            'rexroth': self._format_rexroth_message,
            'brother': self._format_brother_message
        }

    def format_message(self, command: str, parameters: Dict) -> str:
        """格式化NC命令消息"""
        if self.protocol_type in self.message_formatters:
            return self.message_formatters[self.protocol_type](command, parameters)
        return command
11.4.2 进程间通信机制设计
连接状态管理器 (ConnectionChange)

python
class ConnectionManager:
    def __init__(self):
        self.connections = {}
        self.connection_callbacks = []

    def add_connection(self, connection_id: str, connection: object):
        """添加连接"""
        self.connections[connection_id] = connection
        self._notify_connection_change(connection_id, 'connected')
11.5 用户界面交互详细设计
11.5.1 事件处理系统架构设计
事件分发器

python
class EventDispatcher:
    def __init__(self):
        self.event_handlers = {}

    def register_handler(self, event_type: str, handler: Callable):
        """注册事件处理器"""
        if event_type not in self.event_handlers:
            self.event_handlers[event_type] = []
        self.event_handlers[event_type].append(handler)
11.5.2 输入处理技术实现
文本变更处理器 (txt_change)

python
class TextChangeHandler:
    def __init__(self, validation_rules: Dict, calculation_trigger: Callable):
        self.validation_rules = validation_rules
        self.calculation_trigger = calculation_trigger
        self.change_event_flag = False

    def handle_text_change(self, control_id: str, new_text: str):
        """处理文本变更"""
        if self.change_event_flag:
            return
        self.change_event_flag = True
        try:
            # 数据验证
            if self._validate_text(control_id, new_text):
                # 触发计算
                self.calculation_trigger(control_id, new_text)
        finally:
            self.change_event_flag = False
11.6 数据验证模块详细设计
11.6.1 验证方法具体实现
数值验证器 (chkTxtIsNumeric)

python
class NumericValidator:
    def validate(self, text: str, min_value: float = None,
                max_value: float = None, decimal_places: int = None) -> bool:
        """验证数值文本"""
        try:
            value = float(text)
            if min_value is not None and value < min_value:
                return False
            if max_value is not None and value > max_value:
                return False
            if decimal_places is not None:
                # 检查小数位数
                decimal_part = str(value).split('.')
                if len(decimal_part) > 1 and len(decimal_part[1]) > decimal_places:
                    return False
            return True
        except ValueError:
            return False
11.6.2 验证规则技术设计
业务规则验证器 (chkAddControls)

python
class BusinessRuleValidator:
    def __init__(self, validation_rules: Dict):
        self.validation_rules = validation_rules

    def validate_controls(self, control_values: Dict) -> Dict[str, str]:
        """验证控件组业务规则"""
        errors = {}
        for rule_name, rule in self.validation_rules.items():
            if not rule(control_values):
                errors[rule_name] = f"业务规则验证失败: {rule_name}"
        return errors
11.7 系统管理模块详细设计
11.7.1 初始化系统技术实现
系统初始化器 (Frm_main_Load)

python
class SystemInitializer:
    def __init__(self, config_manager: ConfigManager, data_manager: DataManager):
        self.config_manager = config_manager
        self.data_manager = data_manager
        self.initialization_steps = [
            self._load_configuration,
            self._load_master_data,
            self._initialize_ui,
            self._setup_communication
        ]

    async def initialize_system(self):
        """异步初始化系统"""
        for step in self.initialization_steps:
            try:
                await step()
            except Exception as e:
                logger.error(f"初始化步骤失败: {e}")
                raise
11.7.2 配置管理技术方案
INI配置管理器 (IniConfigManager)

python
class IniConfigManager:
    def __init__(self, ini_file_path: str):
        self.ini_file_path = ini_file_path
        self.config = {}

    def load_config(self) -> Dict:
        """加载INI配置文件"""
        config = configparser.ConfigParser()
        config.read(self.ini_file_path, encoding='utf-8')
        for section in config.sections():
            self.config[section] = dict(config.items(section))
        return self.config
11.8 工具方法详细设计
11.8.1 字符串处理技术实现
字符串工具类 (StringUtils)

python
class StringUtils:
    @staticmethod
    def len_b(text: str) -> int:
        """计算字符串字节长度（兼容VB.NET的LenB函数）"""
        return len(text.encode('utf-8'))

    @staticmethod
    def to_half_adjust(value: float, decimal_places: int = 0) -> float:
        """四舍五入处理（兼容VB.NET的ToHalfAdjust）"""
        factor = 10 ** decimal_places
        return round(value * factor) / factor
12. 技术架构设计（基于VB.NET源码分析）
12.1 系统架构概述
基于VB.NET源码分析，DNC系统采用分层架构设计，主要分为以下层次：

表示层：用户界面和交互控制

业务逻辑层：计算引擎和数据处理

数据访问层：文件系统和数据库操作

通信层：NC机床和进程间通信

12.2 核心类设计
12.2.1 主窗体类 (Frm_main)
python
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.control_manager = ControlManager()
        self.data_manager = DataManager()
        self.calculation_engine = CalculationEngine()
        self.communication_manager = CommunicationManager()
        
        # 基于VB.NET Frm_main.vb的初始化逻辑
        self._initialize_ui()
        self._load_master_data()
        self._setup_communication()
12.2.2 DNCMainApplication（主应用类）
python
class DNCMainApplication:
    def __init__(self):
        self.config_manager = ConfigManager()
        self.data_manager = DataManager()
        self.ui_manager = UIManager()
        self.calculation_engine = CalculationEngine()
        self.communication_manager = CommunicationManager()
    
    def initialize_system(self):
        """系统初始化流程"""
        # 1. 加载配置文件
        self.config_manager.load_config_files()
        # 2. 加载数据文件
        self.data_manager.load_data_files()
        # 3. 创建用户界面
        self.ui_manager.create_interface()
        # 4. 初始化通信连接
        self.communication_manager.initialize_connections()
12.2.3 计算引擎类 (CalculationEngine)
python
class CalculationEngine:
    def __init__(self):
        self.expression_calculator = ExpressionCalculator()
        self.relation_judge = RelationJudge()
        self.precision_controller = PrecisionController()

    def calculate_parameters(self, input_data: Dict) -> Dict:
        """计算参数 - 基于getCalcResult"""
        results = {}
        # 执行calc.csv中定义的计算
        for calc_name, calc_expression in self.calc_definitions.items():
            result = self.expression_calculator.calculate(calc_expression, input_data)
            results[calc_name] = self.precision_controller.round_value(result)
        return results
12.2.4 ConfigManager（配置管理类）
python
class ConfigManager:
    def load_config_files(self):
        """加载所有配置文件"""
        # 加载INI配置文件
        self.load_ini_config()
        # 加载程序配置
        self.load_prg_config()
        # 加载类型定义
        self.load_type_definitions()
12.2.5 DataManager（数据管理类）
python
class DataManager:
    def load_data_files(self):
        """加载所有数据文件（对应VB.NET LoadFileToTBL方法）"""
        # 加载关系数据表
        self.load_relation_tables()
        # 加载计算数据表
        self.load_calc_tables()
        # 加载类型定义表
        self.load_type_tables()
12.2.6 UIManager（界面管理类）
python
class UIManager:
    def create_interface(self):
        """创建用户界面（对应VB.NET setControls方法）"""
        # 创建主窗口
        self.main_window = MainWindow()
        # 创建控件工厂
        self.control_factory = ControlFactory()
        # 创建事件处理器
        self.event_handler = EventHandler()
        
        # 创建8种核心控件系统
        self.create_load_controls()
        self.create_input_controls()
        self.create_measure_controls()
        self.create_select_controls()
        self.create_relation_controls()
        self.create_switch_controls()
        self.create_correct_controls()
        self.create_add_controls()
12.2.7 ControlFactory（控件工厂类）
python
class ControlFactory:
    def create_load_control(self, config):
        """创建加载控件（对应VB.NET makeCntrlLoad方法）"""
        # 实现加载控件创建逻辑
        pass
    
    def create_input_control(self, config):
        """创建输入控件（对应VB.NET makeCntrlInput方法）"""
        # 实现输入控件创建逻辑
        pass
12.2.8 通信管理器类 (CommunicationManager)
python
class CommunicationManager:
    def __init__(self):
        self.named_pipe_client = NamedPipeClient("DNC_Pipe")
        self.protocol_handler = NCProtocolHandler("rexroth")
        self.connection_manager = ConnectionManager()

    async def send_to_nc_machine(self, program_data: str):
        """发送数据到NC机 - 基于makeSendTxt"""
        formatted_message = self.protocol_handler.format_message("PROGRAM", program_data)
        await self.named_pipe_client.send_data(formatted_message)
12.3 8种核心控件系统架构设计
12.3.1 Load控件系统架构
设计模式：工厂模式 + 观察者模式
核心组件：

LoadControlFactory：加载控件工厂

LoadDataProvider：数据提供者

LoadEventHandler：事件处理器

12.3.2 Input控件系统架构
设计模式：策略模式 + 命令模式
核心组件：

InputStrategy：输入策略接口

KeyboardInput：键盘输入策略

CalculatorInput：计算器输入策略

12.3.3 Measure控件系统架构
设计模式：状态模式 + 装饰器模式
核心组件：

MeasureState：测量状态接口

NormalState：正常状态

WarningState：警告状态

12.3.4 Select控件系统架构
设计模式：组合模式 + 迭代器模式
核心组件：

SelectItem：选择项接口

SelectGroup：选择项组

SelectIterator：选择项迭代器

12.3.5 Relation控件系统架构
设计模式：中介者模式 + 责任链模式
核心组件：

RelationMediator：关系中介者

RelationHandler：关系处理器

ConditionChain：条件处理链

12.3.6 Switch控件系统架构
设计模式：状态模式 + 备忘录模式
核心组件：

SwitchState：开关状态接口

SwitchContext：开关上下文

SwitchMemento：开关状态备忘录

12.3.7 Correct控件系统架构
设计模式：命令模式 + 访问者模式
核心组件：

CorrectCommand：校正命令接口

CorrectVisitor：校正访问者

CorrectHistory：校正历史记录

12.3.8 Add控件系统架构
设计模式：建造者模式 + 原型模式
核心组件：

ControlGroupBuilder：控件组建造者

ControlGroupDirector：控件组指导者

ControlPrototype：控件原型

12.4 计算引擎架构设计
12.4.1 表达式解析器设计
核心组件：

ExpressionLexer：词法分析器

ExpressionParser：语法分析器

ExpressionEvaluator：表达式求值器

解析流程：

text
原始表达式 → 词法分析 → 语法分析 → 抽象语法树 → 求值计算 → 结果
12.4.2 数学函数库设计
函数分类：

基础数学函数：SIN, COS, TAN

统计函数：MAX, MIN, AVG

舍入函数：ROUND, CEILING, FLOOR

自定义函数：支持用户定义

12.4.3 条件判断引擎设计
条件类型：

数值比较条件

字符串匹配条件

逻辑组合条件

范围检查条件

12.5 通信模块架构设计
12.5.1 NC机床通信设计
协议支持：

Rexroth协议

Brother协议

自定义协议

通信管理：

连接池管理

消息队列管理

错误重试机制

12.5.2 进程间通信设计
通信方式：

命名管道通信

共享内存通信

消息队列通信

12.6 事件处理系统
python
class EventSystem:
    def __init__(self):
        self.event_handlers = {}
        self.text_change_handlers = {}

    def register_text_change_handler(self, control_id: str, handler: Callable):
        """注册文本变更处理器 - 基于txt_change"""
        self.text_change_handlers[control_id] = handler

    def _handle_text_change(self, control_id: str, new_text: str):
        """处理文本变更事件"""
        if control_id in self.text_change_handlers:
            handler = self.text_change_handlers[control_id]
            handler(new_text)
        # 触发计算引擎
        self._trigger_calculation(control_id, new_text)
13. 数据处理流程（基于VB.NET业务流程）
13.1 系统初始化数据处理流程
13.1.1 配置加载流程
流程步骤：

加载INI配置文件

读取系统基本配置

设置界面参数

初始化通信设置

加载程序配置

读取程序定义文件

设置程序参数

初始化程序状态

加载类型定义

读取类型定义表

建立类型关系映射

初始化类型转换规则

数据流图：

text
INI配置文件 → ConfigManager → 系统配置
PRG配置文件 → ConfigManager → 程序配置
类型定义文件 → ConfigManager → 类型定义
13.1.2 数据文件加载流程
流程步骤：

加载关系数据表

读取T_relation.csv

建立关系数据索引

缓存关系数据

加载计算数据表

读取T_calc.csv

建立计算规则索引

缓存计算数据

加载类型数据表

读取type_define.csv

读取type_relation.csv

读取type_chngvl.csv

数据流图：

text
CSV数据文件 → CSVProcessor → DataManager → 内存数据表
13.2 Master数据加载流程
13.2.1 主数据加载流程
流程步骤：

读取Master数据文件

加载header.csv（头部定义）

加载ini.csv（初始化数据）

加载type_*.csv（类型定义）

数据验证和转换

验证数据完整性

转换数据格式

建立数据索引

缓存管理

内存缓存数据表

建立快速搜索索引

数据版本管理

详细流程：

python
def load_master_data(self):
    """Master数据加载流程"""
    # 1. 加载头部定义
    header_data = self.csv_processor.read_csv('data/master/header.csv')
    
    # 2. 加载初始化数据
    ini_data = self.csv_processor.read_csv('data/master/ini.csv')
    
    # 3. 加载类型定义
    type_define = self.csv_processor.read_csv('data/master/type_define.csv')
    type_relation = self.csv_processor.read_csv('data/master/type_relation.csv')
    type_chngvl = self.csv_processor.read_csv('data/master/type_chngvl.csv')
    
    # 4. 数据验证
    self.validate_master_data(header_data, ini_data, type_define)
    
    # 5. 建立索引
    self.build_data_indexes()
    
    # 6. 缓存数据
    self.cache_master_data()
13.2.2 程序数据加载流程
流程步骤：

选择程序目录

根据程序编号选择prg1/prg2/prg3

加载程序配置文件

加载程序数据文件

加载add.csv（添加数据）

加载calc.csv（计算数据）

加载chngValue.csv（变更值数据）

加载cntrl.csv（控制数据）

加载correct.csv（校正数据）

加载define.csv（定义数据）

加载input.csv（输入数据）

加载load.csv（加载数据）

加载measure.csv（测量数据）

加载preset.csv（预设数据）

加载relation.csv（关系数据）

加载select.csv（选择数据）

加载switch.csv（开关数据）

数据关联和验证

建立程序内数据关联

验证数据一致性

初始化程序状态

13.3 实时计算处理流程
13.3.1 用户输入处理流程
流程步骤：

输入事件触发

文本框变更事件

按钮点击事件

组合框选择事件

数据验证

数值格式验证

数据范围检查

业务规则验证

相关数据搜索

搜索关系数据

搜索计算规则

搜索类型定义

计算执行

表达式计算

条件判断

结果验证

界面更新

更新相关控件值

刷新界面显示

状态提示更新

详细流程：

python
def handle_user_input(self, control_id, input_value):
    """用户输入处理流程"""
    # 1. 验证输入数据
    if not self.validate_input(control_id, input_value):
        return
    
    # 2. 搜索相关定义
    relation_config = self.search_relation_config(control_id)
    calc_config = self.search_calc_config(control_id)
    
    # 3. 执行计算
    if calc_config:
        result = self.calculation_engine.calculate(
            calc_config.expression, 
            {'@INPUT': input_value}
        )
    
    # 4. 更新相关控件
    if relation_config:
        self.update_related_controls(relation_config, result)
    
    # 5. 刷新界面
    self.ui_manager.refresh_display()
13.3.2 关系数据处理流程
流程步骤：

关系条件判断

获取关系条件配置

收集相关变量值

执行条件判断

值转换处理

搜索变更值表

执行值转换规则

验证转换结果

目标控件更新

设置目标控件值

更新控件状态

触发相关事件

详细流程：

python
def process_relation_data(self, source_control, source_value):
    """关系数据处理流程"""
    # 1. 搜索关系配置
    relation_configs = self.data_manager.search_relation_configs(source_control)
    
    for config in relation_configs:
        # 2. 收集相关变量
        variables = self.collect_relation_variables(config)
        
        # 3. 条件判断
        condition_result = self.calculation_engine.evaluate_condition(
            config.condition, variables
        )
        
        if condition_result:
            # 4. 值转换
            target_value = self.data_manager.search_chng_value(
                source_value, config.define
            )
            
            # 5. 更新目标控件
            self.ui_manager.set_control_value(
                config.target_control, target_value
            )
13.4 数据持久化流程
13.4.1 配置保存流程
流程步骤：

收集配置变更

界面设置变更

计算参数变更

通信设置变更

数据验证

配置完整性检查

参数范围验证

依赖关系验证

文件写入

写入INI配置文件

写入程序配置文件

写入类型定义文件

13.4.2 数据备份流程
流程步骤：

创建备份目录

按时间戳创建备份

保留历史版本

数据导出

导出配置数据

导出程序数据

导出计算数据

备份验证

验证备份完整性

检查数据一致性

生成备份报告

13.5 错误处理和恢复流程
13.5.1 数据错误处理流程
错误类型：

文件不存在错误

数据格式错误

数据验证错误

处理流程：

错误检测

文件访问错误检测

数据解析错误检测

业务规则错误检测

错误恢复

使用默认值恢复

从备份文件恢复

用户手动修复

错误日志

记录错误详细信息

生成错误报告

发送错误通知

14. 维护和扩展
14.1 数据维护
定期备份Master数据

数据完整性检查

版本控制支持

14.2 功能扩展
支持新的产品类型

添加新的计算逻辑

扩展程序模板

文档版本: 2.0
最后更新: 2025/10/23
维护者: DNC开发团队