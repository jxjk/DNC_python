# DNC系统开发详细文档

## 1. 项目概述

### 1.1 系统简介
DNC（Direct Numerical Control）系统是一个数控设备参数管理软件，用于从电脑直接传送参数到NC机的宏变量系统。该系统解决了传统NC机手动输入参数的时间和错误问题。

### 1.2 系统架构 - 基于VB.NET源码分析
- **原系统**: VB.NET DNC2.05 (基于Frm_main.vb主窗体)
- **新系统**: Python重写版本 (基于VB.NET源码完整重构)
- **系统构成**: PC + NC机 + LAN线 + DNC软件 + 命名管道通信
- **数据格式**: CSV文件存储Master数据 + 动态控件系统
- **核心架构**: 8种控件系统 + 计算引擎 + 通信模块 + 数据处理

## 2. 系统功能模块

### 2.1 核心功能模块

#### 2.1.1 产品型号管理
- 产品类型定义 (type_define.csv)
- 程序类型映射 (type_prg.csv)
- 产品参数配置 (load.csv)

#### 2.1.2 参数计算引擎
- 几何参数计算 (calc.csv)
- 关系验证逻辑 (relation.csv)
- 变量定义管理 (define.csv)

#### 2.1.3 程序生成器
- 程序定义 (prg.csv)
- 控制参数 (cntrl_rex.csv)
- 选择逻辑 (select.csv)

### 2.2 数据流处理

#### 2.2.1 输入处理
```python
输入 → 参数验证 → 计算引擎 → 程序生成 → 输出
```

#### 2.2.2 宏变量映射
- #500-#600: 系统参数
- #1-#100: 用户参数
- 特殊变量: 计算中间值

## 3. 数据结构详细说明

### 3.1 核心数据文件

#### 3.1.1 type_define.csv (产品类型定义)
- **文件大小**: 988.60 KB
- **数据结构**:
  - NO: 序号
  - TYPE: 产品型号 (如: GPA18GT15040-A)
  - DEFINE1: 定义1
  - DEFINE2: 定义2

#### 3.1.2 type_prg.csv (程序类型映射)
- **文件大小**: 480.92 KB
- **数据结构**:
  - NO: 序号
  - prg1: 程序1编号
  - prg2: 程序2编号

#### 3.1.3 load.csv (主数据文件)
- **文件大小**: 8.5 MB
- **数据结构**:
  - NO: 序号
  - TYPE: 产品型号
  - DRAWING: 图纸文件
  - DISPFLG: 显示标志
  - #1-#12: 定义变量
  - #500-#550: 系统参数
  - #602-#603: 开关控制

#### 3.1.4 cntrl_rex.csv (参数控制)
- **文件大小**: 1.10 KB
- **数据结构**:
  - PARAMETER: 参数名称 (如: Work_plan, Teeth_num)
  - DATATYPE: 数据类型 (int, real, boolean)
  - MACRO: 宏变量映射 (如: #510, #511)

### 3.2 计算逻辑文件

#### 3.2.1 calc.csv (计算定义)
```csv
DEFINE,1,2,3,4,5,6,7,8,9,10,11,12,13
calcABC,=,#528,-,#510,*,2,NaN,NaN,NaN,NaN,NaN,NaN,NaN
calcABCD,=,(,#528,-,#513,),/,2.0,NaN,NaN,NaN,NaN,NaN
```

#### 3.2.2 relation.csv (关系验证)
```csv
DEFINE,VALUE,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28
relationHPN,#1,and,#1,>,0.0,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN
```

#### 3.2.3 define.csv (变量定义)
```csv
DEFINE,STR,BEFORE,AFTER,CHNGVL,CALC
defineP,P,P0,0,NaN,NaN
defineH,H,H0,0,NaN,NaN
```

## 4. 技术架构设计

### 4.1 系统架构图

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   用户界面层     │    │   业务逻辑层     │    │   数据访问层     │
│                 │    │                 │    │                 │
│  - 主窗口       │◄──►│  - 参数计算     │◄──►│  - CSV处理器    │
│  - 输入表单     │    │  - 程序生成     │    │  - 数据验证     │
│  - 结果显示     │    │  - 关系验证     │    │  - 编码处理     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 4.2 核心类设计

#### 4.2.1 DataManager (数据管理器)
```python
class DataManager:
    def load_master_data(self) -> Dict[str, pd.DataFrame]
    def batch_read_large_csv(self, file_path: str, batch_size: int = 1000)
    def validate_data_integrity(self) -> bool
    def fix_encoding_issues(self, file_path: str) -> pd.DataFrame
```

#### 4.2.2 CalculationEngine (计算引擎)
```python
class CalculationEngine:
    def calculate_parameters(self, input_data: Dict) -> Dict
    def validate_relations(self, calculated_data: Dict) -> bool
    def generate_macro_variables(self, params: Dict) -> List[str]
```

#### 4.2.3 ProgramGenerator (程序生成器)
```python
class ProgramGenerator:
    def generate_nc_program(self, product_type: str, params: Dict) -> str
    def apply_program_template(self, template: str, variables: Dict) -> str
    def validate_program_syntax(self, program: str) -> bool
```

## 5. 数据处理流程

### 5.1 数据加载流程
1. **扫描目录**: 递归扫描master目录下的所有CSV文件
2. **分类处理**: 根据文件大小分类为小文件和大文件
3. **编码检测**: 自动检测文件编码 (UTF-8, Shift-JIS, CP932)
4. **分批读取**: 大文件使用分批读取机制
5. **数据验证**: 检查数据完整性和一致性

### 5.2 参数计算流程
1. **输入验证**: 验证用户输入参数的有效性
2. **变量替换**: 根据define.csv进行变量替换
3. **计算执行**: 执行calc.csv中定义的计算逻辑
4. **关系验证**: 验证relation.csv中定义的关系条件
5. **结果生成**: 生成最终的宏变量值

## 6. 文件编码处理

### 6.1 编码问题文件列表
- `ini.csv`: 958字节，编码问题
- `math.csv`: 1.08KB，编码问题  
- `cntrl.csv`: 1.38KB，编码问题
- `switch.csv`: 106字节，编码问题

### 6.2 编码处理策略
```python
def detect_encoding(file_path: str) -> str:
    encodings = ['utf-8', 'shift_jis', 'cp932', 'latin1']
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as f:
                f.read()
            return encoding
        except UnicodeDecodeError:
            continue
    return 'unknown'
```

## 7. 性能优化策略

### 7.1 大文件处理优化
- **分批读取**: 使用pandas的chunksize参数
- **内存管理**: 及时释放不需要的数据
- **缓存机制**: 缓存频繁访问的数据

### 7.2 计算优化
- **预编译**: 预编译计算表达式
- **并行处理**: 使用多线程处理独立计算
- **结果缓存**: 缓存重复计算结果

## 8. 错误处理机制

### 8.1 数据验证错误
- 文件不存在错误
- 编码错误处理
- 数据格式错误
- 完整性检查失败

### 8.2 计算错误
- 除零错误处理
- 变量未定义错误
- 关系验证失败
- 程序生成错误

## 9. 部署和配置

### 9.1 环境要求
- Python 3.8+
- pandas >= 1.3.0
- PyQt5/PySide6
- 操作系统: Windows 10/11

### 9.2 配置文件
```ini
[system]
data_directory = ./data/master
log_level = INFO
batch_size = 1000

[encoding]
default_encoding = utf-8
fallback_encodings = shift_jis,cp932,latin1
```

## 10. 测试策略

### 10.1 单元测试
- 数据加载测试
- 计算逻辑测试
- 程序生成测试
- 错误处理测试

### 10.2 集成测试
- 端到端流程测试
- 性能测试
- 兼容性测试

## 11. 功能模块详细设计

### 11.1 控件系统详细设计

#### 11.1.1 8种核心控件类型实现

**Load控件 (makeCntrlLoad)**
```python
class LoadControl:
    def __init__(self, data_source: str, field_mapping: Dict):
        self.data_source = data_source
        self.field_mapping = field_mapping
        self.data_table = None
    
    def load_data(self) -> pd.DataFrame:
        """从CSV文件加载数据"""
        try:
            self.data_table = pd.read_csv(self.data_source, encoding='utf-8')
            return self.data_table
        except Exception as e:
            logger.error(f"加载数据失败: {e}")
            return None
    
    def validate_data(self) -> bool:
        """验证数据完整性"""
        required_fields = ['NO', 'TYPE', 'DRAWING']
        return all(field in self.data_table.columns for field in required_fields)
```

**Input控件 (makeCntrlInput)**
```python
class InputControl:
    def __init__(self, control_id: str, data_type: str, validation_rules: Dict):
        self.control_id = control_id
        self.data_type = data_type
        self.validation_rules = validation_rules
        self.value = None
    
    def handle_text_change(self, new_value: str):
        """处理文本变更事件"""
        if self.validate_input(new_value):
            self.value = self.convert_value(new_value)
            self.trigger_calculation()
    
    def validate_input(self, value: str) -> bool:
        """验证输入值"""
        if self.data_type == 'numeric':
            return self._validate_numeric(value)
        elif self.data_type == 'string':
            return self._validate_string(value)
        return False
```

#### 11.1.2 基础控件创建方法Python实现

**文本框创建 (makeTextBox)**
```python
def create_text_box(name: str, location: Tuple[int, int], size: Tuple[int, int], 
                   text_change_handler: Callable) -> QLineEdit:
    """创建文本框控件"""
    text_box = QLineEdit()
    text_box.setObjectName(name)
    text_box.setGeometry(location[0], location[1], size[0], size[1])
    text_box.textChanged.connect(text_change_handler)
    return text_box
```

**标签创建 (makeLabel)**
```python
def create_label(name: str, text: str, location: Tuple[int, int], 
                size: Tuple[int, int]) -> QLabel:
    """创建标签控件"""
    label = QLabel(text)
    label.setObjectName(name)
    label.setGeometry(location[0], location[1], size[0], size[1])
    return label
```

#### 11.1.3 动态控件管理技术细节

**控件生命周期管理**
```python
class ControlManager:
    def __init__(self):
        self.controls = {}
        self.control_groups = {}
    
    def add_control(self, control_id: str, control: QWidget):
        """添加控件到管理器"""
        self.controls[control_id] = control
    
    def remove_control(self, control_id: str):
        """移除控件"""
        if control_id in self.controls:
            self.controls[control_id].deleteLater()
            del self.controls[control_id]
    
    def enable_controls(self, control_ids: List[str], enabled: bool):
        """批量启用/禁用控件"""
        for control_id in control_ids:
            if control_id in self.controls:
                self.controls[control_id].setEnabled(enabled)
```

### 11.2 计算引擎详细设计

#### 11.2.1 表达式计算具体算法

**表达式解析器 (getCalcResult)**
```python
class ExpressionCalculator:
    def __init__(self):
        self.variables = {}
        self.functions = {
            'MAX': max,
            'MIN': min,
            'ROUND': round,
            'ABS': abs
        }
    
    def calculate(self, expression: str, variables: Dict) -> float:
        """计算表达式值"""
        try:
            # 变量替换
            expr = self._replace_variables(expression, variables)
            # 表达式求值
            result = eval(expr, {"__builtins__": None}, self.functions)
            return float(result)
        except Exception as e:
            logger.error(f"表达式计算错误: {expression}, 错误: {e}")
            return 0.0
    
    def _replace_variables(self, expression: str, variables: Dict) -> str:
        """替换表达式中的变量"""
        for var_name, var_value in variables.items():
            expression = expression.replace(f"@{var_name}", str(var_value))
        return expression
```

#### 11.2.2 条件判断系统实现逻辑

**关系判断引擎 (judgeRelation)**
```python
class RelationJudge:
    def judge(self, condition: str, left_value: Any, right_value: Any) -> bool:
        """判断关系条件"""
        operators = {
            '=': lambda x, y: x == y,
            '<>': lambda x, y: x != y,
            '>': lambda x, y: x > y,
            '<': lambda x, y: x < y,
            '>=': lambda x, y: x >= y,
            '<=': lambda x, y: x <= y
        }
        
        for op, func in operators.items():
            if op in condition:
                return func(left_value, right_value)
        
        return False
```

#### 11.2.3 精度控制技术方案

**数值精度管理**
```python
class PrecisionController:
    def __init__(self, decimal_places: int = 4):
        self.decimal_places = decimal_places
    
    def round_value(self, value: float) -> float:
        """四舍五入处理"""
        return round(value, self.decimal_places)
    
    def format_display(self, value: float) -> str:
        """格式化显示值"""
        return f"{value:.{self.decimal_places}f}".rstrip('0').rstrip('.')
```

### 11.3 数据处理模块详细设计

#### 11.3.1 文件加载系统实现细节

**CSV文件加载器 (LoadFileToTBL)**
```python
class CSVLoader:
    def __init__(self, encoding_detector: EncodingDetector):
        self.encoding_detector = encoding_detector
    
    def load_file(self, file_path: str) -> pd.DataFrame:
        """加载CSV文件"""
        encoding = self.encoding_detector.detect_encoding(file_path)
        
        try:
            df = pd.read_csv(file_path, encoding=encoding)
            return self._clean_data(df)
        except Exception as e:
            logger.error(f"文件加载失败: {file_path}, 错误: {e}")
            return pd.DataFrame()
    
    def _clean_data(self, df: pd.DataFrame) -> pd.DataFrame:
        """数据清理"""
        # 移除空行
        df = df.dropna(how='all')
        # 处理NaN值
        df = df.fillna('')
        return df
```

#### 11.3.2 数据搜索功能算法设计

**表搜索引擎 (searchT_relation)**
```python
class TableSearcher:
    def __init__(self, data_tables: Dict[str, pd.DataFrame]):
        self.data_tables = data_tables
        self.search_cache = {}
    
    def search_table(self, table_name: str, search_criteria: Dict) -> pd.DataFrame:
        """搜索数据表"""
        cache_key = f"{table_name}_{str(search_criteria)}"
        if cache_key in self.search_cache:
            return self.search_cache[cache_key]
        
        if table_name not in self.data_tables:
            return pd.DataFrame()
        
        table = self.data_tables[table_name]
        result = table.copy()
        
        for column, value in search_criteria.items():
            if column in table.columns:
                result = result[result[column] == value]
        
        self.search_cache[cache_key] = result
        return result
```

#### 11.3.3 数据操作技术实现

**数据转换器 (searchT_ChngValue)**
```python
class DataConverter:
    def __init__(self, conversion_rules: Dict):
        self.conversion_rules = conversion_rules
    
    def convert_value(self, value: Any, conversion_type: str) -> Any:
        """转换数据值"""
        if conversion_type in self.conversion_rules:
            rule = self.conversion_rules[conversion_type]
            return rule(value)
        return value
    
    def add_conversion_rule(self, conversion_type: str, rule: Callable):
        """添加转换规则"""
        self.conversion_rules[conversion_type] = rule
```

### 11.4 通信模块详细设计

#### 11.4.1 通信协议支持技术实现

**NC通信协议处理器 (makeSendTxt)**
```python
class NCProtocolHandler:
    def __init__(self, protocol_type: str):
        self.protocol_type = protocol_type
        self.message_formatters = {
            'rexroth': self._format_rexroth_message,
            'brother': self._format_brother_message
        }
    
    def format_message(self, command: str, parameters: Dict) -> str:
        """格式化NC命令消息"""
        if self.protocol_type in self.message_formatters:
            return self.message_formatters[self.protocol_type](command, parameters)
        return command
    
    def _format_rexroth_message(self, command: str, parameters: Dict) -> str:
        """格式化Rexroth协议消息"""
        # Rexroth协议特定格式化逻辑
        return f"{command} {self._format_parameters(parameters)}"
    
    def _format_brother_message(self, command: str, parameters: Dict) -> str:
        """格式化Brother协议消息"""
        # Brother协议特定格式化逻辑
        return f"{command};{self._format_parameters(parameters)}"
```

#### 11.4.2 进程间通信机制设计

**连接状态管理器 (ConnectionChange)**
```python
class ConnectionManager:
    def __init__(self):
        self.connections = {}
        self.connection_callbacks = []
    
    def add_connection(self, connection_id: str, connection: object):
        """添加连接"""
        self.connections[connection_id] = connection
        self._notify_connection_change(connection_id, 'connected')
    
    def remove_connection(self, connection_id: str):
        """移除连接"""
        if connection_id in self.connections:
            del self.connections[connection_id]
            self._notify_connection_change(connection_id, 'disconnected')
    
    def _notify_connection_change(self, connection_id: str, status: str):
        """通知连接状态变更"""
        for callback in self.connection_callbacks:
            callback(connection_id, status)
```

#### 11.4.3 命名管道通信具体实现

**异步命名管道客户端 (NamedPipeAsyncClient)**
```python
class NamedPipeClient:
    def __init__(self, pipe_name: str):
        self.pipe_name = pipe_name
        self.connected = False
        self.data_received_callbacks = []
    
    async def connect(self):
        """异步连接命名管道"""
        try:
            # Windows命名管道连接实现
            self.connected = True
            await self._start_listening()
        except Exception as e:
            logger.error(f"命名管道连接失败: {e}")
            self.connected = False
    
    async def send_data(self, data: str):
        """异步发送数据"""
        if self.connected:
            # 实现数据发送逻辑
            pass
    
    def add_data_received_callback(self, callback: Callable):
        """添加数据接收回调"""
        self.data_received_callbacks.append(callback)
```

### 11.5 用户界面交互详细设计

#### 11.5.1 事件处理系统架构设计

**事件分发器**
```python
class EventDispatcher:
    def __init__(self):
        self.event_handlers = {}
    
    def register_handler(self, event_type: str, handler: Callable):
        """注册事件处理器"""
        if event_type not in self.event_handlers:
            self.event_handlers[event_type] = []
        self.event_handlers[event_type].append(handler)
    
    def dispatch_event(self, event_type: str, event_data: Dict):
        """分发事件"""
        if event_type in self.event_handlers:
            for handler in self.event_handlers[event_type]:
                try:
                    handler(event_data)
                except Exception as e:
                    logger.error(f"事件处理错误: {e}")
```

#### 11.5.2 输入处理技术实现

**文本变更处理器 (txt_change)**
```python
class TextChangeHandler:
    def __init__(self, validation_rules: Dict, calculation_trigger: Callable):
        self.validation_rules = validation_rules
        self.calculation_trigger = calculation_trigger
        self.change_event_flag = False
    
    def handle_text_change(self, control_id: str, new_text: str):
        """处理文本变更"""
        if self.change_event_flag:
            return
        
        self.change_event_flag = True
        
        try:
            # 数据验证
            if self._validate_text(control_id, new_text):
                # 触发计算
                self.calculation_trigger(control_id, new_text)
        finally:
            self.change_event_flag = False
    
    def _validate_text(self, control_id: str, text: str) -> bool:
        """验证文本内容"""
        if control_id in self.validation_rules:
            rule = self.validation_rules[control_id]
            return rule(text)
        return True
```

#### 11.5.3 操作员管理功能设计

**操作员管理器 (TB_OpeID_TextChanged)**
```python
class OperatorManager:
    def __init__(self):
        self.current_operator = None
        self.operator_database = {}
    
    def set_operator(self, operator_id: str):
        """设置当前操作员"""
        if operator_id in self.operator_database:
            self.current_operator = self.operator_database[operator_id]
            logger.info(f"操作员已切换: {self.current_operator.name}")
        else:
            logger.warning(f"未知操作员ID: {operator_id}")
    
    def get_operator_name(self, operator_id: str) -> str:
        """获取操作员名称"""
        if operator_id in self.operator_database:
            return self.operator_database[operator_id].name
        return "未知操作员"
```

### 11.6 数据验证模块详细设计

#### 11.6.1 验证方法具体实现

**数值验证器 (chkTxtIsNumeric)**
```python
class NumericValidator:
    def validate(self, text: str, min_value: float = None, 
                max_value: float = None, decimal_places: int = None) -> bool:
        """验证数值文本"""
        try:
            value = float(text)
            
            if min_value is not None and value < min_value:
                return False
            
            if max_value is not None and value > max_value:
                return False
            
            if decimal_places is not None:
                # 检查小数位数
                decimal_part = str(value).split('.')
                if len(decimal_part) > 1 and len(decimal_part[1]) > decimal_places:
                    return False
            
            return True
        except ValueError:
            return False
```

#### 11.6.2 验证规则技术设计

**业务规则验证器 (chkAddControls)**
```python
class BusinessRuleValidator:
    def __init__(self, validation_rules: Dict):
        self.validation_rules = validation_rules
    
    def validate_controls(self, control_values: Dict) -> Dict[str, str]:
        """验证控件组业务规则"""
        errors = {}
        
        for rule_name, rule in self.validation_rules.items():
            if not rule(control_values):
                errors[rule_name] = f"业务规则验证失败: {rule_name}"
        
        return errors
    
    def add_validation_rule(self, rule_name: str, rule: Callable):
        """添加验证规则"""
        self.validation_rules[rule_name] = rule
```

#### 11.6.3 错误处理机制

**验证错误处理器**
```python
class ValidationErrorHandler:
    def __init__(self):
        self.error_messages = {}
    
    def add_error(self, control_id: str, message: str):
        """添加错误信息"""
        if control_id not in self.error_messages:
            self.error_messages[control_id] = []
        self.error_messages[control_id].append(message)
    
    def clear_errors(self, control_id: str = None):
        """清除错误信息"""
        if control_id:
            if control_id in self.error_messages:
                del self.error_messages[control_id]
        else:
            self.error_messages.clear()
    
    def has_errors(self) -> bool:
        """检查是否有错误"""
        return len(self.error_messages) > 0
```

### 11.7 系统管理模块详细设计

#### 11.7.1 初始化系统技术实现

**系统初始化器 (Frm_main_Load)**
```python
class SystemInitializer:
    def __init__(self, config_manager: ConfigManager, data_manager: DataManager):
        self.config_manager = config_manager
        self.data_manager = data_manager
        self.initialization_steps = [
            self._load_configuration,
            self._load_master_data,
            self._initialize_ui,
            self._setup_communication
        ]
    
    async def initialize_system(self):
        """异步初始化系统"""
        for step in self.initialization_steps:
            try:
                await step()
            except Exception as e:
                logger.error(f"初始化步骤失败: {e}")
                raise
    
    async def _load_configuration(self):
        """加载系统配置"""
        self.config = await self.config_manager.load_config()
    
    async def _load_master_data(self):
        """加载Master数据"""
        self.master_data = await self.data_manager.load_master_data()
    
    async def _initialize_ui(self):
        """初始化用户界面"""
        # 创建主窗口和控件
        pass
    
    async def _setup_communication(self):
        """设置通信连接"""
        # 初始化NC通信和命名管道
        pass
```

#### 11.7.2 显示管理功能设计

**控件状态管理器 (ControlStateManager)**
```python
class ControlStateManager:
    def __init__(self):
        self.control_states = {}
        self.control_groups = {}
    
    def set_controls_enabled(self, control_ids: List[str], enabled: bool):
        """设置控件启用状态"""
        for control_id in control_ids:
            if control_id in self.control_states:
                self.control_states[control_id].setEnabled(enabled)
    
    def set_controls_visible(self, control_ids: List[str], visible: bool):
        """设置控件可见性"""
        for control_id in control_ids:
            if control_id in self.control_states:
                self.control_states[control_id].setVisible(visible)
    
    def add_control_group(self, group_name: str, control_ids: List[str]):
        """添加控件组"""
        self.control_groups[group_name] = control_ids
    
    def set_group_enabled(self, group_name: str, enabled: bool):
        """设置控件组启用状态"""
        if group_name in self.control_groups:
            self.set_controls_enabled(self.control_groups[group_name], enabled)
```

#### 11.7.3 配置管理技术方案

**INI配置管理器 (IniConfigManager)**
```python
class IniConfigManager:
    def __init__(self, ini_file_path: str):
        self.ini_file_path = ini_file_path
        self.config = {}
    
    def load_config(self) -> Dict:
        """加载INI配置文件"""
        config = configparser.ConfigParser()
        config.read(self.ini_file_path, encoding='utf-8')
        
        for section in config.sections():
            self.config[section] = dict(config.items(section))
        
        return self.config
    
    def save_config(self, config: Dict):
        """保存INI配置文件"""
        config_parser = configparser.ConfigParser()
        
        for section, options in config.items():
            config_parser[section] = options
        
        with open(self.ini_file_path, 'w', encoding='utf-8') as f:
            config_parser.write(f)
    
    def get_value(self, section: str, key: str, default=None):
        """获取配置值"""
        return self.config.get(section, {}).get(key, default)
```

### 11.8 工具方法详细设计

#### 11.8.1 字符串处理技术实现

**字符串工具类 (StringUtils)**
```python
class StringUtils:
    @staticmethod
    def len_b(text: str) -> int:
        """计算字符串字节长度（兼容VB.NET的LenB函数）"""
        return len(text.encode('utf-8'))
    
    @staticmethod
    def make_format_str(format_pattern: str, *args) -> str:
        """创建格式化字符串"""
        try:
            return format_pattern.format(*args)
        except Exception as e:
            logger.error(f"字符串格式化失败: {e}")
            return format_pattern
    
    @staticmethod
    def to_half_adjust(value: float, decimal_places: int = 0) -> float:
        """四舍五入处理（兼容VB.NET的ToHalfAdjust）"""
        factor = 10 ** decimal_places
        return round(value * factor) / factor
    
    @staticmethod
    def get_operator_name(operator_id: str) -> str:
        """获取操作员名称"""
        operator_map = {
            '001': '操作员A',
            '002': '操作员B',
            '003': '操作员C'
        }
        return operator_map.get(operator_id, '未知操作员')
```

#### 11.8.2 系统工具功能设计

**系统工具类 (SystemUtils)**
```python
class SystemUtils:
    @staticmethod
    def get_all_controls(parent_widget: QWidget) -> List[QWidget]:
        """获取所有子控件"""
        controls = []
        
        def collect_controls(widget):
            for child in widget.children():
                if isinstance(child, QWidget):
                    controls.append(child)
                    collect_controls(child)
        
        collect_controls(parent_widget)
        return controls
    
    @staticmethod
    def change_form_size(form: QWidget, width: int, height: int):
        """改变窗体大小"""
        form.resize(width, height)
    
    @staticmethod
    def show_info_form(title: str, message: str):
        """显示信息窗体"""
        msg_box = QMessageBox()
        msg_box.setWindowTitle(title)
        msg_box.setText(message)
        msg_box.setIcon(QMessageBox.Information)
        msg_box.exec_()
```

#### 11.8.3 数值处理工具

**公差计算器 (ToleranceCalculator)**
```python
class ToleranceCalculator:
    @staticmethod
    def get_shafts_tolerance(diameter: float, tolerance_class: str) -> Tuple[float, float]:
        """获取轴公差"""
        tolerance_tables = {
            'h6': {10: (-0.009, 0), 18: (-0.011, 0), 30: (-0.013, 0)},
            'h7': {10: (-0.015, 0), 18: (-0.018, 0), 30: (-0.021, 0)},
            'h8': {10: (-0.022, 0), 18: (-0.027, 0), 30: (-0.033, 0)}
        }
        
        for max_diameter, tolerance in tolerance_tables.get(tolerance_class, {}).items():
            if diameter <= max_diameter:
                return tolerance
        
        return (0, 0)
    
    @staticmethod
    def get_length_tolerance(length: float, tolerance_class: str) -> Tuple[float, float]:
        """获取长度公差"""
        tolerance_tables = {
            'fine': {100: (-0.1, 0.1), 400: (-0.2, 0.2), 1000: (-0.3, 0.3)},
            'medium': {100: (-0.2, 0.2), 400: (-0.4, 0.4), 1000: (-0.6, 0.6)},
            'coarse': {100: (-0.4, 0.4), 400: (-0.8, 0.8), 1000: (-1.2, 1.2)}
        }
        
        for max_length, tolerance in tolerance_tables.get(tolerance_class, {}).items():
            if length <= max_length:
                return tolerance
        
        return (0, 0)
```

## 12. 技术架构设计

### 12.1 核心类设计 - 基于VB.NET源码分析

#### 12.1.1 主窗体类 (Frm_main)
```python
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.control_manager = ControlManager()
        self.data_manager = DataManager()
        self.calculation_engine = CalculationEngine()
        self.communication_manager = CommunicationManager()
        
        # 基于VB.NET Frm_main.vb的初始化逻辑
        self._initialize_ui()
        self._load_master_data()
        self._setup_communication()
    
    def _initialize_ui(self):
        """初始化用户界面 - 基于VB.NET Frm_main_Load"""
        # 创建8种控件系统
        self._create_load_controls()
        self._create_input_controls()
        self._create_calc_controls()
        self._create_relation_controls()
        self._create_define_controls()
        self._create_select_controls()
        self._create_switch_controls()
        self._create_preset_controls()
        
        # 设置窗体属性
        self.setWindowTitle("DNC系统")
        self.resize(1024, 768)
    
    def _create_load_controls(self):
        """创建Load控件 - 基于makeCntrlLoad"""
        # 实现Load控件创建逻辑
        pass
    
    def _create_input_controls(self):
        """创建Input控件 - 基于makeCntrlInput"""
        # 实现Input控件创建逻辑
        pass
```

#### 12.1.2 计算引擎类 (CalculationEngine)
```python
class CalculationEngine:
    def __init__(self):
        self.expression_calculator = ExpressionCalculator()
        self.relation_judge = RelationJudge()
        self.precision_controller = PrecisionController()
    
    def calculate_parameters(self, input_data: Dict) -> Dict:
        """计算参数 - 基于getCalcResult"""
        results = {}
        
        # 执行calc.csv中定义的计算
        for calc_name, calc_expression in self.calc_definitions.items():
            result = self.expression_calculator.calculate(calc_expression, input_data)
            results[calc_name] = self.precision_controller.round_value(result)
        
        return results
    
    def validate_relations(self, calculated_data: Dict) -> bool:
        """验证关系 - 基于judgeRelation"""
        for relation_name, relation_condition in self.relation_definitions.items():
            if not self.relation_judge.judge(relation_condition, calculated_data):
                return False
        return True
```

#### 12.1.3 通信管理器类 (CommunicationManager)
```python
class CommunicationManager:
    def __init__(self):
        self.named_pipe_client = NamedPipeClient("DNC_Pipe")
        self.protocol_handler = NCProtocolHandler("rexroth")
        self.connection_manager = ConnectionManager()
    
    async def send_to_nc_machine(self, program_data: str):
        """发送数据到NC机 - 基于makeSendTxt"""
        formatted_message = self.protocol_handler.format_message("PROGRAM", program_data)
        await self.named_pipe_client.send_data(formatted_message)
    
    def handle_connection_change(self, connection_id: str, status: str):
        """处理连接状态变更 - 基于ConnectionChange"""
        self.connection_manager.notify_connection_change(connection_id, status)
```

### 12.2 系统架构图 - 基于8种控件系统

```
┌─────────────────────────────────────────────────────────────────┐
│                        DNC系统架构图                            │
├─────────────────┬─────────────────┬─────────────────┬───────────┤
│   用户界面层     │   业务逻辑层     │   数据处理层     │  通信层    │
│                 │                 │                 │           │
│  - 主窗口       │  - 计算引擎     │  - CSV加载器    │  - 命名管道│
│  - 8种控件系统  │  - 关系验证     │  - 数据验证     │  - NC协议  │
│  - 事件处理     │  - 程序生成     │  - 编码处理     │  - 连接管理│
│                 │  - 精度控制     │  - 缓存管理     │           │
└─────────────────┴─────────────────┴─────────────────┴───────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                        数据存储层                                │
│                                                                 │
│  - Master数据文件 (CSV格式)                                     │
│  - 配置文件 (INI格式)                                          │
│  - 日志文件                                                    │
└─────────────────────────────────────────────────────────────────┘
```

### 12.3 动态控件管理技术细节

#### 12.3.1 控件生命周期管理
```python
class DynamicControlManager:
    def __init__(self):
        self.controls = {}
        self.control_templates = {}
        self.control_groups = {}
    
    def create_control(self, control_type: str, control_id: str, 
                      properties: Dict) -> QWidget:
        """动态创建控件 - 基于VB.NET控件创建方法"""
        if control_type == "TextBox":
            return self._create_text_box(control_id, properties)
        elif control_type == "Label":
            return self._create_label(control_id, properties)
        elif control_type == "Button":
            return self._create_button(control_id, properties)
        # 其他控件类型...
    
    def _create_text_box(self, control_id: str, properties: Dict) -> QLineEdit:
        """创建文本框 - 基于makeTextBox"""
        text_box = QLineEdit()
        text_box.setObjectName(control_id)
        text_box.setGeometry(properties.get('x', 0), 
                           properties.get('y', 0),
                           properties.get('width', 100),
                           properties.get('height', 25))
        
        # 绑定事件处理
        text_box.textChanged.connect(
            lambda text: self._handle_text_change(control_id, text)
        )
        
        self.controls[control_id] = text_box
        return text_box
    
    def manage_control_group(self, group_name: str, control_ids: List[str]):
        """管理控件组 - 基于控件分组逻辑"""
        self.control_groups[group_name] = control_ids
    
    def enable_control_group(self, group_name: str, enabled: bool):
        """启用/禁用控件组"""
        if group_name in self.control_groups:
            for control_id in self.control_groups[group_name]:
                if control_id in self.controls:
                    self.controls[control_id].setEnabled(enabled)
```

#### 12.3.2 事件处理系统
```python
class EventSystem:
    def __init__(self):
        self.event_handlers = {}
        self.text_change_handlers = {}
    
    def register_text_change_handler(self, control_id: str, handler: Callable):
        """注册文本变更处理器 - 基于txt_change"""
        self.text_change_handlers[control_id] = handler
    
    def _handle_text_change(self, control_id: str, new_text: str):
        """处理文本变更事件"""
        if control_id in self.text_change_handlers:
            handler = self.text_change_handlers[control_id]
            handler(new_text)
        
        # 触发计算引擎
        self._trigger_calculation(control_id, new_text)
    
    def _trigger_calculation(self, control_id: str, value: str):
        """触发计算 - 基于文本变更后的计算逻辑"""
        # 更新变量值
        self.variables[control_id] = value
        
        # 执行相关计算
        affected_calculations = self._get_affected_calculations(control_id)
        for calc_id in affected_calculations:
            self.calculation_engine.calculate(calc_id, self.variables)
```

## 13. 数据处理流程

### 13.1 基于VB.NET业务流程的完整处理流程

#### 13.1.1 Master数据加载流程
```python
class MasterDataLoader:
    def __init__(self):
        self.csv_loader = CSVLoader()
        self.encoding_detector = EncodingDetector()
        self.data_validator = DataValidator()
    
    def load_master_data(self) -> Dict[str, pd.DataFrame]:
        """加载Master数据 - 基于VB.NET数据加载流程"""
        master_data = {}
        
        # 1. 扫描master目录
        master_files = self._scan_master_directory()
        
        # 2. 分类处理文件
        for file_path in master_files:
            file_name = os.path.basename(file_path)
            
            # 3. 检测编码
            encoding = self.encoding_detector.detect_encoding(file_path)
            
            # 4. 分批读取大文件
            if self._is_large_file(file_path):
                data = self._batch_read_large_csv(file_path, encoding)
            else:
                data = pd.read_csv(file_path, encoding=encoding)
            
            # 5. 数据验证
            if self.data_validator.validate_data(data, file_name):
                master_data[file_name] = data
        
        return master_data
    
    def _scan_master_directory(self) -> List[str]:
        """扫描master目录 - 基于VB.NET目录扫描逻辑"""
        master_dir = "./data/master"
        csv_files = []
        
        for root, dirs, files in os.walk(master_dir):
            for file in files:
                if file.endswith('.csv'):
                    csv_files.append(os.path.join(root, file))
        
        return csv_files
    
    def _batch_read_large_csv(self, file_path: str, encoding: str, 
                             batch_size: int = 1000) -> pd.DataFrame:
        """分批读取大CSV文件"""
        chunks = []
        for chunk in pd.read_csv(file_path, encoding=encoding, chunksize=batch_size):
            chunks.append(chunk)
        
        return pd.concat(chunks, ignore_index=True)
```

#### 13.1.2 实时计算流程
```python
class RealTimeCalculationFlow:
    def __init__(self):
        self.calculation_engine = CalculationEngine()
        self.variable_manager = VariableManager()
        self.relation_validator = RelationValidator()
    
    def process_input_change(self, control_id: str, new_value: str):
        """处理输入变更 - 基于实时计算流程"""
        # 1. 输入验证
        if not self._validate_input(control_id, new_value):
            return
        
        # 2. 变量替换
        processed_value = self._apply_variable_substitution(control_id, new_value)
        
        # 3. 更新变量管理器
        self.variable_manager.update_variable(control_id, processed_value)
        
        # 4. 执行计算
        calculation_results = self.calculation_engine.calculate_all(
            self.variable_manager.get_all_variables()
        )
        
        # 5. 关系验证
        validation_passed = self.relation_validator.validate_all_relations(
            calculation_results
        )
        
        # 6. 更新显示
        if validation_passed:
            self._update_display(calculation_results)
        else:
            self._show_validation_errors()
    
    def _validate_input(self, control_id: str, value: str) -> bool:
        """验证输入 - 基于chkTxtIsNumeric等验证方法"""
        validation_rules = self._get_validation_rules(control_id)
        
        for rule in validation_rules:
            if not rule(value):
                return False
        
        return True
    
    def _apply_variable_substitution(self, control_id: str, value: str) -> Any:
        """应用变量替换 - 基于define.csv逻辑"""
        substitution_rules = self._get_substitution_rules(control_id)
        
        for before, after in substitution_rules.items():
            value = value.replace(before, after)
        
        return value
```

### 13.2 数据流详细说明

#### 13.2.1 输入到输出完整数据流
```
用户输入
    ↓
输入验证 (chkTxtIsNumeric, chkAddControls)
    ↓
变量替换 (define.csv逻辑)
    ↓
计算执行 (calc.csv表达式计算)
    ↓
关系验证 (relation.csv条件判断)
    ↓
精度控制 (四舍五入处理)
    ↓
程序生成 (prg.csv模板应用)
    ↓
NC协议格式化 (makeSendTxt)
    ↓
命名管道传输
    ↓
NC机接收执行
```

#### 13.2.2 错误处理流程
```python
class ErrorHandlingFlow:
    def __init__(self):
        self.error_handler = ValidationErrorHandler()
        self.logger = logging.getLogger(__name__)
    
    def handle_data_loading_error(self, file_path: str, error: Exception):
        """处理数据加载错误"""
        self.logger.error(f"数据加载失败: {file_path}, 错误: {error}")
        
        # 尝试修复编码问题
        if isinstance(error, UnicodeDecodeError):
            fixed_data = self._fix_encoding_issue(file_path)
            if fixed_data is not None:
                return fixed_data
        
        # 记录错误并返回空数据
        self.error_handler.add_error("data_loading", f"文件加载失败: {file_path}")
        return pd.DataFrame()
    
    def handle_calculation_error(self, expression: str, error: Exception):
        """处理计算错误"""
        self.logger.error(f"计算错误: {expression}, 错误: {error}")
        
        # 记录计算错误
        self.error_handler.add_error("calculation", f"表达式计算失败: {expression}")
        
        # 返回默认值
        return 0.0
    
    def _fix_encoding_issue(self, file_path: str) -> Optional[pd.DataFrame]:
        """修复编码问题"""
        encodings_to_try = ['shift_jis', 'cp932', 'latin1', 'iso-8859-1']
        
        for encoding in encodings_to_try:
            try:
                return pd.read_csv(file_path, encoding=encoding)
            except UnicodeDecodeError:
                continue
        
        return None
```

### 13.3 性能优化数据处理

#### 13.3.1 缓存机制
```python
class DataCache:
    def __init__(self, max_size: int = 1000):
        self.cache = {}
        self.max_size = max_size
        self.access_count = {}
    
    def get(self, key: str) -> Optional[Any]:
        """获取缓存数据"""
        if key in self.cache:
            self.access_count[key] = self.access_count.get(key, 0) + 1
            return self.cache[key]
        return None
    
    def set(self, key: str, value: Any):
        """设置缓存数据"""
        if len(self.cache) >= self.max_size:
            self._evict_least_used()
        
        self.cache[key] = value
        self.access_count[key] = 1
    
    def _evict_least_used(self):
        """淘汰最少使用的缓存项"""
        if not self.access_count:
            return
        
        min_key = min(self.access_count.items(), key=lambda x: x[1])[0]
        del self.cache[min_key]
        del self.access_count[min_key]
```

#### 13.3.2 预编译优化
```python
class ExpressionPrecompiler:
    def __init__(self):
        self.compiled_expressions = {}
    
    def precompile_expression(self, expression: str) -> Callable:
        """预编译表达式"""
        if expression in self.compiled_expressions:
            return self.compiled_expressions[expression]
        
        try:
            # 安全编译表达式
            compiled = compile(expression, '<string>', 'eval')
            self.compiled_expressions[expression] = compiled
            return compiled
        except Exception as e:
            logger.warning(f"表达式预编译失败: {expression}, 错误: {e}")
            return None
```

## 14. 部署和配置

### 14.1 系统配置管理

#### 14.1.1 配置文件结构
```ini
[system]
data_directory = ./data/master
log_level = INFO
batch_size = 1000
max_cache_size = 1000
default_encoding = utf-8

[communication]
pipe_name = DNC_Pipe
protocol_type = rexroth
timeout_seconds = 30

[calculation]
decimal_places = 4
enable_precompilation = true
enable_caching = true

[ui]
window_width = 1024
window_height = 768
theme = default
```

#### 14.1.2 环境配置检查
```python
class EnvironmentChecker:
    def check_system_requirements(self) -> Dict[str, bool]:
        """检查系统要求"""
        requirements = {
            'python_version': self._check_python_version(),
            'pandas_installed': self._check_pandas(),
            'pyqt_installed': self._check_pyqt(),
            'data_directory_exists': self._check_data_directory(),
            'master_files_exist': self._check_master_files()
        }
        return requirements
    
    def _check_python_version(self) -> bool:
        """检查Python版本"""
        import sys
        return sys.version_info >= (3, 8)
    
    def _check_data_directory(self) -> bool:
        """检查数据目录"""
        return os.path.exists('./data/master')
```

## 15. 测试策略

### 15.1 基于VB.NET功能的测试用例

#### 15.1.1 控件系统测试
```python
class ControlSystemTests:
    def test_load_control_creation(self):
        """测试Load控件创建"""
        control_manager = ControlManager()
        load_control = control_manager.create_control("Load", "test_load", {})
        assert isinstance(load_control, LoadControl)
    
    def test_input_control_validation(self):
        """测试Input控件验证"""
        input_control = InputControl("test_input", "numeric", {})
        assert input_control.validate_input("123.45") == True
        assert input_control.validate_input
# DNC系统开发详细文档

## 1. 项目概述

### 1.1 系统简介
DNC（Direct Numerical Control）系统是一个数控设备参数管理软件，用于从电脑直接传送参数到NC机的宏变量系统。该系统解决了传统NC机手动输入参数的时间和错误问题。

### 1.2 系统架构 - 基于VB.NET源码分析
- **原系统**: VB.NET DNC2.05 (基于Frm_main.vb主窗体)
- **新系统**: Python重写版本 (基于VB.NET源码完整重构)
- **系统构成**: PC + NC机 + LAN线 + DNC软件 + 命名管道通信
- **数据格式**: CSV文件存储Master数据 + 动态控件系统
- **核心架构**: 8种控件系统 + 计算引擎 + 通信模块 + 数据处理

## 2. 系统功能模块

### 2.1 核心功能模块

#### 2.1.1 产品型号管理
- 产品类型定义 (type_define.csv)
- 程序类型映射 (type_prg.csv)
- 产品参数配置 (load.csv)

#### 2.1.2 参数计算引擎
- 几何参数计算 (calc.csv)
- 关系验证逻辑 (relation.csv)
- 变量定义管理 (define.csv)

#### 2.1.3 程序生成器
- 程序定义 (prg.csv)
- 控制参数 (cntrl_rex.csv)
- 选择逻辑 (select.csv)

### 2.2 数据流处理

#### 2.2.1 输入处理
```python
输入 → 参数验证 → 计算引擎 → 程序生成 → 输出
```

#### 2.2.2 宏变量映射
- #500-#600: 系统参数
- #1-#100: 用户参数
- 特殊变量: 计算中间值

## 3. 数据结构详细说明

### 3.1 核心数据文件

#### 3.1.1 type_define.csv (产品类型定义)
- **文件大小**: 988.60 KB
- **数据结构**:
  - NO: 序号
  - TYPE: 产品型号 (如: GPA18GT15040-A)
  - DEFINE1: 定义1
  - DEFINE2: 定义2

#### 3.1.2 type_prg.csv (程序类型映射)
- **文件大小**: 480.92 KB
- **数据结构**:
  - NO: 序号
  - prg1: 程序1编号
  - prg2: 程序2编号

#### 3.1.3 load.csv (主数据文件)
- **文件大小**: 8.5 MB
- **数据结构**:
  - NO: 序号
  - TYPE: 产品型号
  - DRAWING: 图纸文件
  - DISPFLG: 显示标志
  - #1-#12: 定义变量
  - #500-#550: 系统参数
  - #602-#603: 开关控制

#### 3.1.4 cntrl_rex.csv (参数控制)
- **文件大小**: 1.10 KB
- **数据结构**:
  - PARAMETER: 参数名称 (如: Work_plan, Teeth_num)
  - DATATYPE: 数据类型 (int, real, boolean)
  - MACRO: 宏变量映射 (如: #510, #511)

### 3.2 计算逻辑文件

#### 3.2.1 calc.csv (计算定义)
```csv
DEFINE,1,2,3,4,5,6,7,8,9,10,11,12,13
calcABC,=,#528,-,#510,*,2,NaN,NaN,NaN,NaN,NaN,NaN,NaN
calcABCD,=,(,#528,-,#513,),/,2.0,NaN,NaN,NaN,NaN,NaN
```

#### 3.2.2 relation.csv (关系验证)
```csv
DEFINE,VALUE,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28
relationHPN,#1,and,#1,>,0.0,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN
```

#### 3.2.3 define.csv (变量定义)
```csv
DEFINE,STR,BEFORE,AFTER,CHNGVL,CALC
defineP,P,P0,0,NaN,NaN
defineH,H,H0,0,NaN,NaN
```

## 4. 技术架构设计

### 4.1 系统架构图

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   用户界面层     │    │   业务逻辑层     │    │   数据访问层     │
│                 │    │                 │    │                 │
│  - 主窗口       │◄──►│  - 参数计算     │◄──►│  - CSV处理器    │
│  - 输入表单     │    │  - 程序生成     │    │  - 数据验证     │
│  - 结果显示     │    │  - 关系验证     │    │  - 编码处理     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 4.2 核心类设计

#### 4.2.1 DataManager (数据管理器)
```python
class DataManager:
    def load_master_data(self) -> Dict[str, pd.DataFrame]
    def batch_read_large_csv(self, file_path: str, batch_size: int = 1000)
    def validate_data_integrity(self) -> bool
    def fix_encoding_issues(self, file_path: str) -> pd.DataFrame
```

#### 4.2.2 CalculationEngine (计算引擎)
```python
class CalculationEngine:
    def calculate_parameters(self, input_data: Dict) -> Dict
    def validate_relations(self, calculated_data: Dict) -> bool
    def generate_macro_variables(self, params: Dict) -> List[str]
```

#### 4.2.3 ProgramGenerator (程序生成器)
```python
class ProgramGenerator:
    def generate_nc_program(self, product_type: str, params: Dict) -> str
    def apply_program_template(self, template: str, variables: Dict) -> str
    def validate_program_syntax(self, program: str) -> bool
```

## 5. 数据处理流程

### 5.1 数据加载流程
1. **扫描目录**: 递归扫描master目录下的所有CSV文件
2. **分类处理**: 根据文件大小分类为小文件和大文件
3. **编码检测**: 自动检测文件编码 (UTF-8, Shift-JIS, CP932)
4. **分批读取**: 大文件使用分批读取机制
5. **数据验证**: 检查数据完整性和一致性

### 5.2 参数计算流程
1. **输入验证**: 验证用户输入参数的有效性
2. **变量替换**: 根据define.csv进行变量替换
3. **计算执行**: 执行calc.csv中定义的计算逻辑
4. **关系验证**: 验证relation.csv中定义的关系条件
5. **结果生成**: 生成最终的宏变量值

## 6. 文件编码处理

### 6.1 编码问题文件列表
- `ini.csv`: 958字节，编码问题
- `math.csv`: 1.08KB，编码问题  
- `cntrl.csv`: 1.38KB，编码问题
- `switch.csv`: 106字节，编码问题

### 6.2 编码处理策略
```python
def detect_encoding(file_path: str) -> str:
    encodings = ['utf-8', 'shift_jis', 'cp932', 'latin1']
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as f:
                f.read()
            return encoding
        except UnicodeDecodeError:
            continue
    return 'unknown'
```

## 7. 性能优化策略

### 7.1 大文件处理优化
- **分批读取**: 使用pandas的chunksize参数
- **内存管理**: 及时释放不需要的数据
- **缓存机制**: 缓存频繁访问的数据

### 7.2 计算优化
- **预编译**: 预编译计算表达式
- **并行处理**: 使用多线程处理独立计算
- **结果缓存**: 缓存重复计算结果

## 8. 错误处理机制

### 8.1 数据验证错误
- 文件不存在错误
- 编码错误处理
- 数据格式错误
- 完整性检查失败

### 8.2 计算错误
- 除零错误处理
- 变量未定义错误
- 关系验证失败
- 程序生成错误

## 9. 部署和配置

### 9.1 环境要求
- Python 3.8+
- pandas >= 1.3.0
- PyQt5/PySide6
- 操作系统: Windows 10/11

### 9.2 配置文件
```ini
[system]
data_directory = ./data/master
log_level = INFO
batch_size = 1000

[encoding]
default_encoding = utf-8
fallback_encodings = shift_jis,cp932,latin1
```

## 10. 测试策略

### 10.1 单元测试
- 数据加载测试
- 计算逻辑测试
- 程序生成测试
- 错误处理测试

### 10.2 集成测试
- 端到端流程测试
- 性能测试
- 兼容性测试

## 11. 功能模块详细设计

### 11.1 控件系统详细设计

#### 11.1.1 8种核心控件类型实现

**Load控件 (makeCntrlLoad)**
```python
class LoadControl:
    def __init__(self, data_source: str, field_mapping: Dict):
        self.data_source = data_source
        self.field_mapping = field_mapping
        self.data_table = None
    
    def load_data(self) -> pd.DataFrame:
        """从CSV文件加载数据"""
        try:
            self.data_table = pd.read_csv(self.data_source, encoding='utf-8')
            return self.data_table
        except Exception as e:
            logger.error(f"加载数据失败: {e}")
            return None
    
    def validate_data(self) -> bool:
        """验证数据完整性"""
        required_fields = ['NO', 'TYPE', 'DRAWING']
        return all(field in self.data_table.columns for field in required_fields)
```

**Input控件 (makeCntrlInput)**
```python
class InputControl:
    def __init__(self, control_id: str, data_type: str, validation_rules: Dict):
        self.control_id = control_id
        self.data_type = data_type
        self.validation_rules = validation_rules
        self.value = None
    
    def handle_text_change(self, new_value: str):
        """处理文本变更事件"""
        if self.validate_input(new_value):
            self.value = self.convert_value(new_value)
            self.trigger_calculation()
    
    def validate_input(self, value: str) -> bool:
        """验证输入值"""
        if self.data_type == 'numeric':
            return self._validate_numeric(value)
        elif self.data_type == 'string':
            return self._validate_string(value)
        return False
```

#### 11.1.2 基础控件创建方法Python实现

**文本框创建 (makeTextBox)**
```python
def create_text_box(name: str, location: Tuple[int, int], size: Tuple[int, int], 
                   text_change_handler: Callable) -> QLineEdit:
    """创建文本框控件"""
    text_box = QLineEdit()
    text_box.setObjectName(name)
    text_box.setGeometry(location[0], location[1], size[0], size[1])
    text_box.textChanged.connect(text_change_handler)
    return text_box
```

**标签创建 (makeLabel)**
```python
def create_label(name: str, text: str, location: Tuple[int, int], 
                size: Tuple[int, int]) -> QLabel:
    """创建标签控件"""
    label = QLabel(text)
    label.setObjectName(name)
    label.setGeometry(location[0], location[1], size[0], size[1])
    return label
```

#### 11.1.3 动态控件管理技术细节

**控件生命周期管理**
```python
class ControlManager:
    def __init__(self):
        self.controls = {}
        self.control_groups = {}
    
    def add_control(self, control_id: str, control: QWidget):
        """添加控件到管理器"""
        self.controls[control_id] = control
    
    def remove_control(self, control_id: str):
        """移除控件"""
        if control_id in self.controls:
            self.controls[control_id].deleteLater()
            del self.controls[control_id]
    
    def enable_controls(self, control_ids: List[str], enabled: bool):
        """批量启用/禁用控件"""
        for control_id in control_ids:
            if control_id in self.controls:
                self.controls[control_id].setEnabled(enabled)
```

### 11.2 计算引擎详细设计

#### 11.2.1 表达式计算具体算法

**表达式解析器 (getCalcResult)**
```python
class ExpressionCalculator:
    def __init__(self):
        self.variables = {}
        self.functions = {
            'MAX': max,
            'MIN': min,
            'ROUND': round,
            'ABS': abs
        }
    
    def calculate(self, expression: str, variables: Dict) -> float:
        """计算表达式值"""
        try:
            # 变量替换
            expr = self._replace_variables(expression, variables)
            # 表达式求值
            result = eval(expr, {"__builtins__": None}, self.functions)
            return float(result)
        except Exception as e:
            logger.error(f"表达式计算错误: {expression}, 错误: {e}")
            return 0.0
    
    def _replace_variables(self, expression: str, variables: Dict) -> str:
        """替换表达式中的变量"""
        for var_name, var_value in variables.items():
            expression = expression.replace(f"@{var_name}", str(var_value))
        return expression
```

#### 11.2.2 条件判断系统实现逻辑

**关系判断引擎 (judgeRelation)**
```python
class RelationJudge:
    def judge(self, condition: str, left_value: Any, right_value: Any) -> bool:
        """判断关系条件"""
        operators = {
            '=': lambda x, y: x == y,
            '<>': lambda x, y: x != y,
            '>': lambda x, y: x > y,
            '<': lambda x, y: x < y,
            '>=': lambda x, y: x >= y,
            '<=': lambda x, y: x <= y
        }
        
        for op, func in operators.items():
            if op in condition:
                return func(left_value, right_value)
        
        return False
```

#### 11.2.3 精度控制技术方案

**数值精度管理**
```python
class PrecisionController:
    def __init__(self, decimal_places: int = 4):
        self.decimal_places = decimal_places
    
    def round_value(self, value: float) -> float:
        """四舍五入处理"""
        return round(value, self.decimal_places)
    
    def format_display(self, value: float) -> str:
        """格式化显示值"""
        return f"{value:.{self.decimal_places}f}".rstrip('0').rstrip('.')
```

### 11.3 数据处理模块详细设计

#### 11.3.1 文件加载系统实现细节

**CSV文件加载器 (LoadFileToTBL)**
```python
class CSVLoader:
    def __init__(self, encoding_detector: EncodingDetector):
        self.encoding_detector = encoding_detector
    
    def load_file(self, file_path: str) -> pd.DataFrame:
        """加载CSV文件"""
        encoding = self.encoding_detector.detect_encoding(file_path)
        
        try:
            df = pd.read_csv(file_path, encoding=encoding)
            return self._clean_data(df)
        except Exception as e:
            logger.error(f"文件加载失败: {file_path}, 错误: {e}")
            return pd.DataFrame()
    
    def _clean_data(self, df: pd.DataFrame) -> pd.DataFrame:
        """数据清理"""
        # 移除空行
        df = df.dropna(how='all')
        # 处理NaN值
        df = df.fillna('')
        return df
```

#### 11.3.2 数据搜索功能算法设计

**表搜索引擎 (searchT_relation)**
```python
class TableSearcher:
    def __init__(self, data_tables: Dict[str, pd.DataFrame]):
        self.data_tables = data_tables
        self.search_cache = {}
    
    def search_table(self, table_name: str, search_criteria: Dict) -> pd.DataFrame:
        """搜索数据表"""
        cache_key = f"{table_name}_{str(search_criteria)}"
        if cache_key in self.search_cache:
            return self.search_cache[cache_key]
        
        if table_name not in self.data_tables:
            return pd.DataFrame()
        
        table = self.data_tables[table_name]
        result = table.copy()
        
        for column, value in search_criteria.items():
            if column in table.columns:
                result = result[result[column] == value]
        
        self.search_cache[cache_key] = result
        return result
```

#### 11.3.3 数据操作技术实现

**数据转换器 (searchT_ChngValue)**
```python
class DataConverter:
    def __init__(self, conversion_rules: Dict):
        self.conversion_rules = conversion_rules
    
    def convert_value(self, value: Any, conversion_type: str) -> Any:
        """转换数据值"""
        if conversion_type in self.conversion_rules:
            rule = self.conversion_rules[conversion_type]
            return rule(value)
        return value
    
    def add_conversion_rule(self, conversion_type: str, rule: Callable):
        """添加转换规则"""
        self.conversion_rules[conversion_type] = rule
```

### 11.4 通信模块详细设计

#### 11.4.1 通信协议支持技术实现

**NC通信协议处理器 (makeSendTxt)**
```python
class NCProtocolHandler:
    def __init__(self, protocol_type: str):
        self.protocol_type = protocol_type
        self.message_formatters = {
            'rexroth': self._format_rexroth_message,
            'brother': self._format_brother_message
        }
    
    def format_message(self, command: str, parameters: Dict) -> str:
        """格式化NC命令消息"""
        if self.protocol_type in self.message_formatters:
            return self.message_formatters[self.protocol_type](command, parameters)
        return command
    
    def _format_rexroth_message(self, command: str, parameters: Dict) -> str:
        """格式化Rexroth协议消息"""
        # Rexroth协议特定格式化逻辑
        return f"{command} {self._format_parameters(parameters)}"
    
    def _format_brother_message(self, command: str, parameters: Dict) -> str:
        """格式化Brother协议消息"""
        # Brother协议特定格式化逻辑
        return f"{command};{self._format_parameters(parameters)}"
```

#### 11.4.2 进程间通信机制设计

**连接状态管理器 (ConnectionChange)**
```python
class ConnectionManager:
    def __init__(self):
        self.connections = {}
        self.connection_callbacks = []
    
    def add_connection(self, connection_id: str, connection: object):
        """添加连接"""
        self.connections[connection_id] = connection
        self._notify_connection_change(connection_id, 'connected')
    
    def remove_connection(self, connection_id: str):
        """移除连接"""
        if connection_id in self.connections:
            del self.connections[connection_id]
            self._notify_connection_change(connection_id, 'disconnected')
    
    def _notify_connection_change(self, connection_id: str, status: str):
        """通知连接状态变更"""
        for callback in self.connection_callbacks:
            callback(connection_id, status)
```

#### 11.4.3 命名管道通信具体实现

**异步命名管道客户端 (NamedPipeAsyncClient)**
```python
class NamedPipeClient:
    def __init__(self, pipe_name: str):
        self.pipe_name = pipe_name
        self.connected = False
        self.data_received_callbacks = []
    
    async def connect(self):
        """异步连接命名管道"""
        try:
            # Windows命名管道连接实现
            self.connected = True
            await self._start_listening()
        except Exception as e:
            logger.error(f"命名管道连接失败: {e}")
            self.connected = False
    
    async def send_data(self, data: str):
        """异步发送数据"""
        if self.connected:
            # 实现数据发送逻辑
            pass
    
    def add_data_received_callback(self, callback: Callable):
        """添加数据接收回调"""
        self.data_received_callbacks.append(callback)
```

### 11.5 用户界面交互详细设计

#### 11.5.1 事件处理系统架构设计

**事件分发器**
```python
class EventDispatcher:
    def __init__(self):
        self.event_handlers = {}
    
    def register_handler(self, event_type: str, handler: Callable):
        """注册事件处理器"""
        if event_type not in self.event_handlers:
            self.event_handlers[event_type] = []
        self.event_handlers[event_type].append(handler)
    
    def dispatch_event(self, event_type: str, event_data: Dict):
        """分发事件"""
        if event_type in self.event_handlers:
            for handler in self.event_handlers[event_type]:
                try:
                    handler(event_data)
                except Exception as e:
                    logger.error(f"事件处理错误: {e}")
```

#### 11.5.2 输入处理技术实现

**文本变更处理器 (txt_change)**
```python
class TextChangeHandler:
    def __init__(self, validation_rules: Dict, calculation_trigger: Callable):
        self.validation_rules = validation_rules
        self.calculation_trigger = calculation_trigger
        self.change_event_flag = False
    
    def handle_text_change(self, control_id: str, new_text: str):
        """处理文本变更"""
        if self.change_event_flag:
            return
        
        self.change_event_flag = True
        
        try:
            # 数据验证
            if self._validate_text(control_id, new_text):
                # 触发计算
                self.calculation_trigger(control_id, new_text)
        finally:
            self.change_event_flag = False
    
    def _validate_text(self, control_id: str, text: str) -> bool:
        """验证文本内容"""
        if control_id in self.validation_rules:
            rule = self.validation_rules[control_id]
            return rule(text)
        return True
```

#### 11.5.3 操作员管理功能设计

**操作员管理器 (TB_OpeID_TextChanged)**
```python
class OperatorManager:
    def __init__(self):
        self.current_operator = None
        self.operator_database = {}
    
    def set_operator(self, operator_id: str):
        """设置当前操作员"""
        if operator_id in self.operator_database:
            self.current_operator = self.operator_database[operator_id]
            logger.info(f"操作员已切换: {self.current_operator.name}")
        else:
            logger.warning(f"未知操作员ID: {operator_id}")
    
    def get_operator_name(self, operator_id: str) -> str:
        """获取操作员名称"""
        if operator_id in self.operator_database:
            return self.operator_database[operator_id].name
        return "未知操作员"
```

### 11.6 数据验证模块详细设计

#### 11.6.1 验证方法具体实现

**数值验证器 (chkTxtIsNumeric)**
```python
class NumericValidator:
    def validate(self, text: str, min_value: float = None, 
                max_value: float = None, decimal_places: int = None) -> bool:
        """验证数值文本"""
        try:
            value = float(text)
            
            if min_value is not None and value < min_value:
                return False
            
            if max_value is not None and value > max_value:
                return False
            
            if decimal_places is not None:
                # 检查小数位数
                decimal_part = str(value).split('.')
                if len(decimal_part) > 1 and len(decimal_part[1]) > decimal_places:
                    return False
            
            return True
        except ValueError:
            return False
```

#### 11.6.2 验证规则技术设计

**业务规则验证器 (chkAddControls)**
```python
class BusinessRuleValidator:
    def __init__(self, validation_rules: Dict):
        self.validation_rules = validation_rules
    
    def validate_controls(self, control_values: Dict) -> Dict[str, str]:
        """验证控件组业务规则"""
        errors = {}
        
        for rule_name, rule in self.validation_rules.items():
            if not rule(control_values):
                errors[rule_name] = f"业务规则验证失败: {rule_name}"
        
        return errors
    
    def add_validation_rule(self, rule_name: str, rule: Callable):
        """添加验证规则"""
        self.validation_rules[rule_name] = rule
```

#### 11.6.3 错误处理机制

**验证错误处理器**
```python
class ValidationErrorHandler:
    def __init__(self):
        self.error_messages = {}
    
    def add_error(self, control_id: str, message: str):
        """添加错误信息"""
        if control_id not in self.error_messages:
            self.error_messages[control_id] = []
        self.error_messages[control_id].append(message)
    
    def clear_errors(self, control_id: str = None):
        """清除错误信息"""
        if control_id:
            if control_id in self.error_messages:
                del self.error_messages[control_id]
        else:
            self.error_messages.clear()
    
    def has_errors(self) -> bool:
        """检查是否有错误"""
        return len(self.error_messages) > 0
```

### 11.7 系统管理模块详细设计

#### 11.7.1 初始化系统技术实现

**系统初始化器 (Frm_main_Load)**
```python
class SystemInitializer:
    def __init__(self, config_manager: ConfigManager, data_manager: DataManager):
        self.config_manager = config_manager
        self.data_manager = data_manager
        self.initialization_steps = [
            self._load_configuration,
            self._load_master_data,
            self._initialize_ui,
            self._setup_communication
        ]
    
    async def initialize_system(self):
        """异步初始化系统"""
        for step in self.initialization_steps:
            try:
                await step()
            except Exception as e:
                logger.error(f"初始化步骤失败: {e}")
                raise
    
    async def _load_configuration(self):
        """加载系统配置"""
        self.config = await self.config_manager.load_config()
    
    async def _load_master_data(self):
        """加载Master数据"""
        self.master_data = await self.data_manager.load_master_data()
    
    async def _initialize_ui(self):
        """初始化用户界面"""
        # 创建主窗口和控件
        pass
    
    async def _setup_communication(self):
        """设置通信连接"""
        # 初始化NC通信和命名管道
        pass
```

#### 11.7.2 显示管理功能设计

**控件状态管理器 (ControlStateManager)**
```python
class ControlStateManager:
    def __init__(self):
        self.control_states = {}
        self.control_groups = {}
    
    def set_controls_enabled(self, control_ids: List[str], enabled: bool):
        """设置控件启用状态"""
        for control_id in control_ids:
            if control_id in self.control_states:
                self.control_states[control_id].setEnabled(enabled)
    
    def set_controls_visible(self, control_ids: List[str], visible: bool):
        """设置控件可见性"""
        for control_id in control_ids:
            if control_id in self.control_states:
                self.control_states[control_id].setVisible(visible)
    
    def add_control_group(self, group_name: str, control_ids: List[str]):
        """添加控件组"""
        self.control_groups[group_name] = control_ids
    
    def set_group_enabled(self, group_name: str, enabled: bool):
        """设置控件组启用状态"""
        if group_name in self.control_groups:
            self.set_controls_enabled(self.control_groups[group_name], enabled)
```

#### 11.7.3 配置管理技术方案

**INI配置管理器 (IniConfigManager)**
```python
class IniConfigManager:
    def __init__(self, ini_file_path: str):
        self.ini_file_path = ini_file_path
        self.config = {}
    
    def load_config(self) -> Dict:
        """加载INI配置文件"""
        config = configparser.ConfigParser()
        config.read(self.ini_file_path, encoding='utf-8')
        
        for section in config.sections():
            self.config[section] = dict(config.items(section))
        
        return self.config
    
    def save_config(self, config: Dict):
        """保存INI配置文件"""
        config_parser = configparser.ConfigParser()
        
        for section, options in config.items():
            config_parser[section] = options
        
        with open(self.ini_file_path, 'w', encoding='utf-8') as f:
            config_parser.write(f)
    
    def get_value(self, section: str, key: str, default=None):
        """获取配置值"""
        return self.config.get(section, {}).get(key, default)
```

### 11.8 工具方法详细设计

#### 11.8.1 字符串处理技术实现

**字符串工具类 (StringUtils)**
```python
class StringUtils:
    @staticmethod
    def len_b(text: str) -> int:
        """计算字符串字节长度（兼容VB.NET的LenB函数）"""
        return len(text.encode('utf-8'))
    
    @staticmethod
    def make_format_str(format_pattern: str, *args) -> str:
        """创建格式化字符串"""
        try:
            return format_pattern.format(*args)
        except Exception as e:
            logger.error(f"字符串格式化失败: {e}")
            return format_pattern
    
    @staticmethod
    def to_half_adjust(value: float, decimal_places: int = 0) -> float:
        """四舍五入处理（兼容VB.NET的ToHalfAdjust）"""
        factor = 10 ** decimal_places
        return round(value * factor) / factor
    
    @staticmethod
    def get_operator_name(operator_id: str) -> str:
        """获取操作员名称"""
        operator_map = {
            '001': '操作员A',
            '002': '操作员B',
            '003': '操作员C'
        }
        return operator_map.get(operator_id, '未知操作员')
```

#### 11.8.2 系统工具功能设计

**系统工具类 (SystemUtils)**
```python
class SystemUtils:
    @staticmethod
    def get_all_controls(parent_widget: QWidget) -> List[QWidget]:
        """获取所有子控件"""
        controls = []
        
        def collect_controls(widget):
            for child in widget.children():
                if isinstance(child, QWidget):
                    controls.append(child)
                    collect_controls(child)
        
        collect_controls(parent_widget)
        return controls
    
    @staticmethod
    def change_form_size(form: QWidget, width: int, height: int):
        """改变窗体大小"""
        form.resize(width, height)
    
    @staticmethod
    def show_info_form(title: str, message: str):
        """显示信息窗体"""
        msg_box = QMessageBox()
        msg_box.setWindowTitle(title)
        msg_box.setText(message)
        msg_box.setIcon(QMessageBox.Information)
        msg_box.exec_()
```

#### 11.8.3 数值处理工具

**公差计算器 (ToleranceCalculator)**
```python
class ToleranceCalculator:
    @staticmethod
    def get_shafts_tolerance(diameter: float, tolerance_class: str) -> Tuple[float, float]:
        """获取轴公差"""
        tolerance_tables = {
            'h6': {10: (-0.009, 0), 18: (-0.011, 0), 30: (-0.013, 0)},
            'h7': {10: (-0.015, 0), 18: (-0.018, 0), 30: (-0.021, 0)},
            'h8': {10: (-0.022, 0), 18: (-0.027, 0), 30: (-0.033, 0)}
        }
        
        for max_diameter, tolerance in tolerance_tables.get(tolerance_class, {}).items():
            if diameter <= max_diameter:
                return tolerance
        
        return (0, 0)
    
    @staticmethod
    def get_length_tolerance(length: float, tolerance_class: str) -> Tuple[float, float]:
        """获取长度公差"""
        tolerance_tables = {
            'fine': {100: (-0.1, 0.1), 400: (-0.2, 0.2), 1000: (-0.3, 0.3)},
            'medium': {100: (-0.2, 0.2), 400: (-0.4, 0.4), 1000: (-0.6, 0.6)},
            'coarse': {100: (-0.4, 0.4), 400: (-0.8, 0.8), 1000: (-1.2, 1.2)}
        }
        
        for max_length, tolerance in tolerance_tables.get(tolerance_class, {}).items():
            if length <= max_length:
                return tolerance
        
        return (0, 0)
```

## 12. 技术架构设计

### 12.1 核心类设计
# DNC系统开发详细文档

## 1. 项目概述

### 1.1 系统简介
DNC（Direct Numerical Control）系统是一个数控设备参数管理软件，用于从电脑直接传送参数到NC机的宏变量系统。该系统解决了传统NC机手动输入参数的时间和错误问题。

### 1.2 系统架构 - 基于VB.NET源码分析
- **原系统**: VB.NET DNC2.05 (基于Frm_main.vb主窗体)
- **新系统**: Python重写版本 (基于VB.NET源码完整重构)
- **系统构成**: PC + NC机 + LAN线 + DNC软件 + 命名管道通信
- **数据格式**: CSV文件存储Master数据 + 动态控件系统
- **核心架构**: 8种控件系统 + 计算引擎 + 通信模块 + 数据处理

## 2. 系统功能模块

### 2.1 核心功能模块

#### 2.1.1 产品型号管理
- 产品类型定义 (type_define.csv)
- 程序类型映射 (type_prg.csv)
- 产品参数配置 (load.csv)

#### 2.1.2 参数计算引擎
- 几何参数计算 (calc.csv)
- 关系验证逻辑 (relation.csv)
- 变量定义管理 (define.csv)

#### 2.1.3 程序生成器
- 程序定义 (prg.csv)
- 控制参数 (cntrl_rex.csv)
- 选择逻辑 (select.csv)

### 2.2 数据流处理

#### 2.2.1 输入处理
```python
输入 → 参数验证 → 计算引擎 → 程序生成 → 输出
```

#### 2.2.2 宏变量映射
- #500-#600: 系统参数
- #1-#100: 用户参数
- 特殊变量: 计算中间值

## 3. 数据结构详细说明

### 3.1 核心数据文件

#### 3.1.1 type_define.csv (产品类型定义)
- **文件大小**: 988.60 KB
- **数据结构**:
  - NO: 序号
  - TYPE: 产品型号 (如: GPA18GT15040-A)
  - DEFINE1: 定义1
  - DEFINE2: 定义2

#### 3.1.2 type_prg.csv (程序类型映射)
- **文件大小**: 480.92 KB
- **数据结构**:
  - NO: 序号
  - prg1: 程序1编号
  - prg2: 程序2编号

#### 3.1.3 load.csv (主数据文件)
- **文件大小**: 8.5 MB
- **数据结构**:
  - NO: 序号
  - TYPE: 产品型号
  - DRAWING: 图纸文件
  - DISPFLG: 显示标志
  - #1-#12: 定义变量
  - #500-#550: 系统参数
  - #602-#603: 开关控制

#### 3.1.4 cntrl_rex.csv (参数控制)
- **文件大小**: 1.10 KB
- **数据结构**:
  - PARAMETER: 参数名称 (如: Work_plan, Teeth_num)
  - DATATYPE: 数据类型 (int, real, boolean)
  - MACRO: 宏变量映射 (如: #510, #511)

### 3.2 计算逻辑文件

#### 3.2.1 calc.csv (计算定义)
```csv
DEFINE,1,2,3,4,5,6,7,8,9,10,11,12,13
calcABC,=,#528,-,#510,*,2,NaN,NaN,NaN,NaN,NaN,NaN,NaN
calcABCD,=,(,#528,-,#513,),/,2.0,NaN,NaN,NaN,NaN,NaN
```

#### 3.2.2 relation.csv (关系验证)
```csv
DEFINE,VALUE,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28
relationHPN,#1,and,#1,>,0.0,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN
```

#### 3.2.3 define.csv (变量定义)
```csv
DEFINE,STR,BEFORE,AFTER,CHNGVL,CALC
defineP,P,P0,0,NaN,NaN
defineH,H,H0,0,NaN,NaN
```

## 4. 技术架构设计

### 4.1 系统架构图

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   用户界面层     │    │   业务逻辑层     │    │   数据访问层     │
│                 │    │                 │    │                 │
│  - 主窗口       │◄──►│  - 参数计算     │◄──►│  - CSV处理器    │
│  - 输入表单     │    │  - 程序生成     │    │  - 数据验证     │
│  - 结果显示     │    │  - 关系验证     │    │  - 编码处理     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 4.2 核心类设计

#### 4.2.1 DataManager (数据管理器)
```python
class DataManager:
    def load_master_data(self) -> Dict[str, pd.DataFrame]
    def batch_read_large_csv(self, file_path: str, batch_size: int = 1000)
    def validate_data_integrity(self) -> bool
    def fix_encoding_issues(self, file_path: str) -> pd.DataFrame
```

#### 4.2.2 CalculationEngine (计算引擎)
```python
class CalculationEngine:
    def calculate_parameters(self, input_data: Dict) -> Dict
    def validate_relations(self, calculated_data: Dict) -> bool
    def generate_macro_variables(self, params: Dict) -> List[str]
```

#### 4.2.3 ProgramGenerator (程序生成器)
```python
class ProgramGenerator:
    def generate_nc_program(self, product_type: str, params: Dict) -> str
    def apply_program_template(self, template: str, variables: Dict) -> str
    def validate_program_syntax(self, program: str) -> bool
```

## 5. 数据处理流程

### 5.1 数据加载流程
1. **扫描目录**: 递归扫描master目录下的所有CSV文件
2. **分类处理**: 根据文件大小分类为小文件和大文件
3. **编码检测**: 自动检测文件编码 (UTF-8, Shift-JIS, CP932)
4. **分批读取**: 大文件使用分批读取机制
5. **数据验证**: 检查数据完整性和一致性

### 5.2 参数计算流程
1. **输入验证**: 验证用户输入参数的有效性
2. **变量替换**: 根据define.csv进行变量替换
3. **计算执行**: 执行calc.csv中定义的计算逻辑
4. **关系验证**: 验证relation.csv中定义的关系条件
5. **结果生成**: 生成最终的宏变量值

## 6. 文件编码处理

### 6.1 编码问题文件列表
- `ini.csv`: 958字节，编码问题
- `math.csv`: 1.08KB，编码问题  
- `cntrl.csv`: 1.38KB，编码问题
- `switch.csv`: 106字节，编码问题

### 6.2 编码处理策略
```python
def detect_encoding(file_path: str) -> str:
    encodings = ['utf-8', 'shift_jis', 'cp932', 'latin1']
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as f:
                f.read()
            return encoding
        except UnicodeDecodeError:
            continue
    return 'unknown'
```

## 7. 性能优化策略

### 7.1 大文件处理优化
- **分批读取**: 使用pandas的chunksize参数
- **内存管理**: 及时释放不需要的数据
- **缓存机制**: 缓存频繁访问的数据

### 7.2 计算优化
- **预编译**: 预编译计算表达式
- **并行处理**: 使用多线程处理独立计算
- **结果缓存**: 缓存重复计算结果

## 8. 错误处理机制

### 8.1 数据验证错误
- 文件不存在错误
- 编码错误处理
- 数据格式错误
- 完整性检查失败

### 8.2 计算错误
- 除零错误处理
- 变量未定义错误
- 关系验证失败
- 程序生成错误

## 9. 部署和配置

### 9.1 环境要求
- Python 3.8+
- pandas >= 1.3.0
- PyQt5/PySide6
- 操作系统: Windows 10/11

### 9.2 配置文件
```ini
[system]
data_directory = ./data/master
log_level = INFO
batch_size = 1000

[encoding]
default_encoding = utf-8
fallback_encodings = shift_jis,cp932,latin1
```

## 10. 测试策略

### 10.1 单元测试
- 数据加载测试
- 计算逻辑测试
- 程序生成测试
- 错误处理测试

### 10.2 集成测试
- 端到端流程测试
- 性能测试
- 兼容性测试

## 11. 功能模块详细设计

### 11.1 控件系统详细设计

#### 11.1.1 8种核心控件类型实现

**Load控件 (makeCntrlLoad)**
```python
class LoadControl:
    def __init__(self, data_source: str, field_mapping: Dict):
        self.data_source = data_source
        self.field_mapping = field_mapping
        self.data_table = None
    
    def load_data(self) -> pd.DataFrame:
        """从CSV文件加载数据"""
        try:
            self.data_table = pd.read_csv(self.data_source, encoding='utf-8')
            return self.data_table
        except Exception as e:
            logger.error(f"加载数据失败: {e}")
            return None
    
    def validate_data(self) -> bool:
        """验证数据完整性"""
        required_fields = ['NO', 'TYPE', 'DRAWING']
        return all(field in self.data_table.columns for field in required_fields)
```

**Input控件 (makeCntrlInput)**
```python
class InputControl:
    def __init__(self, control_id: str, data_type: str, validation_rules: Dict):
        self.control_id = control_id
        self.data_type = data_type
        self.validation_rules = validation_rules
        self.value = None
    
    def handle_text_change(self, new_value: str):
        """处理文本变更事件"""
        if self.validate_input(new_value):
            self.value = self.convert_value(new_value)
            self.trigger_calculation()
    
    def validate_input(self, value: str) -> bool:
        """验证输入值"""
        if self.data_type == 'numeric':
            return self._validate_numeric(value)
        elif self.data_type == 'string':
            return self._validate_string(value)
        return False
```

#### 11.1.2 基础控件创建方法Python实现

**文本框创建 (makeTextBox)**
```python
def create_text_box(name: str, location: Tuple[int, int], size: Tuple[int, int], 
                   text_change_handler: Callable) -> QLineEdit:
    """创建文本框控件"""
    text_box = QLineEdit()
    text_box.setObjectName(name)
    text_box.setGeometry(location[0], location[1], size[0], size[1])
    text_box.textChanged.connect(text_change_handler)
    return text_box
```

**标签创建 (makeLabel)**
```python
def create_label(name: str, text: str, location: Tuple[int, int], 
                size: Tuple[int, int]) -> QLabel:
    """创建标签控件"""
    label = QLabel(text)
    label.setObjectName(name)
    label.setGeometry(location[0], location[1], size[0], size[1])
    return label
```

#### 11.1.3 动态控件管理技术细节

**控件生命周期管理**
```python
class ControlManager:
    def __init__(self):
        self.controls = {}
        self.control_groups = {}
    
    def add_control(self, control_id: str, control: QWidget):
        """添加控件到管理器"""
        self.controls[control_id] = control
    
    def remove_control(self, control_id: str):
        """移除控件"""
        if control_id in self.controls:
            self.controls[control_id].deleteLater()
            del self.controls[control_id]
    
    def enable_controls(self, control_ids: List[str], enabled: bool):
        """批量启用/禁用控件"""
        for control_id in control_ids:
            if control_id in self.controls:
                self.controls[control_id].setEnabled(enabled)
```

### 11.2 计算引擎详细设计

#### 11.2.1 表达式计算具体算法

**表达式解析器 (getCalcResult)**
```python
class ExpressionCalculator:
    def __init__(self):
        self.variables = {}
        self.functions = {
            'MAX': max,
            'MIN': min,
            'ROUND': round,
            'ABS': abs
        }
    
    def calculate(self, expression: str, variables: Dict) -> float:
        """计算表达式值"""
        try:
            # 变量替换
            expr = self._replace_variables(expression, variables)
            # 表达式求值
            result = eval(expr, {"__builtins__": None}, self.functions)
            return float(result)
        except Exception as e:
            logger.error(f"表达式计算错误: {expression}, 错误: {e}")
            return 0.0
    
    def _replace_variables(self, expression: str, variables: Dict) -> str:
        """替换表达式中的变量"""
        for var_name, var_value in variables.items():
            expression = expression.replace(f"@{var_name}", str(var_value))
        return expression
```

#### 11.2.2 条件判断系统实现逻辑

**关系判断引擎 (judgeRelation)**
```python
class RelationJudge:
    def judge(self, condition: str, left_value: Any, right_value: Any) -> bool:
        """判断关系条件"""
        operators = {
            '=': lambda x, y: x == y,
            '<>': lambda x, y: x != y,
            '>': lambda x, y: x > y,
            '<': lambda x, y: x < y,
            '>=': lambda x, y: x >= y,
            '<=': lambda x, y: x <= y
        }
        
        for op, func in operators.items():
            if op in condition:
                return func(left_value, right_value)
        
        return False
```

#### 11.2.3 精度控制技术方案

**数值精度管理**
```python
class PrecisionController:
    def __init__(self, decimal_places: int = 4):
        self.decimal_places = decimal_places
    
    def round_value(self, value: float) -> float:
        """四舍五入处理"""
        return round(value, self.decimal_places)
    
    def format_display(self, value: float) -> str:
        """格式化显示值"""
        return f"{value:.{self.decimal_places}f}".rstrip('0').rstrip('.')
```

### 11.3 数据处理模块详细设计

#### 11.3.1 文件加载系统实现细节

**CSV文件加载器 (LoadFileToTBL)**
```python
class CSVLoader:
    def __init__(self, encoding_detector: EncodingDetector):
        self.encoding_detector = encoding_detector
    
    def load_file(self, file_path: str) -> pd.DataFrame:
        """加载CSV文件"""
        encoding = self.encoding_detector.detect_encoding(file_path)
        
        try:
            df = pd.read_csv(file_path, encoding=encoding)
            return self._clean_data(df)
        except Exception as e:
            logger.error(f"文件加载失败: {file_path}, 错误: {e}")
            return pd.DataFrame()
    
    def _clean_data(self, df: pd.DataFrame) -> pd.DataFrame:
        """数据清理"""
        # 移除空行
        df = df.dropna(how='all')
        # 处理NaN值
        df = df.fillna('')
        return df
```

#### 11.3.2 数据搜索功能算法设计

**表搜索引擎 (searchT_relation)**
```python
class TableSearcher:
    def __init__(self, data_tables: Dict[str, pd.DataFrame]):
        self.data_tables = data_tables
        self.search_cache = {}
    
    def search_table(self, table_name: str, search_criteria: Dict) -> pd.DataFrame:
        """搜索数据表"""
        cache_key = f"{table_name}_{str(search_criteria)}"
        if cache_key in self.search_cache:
            return self.search_cache[cache_key]
        
        if table_name not in self.data_tables:
            return pd.DataFrame()
        
        table = self.data_tables[table_name]
        result = table.copy()
        
        for column, value in search_criteria.items():
            if column in table.columns:
                result = result[result[column] == value]
        
        self.search_cache[cache_key] = result
        return result
```

#### 11.3.3 数据操作技术实现

**数据转换器 (searchT_ChngValue)**
```python
class DataConverter:
    def __init__(self, conversion_rules: Dict):
        self.conversion_rules = conversion_rules
    
    def convert_value(self, value: Any, conversion_type: str) -> Any:
        """转换数据值"""
        if conversion_type in self.conversion_rules:
            rule = self.conversion_rules[conversion_type]
            return rule(value)
        return value
    
    def add_conversion_rule(self, conversion_type: str, rule: Callable):
        """添加转换规则"""
        self.conversion_rules[conversion_type] = rule
```

### 11.4 通信模块详细设计

#### 11.4.1 通信协议支持技术实现

**NC通信协议处理器 (makeSendTxt)**
```python
class NCProtocolHandler:
    def __init__(self, protocol_type: str):
        self.protocol_type = protocol_type
        self.message_formatters = {
            'rexroth': self._format_rexroth_message,
            'brother': self._format_brother_message
        }
    
    def format_message(self, command: str, parameters: Dict) -> str:
        """格式化NC命令消息"""
        if self.protocol_type in self.message_formatters:
            return self.message_formatters[self.protocol_type](command, parameters)
        return command
    
    def _format_rexroth_message(self, command: str, parameters: Dict) -> str:
        """格式化Rexroth协议消息"""
        # Rexroth协议特定格式化逻辑
        return f"{command} {self._format_parameters(parameters)}"
    
    def _format_brother_message(self, command: str, parameters: Dict) -> str:
        """格式化Brother协议消息"""
        # Brother协议特定格式化逻辑
        return f"{command};{self._format_parameters(parameters)}"
```

#### 11.4.2 进程间通信机制设计

**连接状态管理器 (ConnectionChange)**
```python
class ConnectionManager:
    def __init__(self):
        self.connections = {}
        self.connection_callbacks = []
    
    def add_connection(self, connection_id: str, connection: object):
        """添加连接"""
        self.connections[connection_id] = connection
        self._notify_connection_change(connection_id, 'connected')
    
    def remove_connection(self, connection_id: str):
        """移除连接"""
        if connection_id in self.connections:
            del self.connections[connection_id]
            self._notify_connection_change(connection_id, 'disconnected')
    
    def _notify_connection_change(self, connection_id: str, status: str):
        """通知连接状态变更"""
        for callback in self.connection_callbacks:
            callback(connection_id, status)
```

#### 11.4.3 命名管道通信具体实现

**异步命名管道客户端 (NamedPipeAsyncClient)**
```python
class NamedPipeClient:
    def __init__(self, pipe_name: str):
        self.pipe_name = pipe_name
        self.connected = False
        self.data_received_callbacks = []
    
    async def connect(self):
        """异步连接命名管道"""
        try:
            # Windows命名管道连接实现
            self.connected = True
            await self._start_listening()
        except Exception as e:
            logger.error(f"命名管道连接失败: {e}")
            self.connected = False
    
    async def send_data(self, data: str):
        """异步发送数据"""
        if self.connected:
            # 实现数据发送逻辑
            pass
    
    def add_data_received_callback(self, callback: Callable):
        """添加数据接收回调"""
        self.data_received_callbacks.append(callback)
```

### 11.5 用户界面交互详细设计

#### 11.5.1 事件处理系统架构设计

**事件分发器**
```python
class EventDispatcher:
    def __init__(self):
        self.event_handlers = {}
    
    def register_handler(self, event_type: str, handler: Callable):
        """注册事件处理器"""
        if event_type not in self.event_handlers:
            self.event_handlers[event_type] = []
        self.event_handlers[event_type].append(handler)
    
    def dispatch_event(self, event_type: str, event_data: Dict):
        """分发事件"""
        if event_type in self.event_handlers:
            for handler in self.event_handlers[event_type]:
                try:
                    handler(event_data)
                except Exception as e:
                    logger.error(f"事件处理错误: {e}")
```

#### 11.5.2 输入处理技术实现

**文本变更处理器 (txt_change)**
```python
class TextChangeHandler:
    def __init__(self, validation_rules: Dict, calculation_trigger: Callable):
        self.validation_rules = validation_rules
        self.calculation_trigger = calculation_trigger
        self.change_event_flag = False
    
    def handle_text_change(self, control_id: str, new_text: str):
        """处理文本变更"""
        if self.change_event_flag:
            return
        
        self.change_event_flag = True
        
        try:
            # 数据验证
            if self._validate_text(control_id, new_text):
                # 触发计算
                self.calculation_trigger(control_id, new_text)
        finally:
            self.change_event_flag = False
    
    def _validate_text(self, control_id: str, text: str) -> bool:
        """验证文本内容"""
        if control_id in self.validation_rules:
            rule = self.validation_rules[control_id]
            return rule(text)
        return True
```

#### 11.5.3 操作员管理功能设计

**操作员管理器 (TB_OpeID_TextChanged)**
```python
class OperatorManager:
    def __init__(self):
        self.current_operator = None
        self.operator_database = {}
    
    def set_operator(self, operator_id: str):
        """设置当前操作员"""
        if operator_id in self.operator_database:
            self.current_operator = self.operator_database[operator_id]
            logger.info(f"操作员已切换: {self.current_operator.name}")
        else:
            logger.warning(f"未知操作员ID: {operator_id}")
    
    def get_operator_name(self, operator_id: str) -> str:
        """获取操作员名称"""
        if operator_id in self.operator_database:
            return self.operator_database[operator_id].name
        return "未知操作员"
```

### 11.6 数据验证模块详细设计

#### 11.6.1 验证方法具体实现

**数值验证器 (chkTxtIsNumeric)**
```python
class NumericValidator:
    def validate(self, text: str, min_value: float = None, 
                max_value: float = None, decimal_places: int = None) -> bool:
        """验证数值文本"""
        try:
            value = float(text)
            
            if min_value is not None and value < min_value:
                return False
            
            if max_value is not None and value > max_value:
                return False
            
            if decimal_places is not None:
                # 检查小数位数
                decimal_part = str(value).split('.')
                if len(decimal_part) > 1 and len(decimal_part[1]) > decimal_places:
                    return False
            
            return True
        except ValueError:
            return False
```

#### 11.6.2 验证规则技术设计

**业务规则验证器 (chkAddControls)**
```python
class BusinessRuleValidator:
    def __init__(self, validation_rules: Dict):
        self.validation_rules = validation_rules
    
    def validate_controls(self, control_values: Dict) -> Dict[str, str]:
        """验证控件组业务规则"""
        errors = {}
        
        for rule_name, rule in self.validation_rules.items():
            if not rule(control_values):
                errors[rule_name] = f"业务规则验证失败: {rule_name}"
        
        return errors
    
    def add_validation_rule(self, rule_name: str, rule: Callable):
        """添加验证规则"""
        self.validation_rules[rule_name] = rule
```

#### 11.6.3 错误处理机制

**验证错误处理器**
```python
class ValidationErrorHandler:
    def __init__(self):
        self.error_messages = {}
    
    def add_error(self, control_id: str, message: str):
        """添加错误信息"""
        if control_id not in self.error_messages:
            self.error_messages[control_id] = []
        self.error_messages[control_id].append(message)
    
    def clear_errors(self, control_id: str = None):
        """清除错误信息"""
        if control_id:
            if control_id in self.error_messages:
                del self.error_messages[control_id]
        else:
            self.error_messages.clear()
    
    def has_errors(self) -> bool:
        """检查是否有错误"""
        return len(self.error_messages) > 0
```

### 11.7 系统管理模块详细设计

#### 11.7.1 初始化系统技术实现

**系统初始化器 (Frm_main_Load)**
```python
class SystemInitializer:
    def __init__(self, config_manager: ConfigManager, data_manager: DataManager):
        self.config_manager = config_manager
        self.data_manager = data_manager
        self.initialization_steps = [
            self._load_configuration,
            self._load_master_data,
            self._initialize_ui,
            self._setup_communication
        ]
    
    async def initialize_system(self):
        """异步初始化系统"""
        for step in self.initialization_steps:
            try:
                await step()
            except Exception as e:
                logger.error(f"初始化步骤失败: {e}")
                raise
    
    async def _load_configuration(self):
# DNC系统开发详细文档

## 1. 项目概述

### 1.1 系统简介
DNC（Direct Numerical Control）系统是一个数控设备参数管理软件，用于从电脑直接传送参数到NC机的宏变量系统。该系统解决了传统NC机手动输入参数的时间和错误问题。

### 1.2 系统架构 - 基于VB.NET源码分析
- **原系统**: VB.NET DNC2.05 (基于Frm_main.vb主窗体)
- **新系统**: Python重写版本 (基于VB.NET源码完整重构)
- **系统构成**: PC + NC机 + LAN线 + DNC软件 + 命名管道通信
- **数据格式**: CSV文件存储Master数据 + 动态控件系统
- **核心架构**: 8种控件系统 + 计算引擎 + 通信模块 + 数据处理

## 2. 系统功能模块

### 2.1 核心功能模块

#### 2.1.1 产品型号管理
- 产品类型定义 (type_define.csv)
- 程序类型映射 (type_prg.csv)
- 产品参数配置 (load.csv)

#### 2.1.2 参数计算引擎
- 几何参数计算 (calc.csv)
- 关系验证逻辑 (relation.csv)
- 变量定义管理 (define.csv)

#### 2.1.3 程序生成器
- 程序定义 (prg.csv)
- 控制参数 (cntrl_rex.csv)
- 选择逻辑 (select.csv)

### 2.2 数据流处理

#### 2.2.1 输入处理
```python
输入 → 参数验证 → 计算引擎 → 程序生成 → 输出
```

#### 2.2.2 宏变量映射
- #500-#600: 系统参数
- #1-#100: 用户参数
- 特殊变量: 计算中间值

## 3. 数据结构详细说明

### 3.1 核心数据文件

#### 3.1.1 type_define.csv (产品类型定义)
- **文件大小**: 988.60 KB
- **数据结构**:
  - NO: 序号
  - TYPE: 产品型号 (如: GPA18GT15040-A)
  - DEFINE1: 定义1
  - DEFINE2: 定义2

#### 3.1.2 type_prg.csv (程序类型映射)
- **文件大小**: 480.92 KB
- **数据结构**:
  - NO: 序号
  - prg1: 程序1编号
  - prg2: 程序2编号

#### 3.1.3 load.csv (主数据文件)
- **文件大小**: 8.5 MB
- **数据结构**:
  - NO: 序号
  - TYPE: 产品型号
  - DRAWING: 图纸文件
  - DISPFLG: 显示标志
  - #1-#12: 定义变量
  - #500-#550: 系统参数
  - #602-#603: 开关控制

#### 3.1.4 cntrl_rex.csv (参数控制)
- **文件大小**: 1.10 KB
- **数据结构**:
  - PARAMETER: 参数名称 (如: Work_plan, Teeth_num)
  - DATATYPE: 数据类型 (int, real, boolean)
  - MACRO: 宏变量映射 (如: #510, #511)

### 3.2 计算逻辑文件

#### 3.2.1 calc.csv (计算定义)
```csv
DEFINE,1,2,3,4,5,6,7,8,9,10,11,12,13
calcABC,=,#528,-,#510,*,2,NaN,NaN,NaN,NaN,NaN,NaN,NaN
calcABCD,=,(,#528,-,#513,),/,2.0,NaN,NaN,NaN,NaN,NaN
```

#### 3.2.2 relation.csv (关系验证)
```csv
DEFINE,VALUE,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28
relationHPN,#1,and,#1,>,0.0,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN
```

#### 3.2.3 define.csv (变量定义)
```csv
DEFINE,STR,BEFORE,AFTER,CHNGVL,CALC
defineP,P,P0,0,NaN,NaN
defineH,H,H0,0,NaN,NaN
```

## 4. 技术架构设计

### 4.1 系统架构图

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   用户界面层     │    │   业务逻辑层     │    │   数据访问层     │
│                 │    │                 │    │                 │
│  - 主窗口       │◄──►│  - 参数计算     │◄──►│  - CSV处理器    │
│  - 输入表单     │    │  - 程序生成     │    │  - 数据验证     │
│  - 结果显示     │    │  - 关系验证     │    │  - 编码处理     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 4.2 核心类设计

#### 4.2.1 DataManager (数据管理器)
```python
class DataManager:
    def load_master_data(self) -> Dict[str, pd.DataFrame]
    def batch_read_large_csv(self, file_path: str, batch_size: int = 1000)
    def validate_data_integrity(self) -> bool
    def fix_encoding_issues(self, file_path: str) -> pd.DataFrame
```

#### 4.2.2 CalculationEngine (计算引擎)
```python
class CalculationEngine:
    def calculate_parameters(self, input_data: Dict) -> Dict
    def validate_relations(self, calculated_data: Dict) -> bool
    def generate_macro_variables(self, params: Dict) -> List[str]
```

#### 4.2.3 ProgramGenerator (程序生成器)
```python
class ProgramGenerator:
    def generate_nc_program(self, product_type: str, params: Dict) -> str
    def apply_program_template(self, template: str, variables: Dict) -> str
    def validate_program_syntax(self, program: str) -> bool
```

## 5. 数据处理流程

### 5.1 数据加载流程
1. **扫描目录**: 递归扫描master目录下的所有CSV文件
2. **分类处理**: 根据文件大小分类为小文件和大文件
3. **编码检测**: 自动检测文件编码 (UTF-8, Shift-JIS, CP932)
4. **分批读取**: 大文件使用分批读取机制
5. **数据验证**: 检查数据完整性和一致性

### 5.2 参数计算流程
1. **输入验证**: 验证用户输入参数的有效性
2. **变量替换**: 根据define.csv进行变量替换
3. **计算执行**: 执行calc.csv中定义的计算逻辑
4. **关系验证**: 验证relation.csv中定义的关系条件
5. **结果生成**: 生成最终的宏变量值

## 6. 文件编码处理

### 6.1 编码问题文件列表
- `ini.csv`: 958字节，编码问题
- `math.csv`: 1.08KB，编码问题  
- `cntrl.csv`: 1.38KB，编码问题
- `switch.csv`: 106字节，编码问题

### 6.2 编码处理策略
```python
def detect_encoding(file_path: str) -> str:
    encodings = ['utf-8', 'shift_jis', 'cp932', 'latin1']
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as f:
                f.read()
            return encoding
        except UnicodeDecodeError:
            continue
    return 'unknown'
```

## 7. 性能优化策略

### 7.1 大文件处理优化
- **分批读取**: 使用pandas的chunksize参数
- **内存管理**: 及时释放不需要的数据
- **缓存机制**: 缓存频繁访问的数据

### 7.2 计算优化
- **预编译**: 预编译计算表达式
- **并行处理**: 使用多线程处理独立计算
- **结果缓存**: 缓存重复计算结果

## 8. 错误处理机制

### 8.1 数据验证错误
- 文件不存在错误
- 编码错误处理
- 数据格式错误
- 完整性检查失败

### 8.2 计算错误
- 除零错误处理
- 变量未定义错误
- 关系验证失败
- 程序生成错误

## 9. 部署和配置

### 9.1 环境要求
- Python 3.8+
- pandas >= 1.3.0
- PyQt5/PySide6
- 操作系统: Windows 10/11

### 9.2 配置文件
```ini
[system]
data_directory = ./data/master
log_level = INFO
batch_size = 1000

[encoding]
default_encoding = utf-8
fallback_encodings = shift_jis,cp932,latin1
```

## 10. 测试策略

### 10.1 单元测试
- 数据加载测试
- 计算逻辑测试
- 程序生成测试
- 错误处理测试

### 10.2 集成测试
- 端到端流程测试
- 性能测试
- 兼容性测试

## 11. 功能模块详细设计

### 11.1 控件系统详细设计

#### 11.1.1 8种核心控件类型实现

**Load控件 (makeCntrlLoad)**
```python
class LoadControl:
    def __init__(self, data_source: str, field_mapping: Dict):
        self.data_source = data_source
        self.field_mapping = field_mapping
        self.data_table = None
    
    def load_data(self) -> pd.DataFrame:
        """从CSV文件加载数据"""
        try:
            self.data_table = pd.read_csv(self.data_source, encoding='utf-8')
            return self.data_table
        except Exception as e:
            logger.error(f"加载数据失败: {e}")
            return None
    
    def validate_data(self) -> bool:
        """验证数据完整性"""
        required_fields = ['NO', 'TYPE', 'DRAWING']
        return all(field in self.data_table.columns for field in required_fields)
```

**Input控件 (makeCntrlInput)**
```python
class InputControl:
    def __init__(self, control_id: str, data_type: str, validation_rules: Dict):
        self.control_id = control_id
        self.data_type = data_type
        self.validation_rules = validation_rules
        self.value = None
    
    def handle_text_change(self, new_value: str):
        """处理文本变更事件"""
        if self.validate_input(new_value):
            self.value = self.convert_value(new_value)
            self.trigger_calculation()
    
    def validate_input(self, value: str) -> bool:
        """验证输入值"""
        if self.data_type == 'numeric':
            return self._validate_numeric(value)
        elif self.data_type == 'string':
            return self._validate_string(value)
        return False
```

#### 11.1.2 基础控件创建方法Python实现

**文本框创建 (makeTextBox)**
```python
def create_text_box(name: str, location: Tuple[int, int], size: Tuple[int, int], 
                   text_change_handler: Callable) -> QLineEdit:
    """创建文本框控件"""
    text_box = QLineEdit()
    text_box.setObjectName(name)
    text_box.setGeometry(location[0], location[1], size[0], size[1])
    text_box.textChanged.connect(text_change_handler)
    return text_box
```

**标签创建 (makeLabel)**
```python
def create_label(name: str, text: str, location: Tuple[int, int], 
                size: Tuple[int, int]) -> QLabel:
    """创建标签控件"""
    label = QLabel(text)
    label.setObjectName(name)
    label.setGeometry(location[0], location[1], size[0], size[1])
    return label
```

#### 11.1.3 动态控件管理技术细节

**控件生命周期管理**
```python
class ControlManager:
    def __init__(self):
        self.controls = {}
        self.control_groups = {}
    
    def add_control(self, control_id: str, control: QWidget):
        """添加控件到管理器"""
        self.controls[control_id] = control
    
    def remove_control(self, control_id: str):
        """移除控件"""
        if control_id in self.controls:
            self.controls[control_id].deleteLater()
            del self.controls[control_id]
    
    def enable_controls(self, control_ids: List[str], enabled: bool):
        """批量启用/禁用控件"""
        for control_id in control_ids:
            if control_id in self.controls:
                self.controls[control_id].setEnabled(enabled)
```

### 11.2 计算引擎详细设计

#### 11.2.1 表达式计算具体算法

**表达式解析器 (getCalcResult)**
```python
class ExpressionCalculator:
    def __init__(self):
        self.variables = {}
        self.functions = {
            'MAX': max,
            'MIN': min,
            'ROUND': round,
            'ABS': abs
        }
    
    def calculate(self, expression: str, variables: Dict) -> float:
        """计算表达式值"""
        try:
            # 变量替换
            expr = self._replace_variables(expression, variables)
            # 表达式求值
            result = eval(expr, {"__builtins__": None}, self.functions)
            return float(result)
        except Exception as e:
            logger.error(f"表达式计算错误: {expression}, 错误: {e}")
            return 0.0
    
    def _replace_variables(self, expression: str, variables: Dict) -> str:
        """替换表达式中的变量"""
        for var_name, var_value in variables.items():
            expression = expression.replace(f"@{var_name}", str(var_value))
        return expression
```

#### 11.2.2 条件判断系统实现逻辑

**关系判断引擎 (judgeRelation)**
```python
class RelationJudge:
    def judge(self, condition: str, left_value: Any, right_value: Any) -> bool:
        """判断关系条件"""
        operators = {
            '=': lambda x, y: x == y,
            '<>': lambda x, y: x != y,
            '>': lambda x, y: x > y,
            '<': lambda x, y: x < y,
            '>=': lambda x, y: x >= y,
            '<=': lambda x, y: x <= y
        }
        
        for op, func in operators.items():
            if op in condition:
                return func(left_value, right_value)
        
        return False
```

#### 11.2.3 精度控制技术方案

**数值精度管理**
```python
class PrecisionController:
    def __init__(self, decimal_places: int = 4):
        self.decimal_places = decimal_places
    
    def round_value(self, value: float) -> float:
        """四舍五入处理"""
        return round(value, self.decimal_places)
    
    def format_display(self, value: float) -> str:
        """格式化显示值"""
        return f"{value:.{self.decimal_places}f}".rstrip('0').rstrip('.')
```

### 11.3 数据处理模块详细设计

#### 11.3.1 文件加载系统实现细节

**CSV文件加载器 (LoadFileToTBL)**
```python
class CSVLoader:
    def __init__(self, encoding_detector: EncodingDetector):
        self.encoding_detector = encoding_detector
    
    def load_file(self, file_path: str) -> pd.DataFrame:
        """加载CSV文件"""
        encoding = self.encoding_detector.detect_encoding(file_path)
        
        try:
            df = pd.read_csv(file_path, encoding=encoding)
            return self._clean_data(df)
        except Exception as e:
            logger.error(f"文件加载失败: {file_path}, 错误: {e}")
            return pd.DataFrame()
    
    def _clean_data(self, df: pd.DataFrame) -> pd.DataFrame:
        """数据清理"""
        # 移除空行
        df = df.dropna(how='all')
        # 处理NaN值
        df = df.fillna('')
        return df
```

#### 11.3.2 数据搜索功能算法设计

**表搜索引擎 (searchT_relation)**
```python
class TableSearcher:
    def __init__(self, data_tables: Dict[str, pd.DataFrame]):
        self.data_tables = data_tables
        self.search_cache = {}
    
    def search_table(self, table_name: str, search_criteria: Dict) -> pd.DataFrame:
        """搜索数据表"""
        cache_key = f"{table_name}_{str(search_criteria)}"
        if cache_key in self.search_cache:
            return self.search_cache[cache_key]
        
        if table_name not in self.data_tables:
            return pd.DataFrame()
        
        table = self.data_tables[table_name]
        result = table.copy()
        
        for column, value in search_criteria.items():
            if column in table.columns:
                result = result[result[column] == value]
        
        self.search_cache[cache_key] = result
        return result
```

#### 11.3.3 数据操作技术实现

**数据转换器 (searchT_ChngValue)**
```python
class DataConverter:
    def __init__(self, conversion_rules: Dict):
        self.conversion_rules = conversion_rules
    
    def convert_value(self, value: Any, conversion_type: str) -> Any:
        """转换数据值"""
        if conversion_type in self.conversion_rules:
            rule = self.conversion_rules[conversion_type]
            return rule(value)
        return value
    
    def add_conversion_rule(self, conversion_type: str, rule: Callable):
        """添加转换规则"""
        self.conversion_rules[conversion_type] = rule
```

### 11.4 通信模块详细设计

#### 11.4.1 通信协议支持技术实现

**NC通信协议处理器 (makeSendTxt)**
```python
class NCProtocolHandler:
    def __init__(self, protocol_type: str):
        self.protocol_type = protocol_type
        self.message_formatters = {
            'rexroth': self._format_rexroth_message,
            'brother': self._format_brother_message
        }
    
    def format_message(self, command: str, parameters: Dict) -> str:
        """格式化NC命令消息"""
        if self.protocol_type in self.message_formatters:
            return self.message_formatters[self.protocol_type](command, parameters)
        return command
    
    def _format_rexroth_message(self, command: str, parameters: Dict) -> str:
        """格式化Rexroth协议消息"""
        # Rexroth协议特定格式化逻辑
        return f"{command} {self._format_parameters(parameters)}"
    
    def _format_brother_message(self, command: str, parameters: Dict) -> str:
        """格式化Brother协议消息"""
        # Brother协议特定格式化逻辑
        return f"{command};{self._format_parameters(parameters)}"
```

#### 11.4.2 进程间通信机制设计

**连接状态管理器 (ConnectionChange)**
```python
class ConnectionManager:
    def __init__(self):
        self.connections = {}
        self.connection_callbacks = []
    
    def add_connection(self, connection_id: str, connection: object):
        """添加连接"""
        self.connections[connection_id] = connection
        self._notify_connection_change(connection_id, 'connected')
    
    def remove_connection(self, connection_id: str):
        """移除连接"""
        if connection_id in self.connections:
            del self.connections[connection_id]
            self._notify_connection_change(connection_id, 'disconnected')
    
    def _notify_connection_change(self, connection_id: str, status: str):
        """通知连接状态变更"""
        for callback in self.connection_callbacks:
            callback(connection_id, status)
```

#### 11.4.3 命名管道通信具体实现

**异步命名管道客户端 (NamedPipeAsyncClient)**
```python
class NamedPipeClient:
    def __init__(self, pipe_name: str):
        self.pipe_name = pipe_name
        self.connected = False
        self.data_received_callbacks = []
    
    async def connect(self):
        """异步连接命名管道"""
        try:
            # Windows命名管道连接实现
            self.connected = True
            await self._start_listening()
        except Exception as e:
            logger.error(f"命名管道连接失败: {e}")
            self.connected = False
    
    async def send_data(self, data: str):
        """异步发送数据"""
        if self.connected:
            # 实现数据发送逻辑
            pass
    
    def add_data_received_callback(self, callback: Callable):
        """添加数据接收回调"""
        self.data_received_callbacks.append(callback)
```

### 11.5 用户界面交互详细设计

#### 11.5.1 事件处理系统架构设计

**事件分发器**
```python
class EventDispatcher:
    def __init__(self):
        self.event_handlers = {}
    
    def register_handler(self, event_type: str, handler: Callable):
        """注册事件处理器"""
        if event_type not in self.event_handlers:
            self.event_handlers[event_type] = []
        self.event_handlers[event_type].append(handler)
    
    def dispatch_event(self, event_type: str, event_data: Dict):
        """分发事件"""
        if event_type in self.event_handlers:
            for handler in self.event_handlers[event_type]:
                try:
                    handler(event_data)
                except Exception as e:
                    logger.error(f"事件处理错误: {e}")
```

#### 11.5.2 输入处理技术实现

**文本变更处理器 (txt_change)**
```python
class TextChangeHandler:
    def __init__(self, validation_rules: Dict, calculation_trigger: Callable):
        self.validation_rules = validation_rules
        self.calculation_trigger = calculation_trigger
        self.change_event_flag = False
    
    def handle_text_change(self, control_id: str, new_text: str):
        """处理文本变更"""
        if self.change_event_flag:
            return
        
        self.change_event_flag = True
        
        try:
            # 数据验证
            if self._validate_text(control_id, new_text):
                # 触发计算
                self.calculation_trigger(control_id, new_text)
        finally:
            self.change_event_flag = False
    
    def _validate_text(self, control_id: str, text: str) -> bool:
        """验证文本内容"""
        if control_id in self.validation_rules:
            rule = self.validation_rules[control_id]
            return rule(text)
        return True
```

#### 11.5.3 操作员管理功能设计

**操作员管理器 (TB_OpeID_TextChanged)**
```python
class OperatorManager:
    def __init__(self):
        self.current_operator = None
        self.operator_database = {}
    
    def set_operator(self, operator_id: str):
        """设置当前操作员"""
        if operator_id in self.operator_database:
            self.current_operator = self.operator_database[operator_id]
            logger.info(f"操作员已切换: {self.current_operator.name}")
        else:
            logger.warning(f"未知操作员ID: {operator_id}")
    
    def get_operator_name(self, operator_id: str) -> str:
        """获取操作员名称"""
        if operator_id in self.operator_database:
            return self.operator_database[operator_id].name
        return "未知操作员"
```

### 11.6 数据验证模块详细设计

#### 11.6.1 验证方法具体实现

**数值验证器 (chkTxtIsNumeric)**
```python
class NumericValidator:
    def validate(self, text: str, min_value: float = None, 
                max_value: float = None, decimal_places: int = None) -> bool:
        """验证数值文本"""
        try:
            value = float(text)
            
            if min_value is not None and value < min_value:
                return False
            
            if max_value is not None and value > max_value:
                return False
            
            if decimal_places is not None:
                # 检查小数位数
                decimal_part = str(value).split('.')
                if len(decimal_part) > 1 and len(decimal_part[1]) > decimal_places:
                    return False
            
            return True
        except ValueError:
            return False
```

#### 11.6.2 验证规则技术设计

**业务规则验证器 (chkAddControls)**
```python
class BusinessRuleValidator:
    def __init__(self, validation_rules: Dict):
        self.validation_rules = validation_rules
    
    def validate_controls(self, control_values: Dict) -> Dict[str, str]:
        """验证控件组业务规则"""
        errors = {}
        
        for rule_name, rule in self.validation_rules.items():
            if not rule(control_values):
                errors[rule_name] = f"业务规则验证失败: {rule_name}"
        
        return errors
    
    def add_validation_rule(self, rule_name: str, rule: Callable):
        """添加验证规则"""
        self.validation_rules[rule_name] = rule
```

#### 11.6.3 错误处理机制

**验证错误处理器**
```python
class ValidationErrorHandler:
    def __init__(self):
        self.error_messages = {}
    
    def add_error(self, control_id: str, message: str):
        """添加错误信息"""
        if control_id not in self.error_messages:
            self.error_messages[control_id] = []
        self.error_messages[control_id].append(message)
    
    def clear_errors(self, control_id: str = None):
        """清除错误信息"""
        if control_id:
            if control_id in self.error_messages:
                del self.error_messages[control_id]
        else:
            self.error_messages.clear()
    
    def has_errors(self) -> bool:
        """检查是否有错误"""
        return len(self.error_messages) > 0
```

### 11.7 系统管理模块详细设计

#### 11.7.1 初始化系统技术实现

**系统初始化器 (Frm_main_Load)**
```python
class SystemInitializer:
    def __init__(self, config_manager: ConfigManager, data_manager: DataManager):
        self.config_manager = config_manager
        self.data_manager = data_manager
        self.initialization_steps = [
            self._load_configuration,
            self._load_master_data,
            self._initialize_ui,
            self._setup_communication
        ]
    
    async def initialize_system(self):
        """异步初始化系统"""
        for step in self.initialization_steps:
            try:
                await step()
            except Exception as e:
                logger.error(f"初始化步骤失败: {e}")
                raise
    
    async def _load_configuration(self):
        """加载系统配置"""
        self.config = await self.config_manager.load_config()
    
    async def _load_master_data(self):
        """加载Master数据"""
        self.master_data = await self.data_manager.load_master_data()
    
    async def _initialize_ui(self):
        """初始化用户界面"""
        # 创建主窗口和控件
        pass
    
    async def _setup_communication(self):
        """设置通信连接"""
        # 初始化NC通信和命名管道
        pass
```

#### 11.7.2 显示管理功能设计

**控件状态管理器 (ControlStateManager)**
```python
class ControlStateManager:
    def __init__(self):
        self.control_states = {}
        self.control_groups = {}
    
    def set_controls_enabled(self, control_ids: List[str], enabled: bool):
        """设置控件启用状态"""
        for control_id in control_ids:
            if control_id in self.control_states:
                self.control_states[control_id].setEnabled(enabled)
    
    def set_controls_visible(self, control_ids: List[str], visible: bool):
        """设置控件可见性"""
        for control_id in control_ids:
            if control_id in self.control_states:
                self.control_states[control_id].setVisible(visible)
    
    def add_control_group(self, group_name: str, control_ids: List[str]):
        """添加控件组"""
        self.control_groups[group_name] = control_ids
    
    def set_group_enabled(self, group_name: str, enabled: bool):
        """设置控件组启用状态"""
        if group_name in self.control_groups:
            self.set_controls_enabled(self.control_groups[group_name], enabled)
```

#### 11.7.3 配置管理技术方案

**INI配置管理器 (IniConfigManager)**
```python
class IniConfigManager:
    def __init__(self, ini_file_path: str):
        self.ini_file_path = ini_file_path
        self.config = {}
    
    def load_config(self) -> Dict:
        """加载INI配置文件"""
        config = configparser.ConfigParser()
        config.read(self.ini_file_path, encoding='utf-8')
        
        for section in config.sections():
            self.config[section] = dict(config.items(section))
        
        return self.config
    
    def save_config(self, config: Dict):
        """保存INI配置文件"""
        config_parser = configparser.ConfigParser()
        
        for section, options in config.items():
            config_parser[section] = options
        
        with open(self.ini_file_path, 'w', encoding='utf-8') as f:
            config_parser.write(f)
    
    def get_value(self, section: str, key: str, default=None):
        """获取配置值"""
        return self.config.get(section, {}).get(key, default)
```

### 11.8 工具方法详细设计

#### 11.8.1 字符串处理技术实现

**字符串工具类 (StringUtils)**
```python
class StringUtils:
    @staticmethod
    def len_b(text: str) -> int:
        """计算字符串字节长度（兼容VB.NET的LenB函数）"""
        return len(text.encode('utf-8'))
    
    @staticmethod
    def make_format_str(format_pattern: str, *args) -> str:
        """创建格式化字符串"""
        try:
            return format_pattern.format(*args)
        except Exception as e:
            logger.error(f"字符串格式化失败: {e}")
            return format_pattern
    
    @staticmethod
    def to_half_adjust(value: float, decimal_places: int = 0) -> float:
        """四舍五入处理（兼容VB.NET的ToHalfAdjust）"""
        factor = 10 ** decimal_places
        return round(value * factor) / factor
    
    @staticmethod
    def get_operator_name(operator_id: str) -> str:
        """获取操作员名称"""
        operator_map = {
            '001': '操作员A',
            '002': '操作员B',
            '003': '操作员C'
        }
        return operator_map.get(operator_id, '未知操作员')
```

#### 11.8.2 系统工具功能设计

**系统工具类 (SystemUtils)**
```python
class SystemUtils:
    @staticmethod
    def get_all_controls(parent_widget: QWidget) -> List[QWidget]:
        """获取所有子控件"""
        controls = []
        
        def collect_controls(widget):
            for child in widget.children():
                if isinstance(child, QWidget):
                    controls.append(child)
                    collect_controls(child)
        
        collect_controls(parent_widget)
        return controls
    
    @staticmethod
    def change_form_size(form: QWidget, width: int, height: int):
        """改变窗体大小"""
        form.resize(width, height)
    
    @staticmethod
    def show_info_form(title: str, message: str):
        """显示信息窗体"""
        msg_box = QMessageBox()
        msg_box.setWindowTitle(title)
        msg_box.setText(message)
        msg_box.setIcon(QMessageBox.Information)
        msg_box.exec_()
```

#### 11.8.3 数值处理工具

**公差计算器 (ToleranceCalculator)**
```python
class ToleranceCalculator:
    @staticmethod
    def get_shafts_tolerance(diameter: float, tolerance_class: str) -> Tuple[float, float]:
        """获取轴公差"""
        tolerance_tables = {
            'h6': {10: (-0.009, 0), 18: (-0.011, 0), 30: (-0.013, 0)},
            'h7': {10: (-0.015, 0), 18: (-0.018, 0), 30: (-0.021, 0)},
            'h8': {10: (-0.022, 0), 18: (-0.027, 0), 30: (-0.033, 0)}
        }
        
        for max_diameter, tolerance in tolerance_tables.get(tolerance_class, {}).items():
            if diameter <= max_diameter:
                return tolerance
        
        return (0, 0)
    
    @staticmethod
    def get_length_tolerance(length: float, tolerance_class: str) -> Tuple[float, float]:
        """获取长度公差"""
        tolerance_tables = {
            'fine': {100: (-0.1, 0.1), 400: (-0.2, 0.2), 1000: (-0.3, 0.3)},
            'medium': {100: (-0.2, 0.2), 400: (-0.4, 0.4), 1000: (-0.6, 0.6)},
            'coarse': {100: (-0.4, 0.4), 400: (-0.8, 0.8), 1000: (-1.2, 1.2)}
        }
        
        for max_length, tolerance in tolerance_tables.get(tolerance_class, {}).items():
            if length <= max_length:
                return tolerance
        
        return (0, 0)
```

## 12. 技术架构设计

### 12.1 核心类设计
# DNC系统开发详细文档

## 1. 项目概述

### 1.1 系统简介
DNC（Direct Numerical Control）系统是一个数控设备参数管理软件，用于从电脑直接传送参数到NC机的宏变量系统。该系统解决了传统NC机手动输入参数的时间和错误问题。

### 1.2 系统架构 - 基于VB.NET源码分析
- **原系统**: VB.NET DNC2.05 (基于Frm_main.vb主窗体)
- **新系统**: Python重写版本 (基于VB.NET源码完整重构)
- **系统构成**: PC + NC机 + LAN线 + DNC软件 + 命名管道通信
- **数据格式**: CSV文件存储Master数据 + 动态控件系统
- **核心架构**: 8种控件系统 + 计算引擎 + 通信模块 + 数据处理

## 2. 系统功能模块

### 2.1 核心功能模块

#### 2.1.1 产品型号管理
- 产品类型定义 (type_define.csv)
- 程序类型映射 (type_prg.csv)
- 产品参数配置 (load.csv)

#### 2.1.2 参数计算引擎
- 几何参数计算 (calc.csv)
- 关系验证逻辑 (relation.csv)
- 变量定义管理 (define.csv)

#### 2.1.3 程序生成器
- 程序定义 (prg.csv)
- 控制参数 (cntrl_rex.csv)
- 选择逻辑 (select.csv)

### 2.2 数据流处理

#### 2.2.1 输入处理
```python
输入 → 参数验证 → 计算引擎 → 程序生成 → 输出
```

#### 2.2.2 宏变量映射
- #500-#600: 系统参数
- #1-#100: 用户参数
- 特殊变量: 计算中间值

## 3. 数据结构详细说明

### 3.1 核心数据文件

#### 3.1.1 type_define.csv (产品类型定义)
- **文件大小**: 988.60 KB
- **数据结构**:
  - NO: 序号
  - TYPE: 产品型号 (如: GPA18GT15040-A)
  - DEFINE1: 定义1
  - DEFINE2: 定义2

#### 3.1.2 type_prg.csv (程序类型映射)
- **文件大小**: 480.92 KB
- **数据结构**:
  - NO: 序号
  - prg1: 程序1编号
  - prg2: 程序2编号

#### 3.1.3 load.csv (主数据文件)
- **文件大小**: 8.5 MB
- **数据结构**:
  - NO: 序号
  - TYPE: 产品型号
  - DRAWING: 图纸文件
  - DISPFLG: 显示标志
  - #1-#12: 定义变量
  - #500-#550: 系统参数
  - #602-#603: 开关控制

#### 3.1.4 cntrl_rex.csv (参数控制)
- **文件大小**: 1.10 KB
- **数据结构**:
  - PARAMETER: 参数名称 (如: Work_plan, Teeth_num)
  - DATATYPE: 数据类型 (int, real, boolean)
  - MACRO: 宏变量映射 (如: #510, #511)

### 3.2 计算逻辑文件

#### 3.2.1 calc.csv (计算定义)
```csv
DEFINE,1,2,3,4,5,6,7,8,9,10,11,12,13
calcABC,=,#528,-,#510,*,2,NaN,NaN,NaN,NaN,NaN,NaN,NaN
calcABCD,=,(,#528,-,#513,),/,2.0,NaN,NaN,NaN,NaN,NaN
```

#### 3.2.2 relation.csv (关系验证)
```csv
DEFINE,VALUE,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28
relationHPN,#1,and,#1,>,0.0,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN
```

#### 3.2.3 define.csv (变量定义)
```csv
DEFINE,STR,BEFORE,AFTER,CHNGVL,CALC
defineP,P,P0,0,NaN,NaN
defineH,H,H0,0,NaN,NaN
```

## 4. 技术架构设计

### 4.1 系统架构图

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   用户界面层     │    │   业务逻辑层     │    │   数据访问层     │
│                 │    │                 │    │                 │
│  - 主窗口       │◄──►│  - 参数计算     │◄──►│  - CSV处理器    │
│  - 输入表单     │    │  - 程序生成     │    │  - 数据验证     │
│  - 结果显示     │    │  - 关系验证     │    │  - 编码处理     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 4.2 核心类设计

#### 4.2.1 DataManager (数据管理器)
```python
class DataManager:
    def load_master_data(self) -> Dict[str, pd.DataFrame]
    def batch_read_large_csv(self, file_path: str, batch_size: int = 1000)
    def validate_data_integrity(self) -> bool
    def fix_encoding_issues(self, file_path: str) -> pd.DataFrame
```

#### 4.2.2 CalculationEngine (计算引擎)
```python
class CalculationEngine:
    def calculate_parameters(self, input_data: Dict) -> Dict
    def validate_relations(self, calculated_data: Dict) -> bool
    def generate_macro_variables(self, params: Dict) -> List[str]
```

#### 4.2.3 ProgramGenerator (程序生成器)
```python
class ProgramGenerator:
    def generate_nc_program(self, product_type: str, params: Dict) -> str
    def apply_program_template(self, template: str, variables: Dict) -> str
    def validate_program_syntax(self, program: str) -> bool
```

## 5. 数据处理流程

### 5.1 数据加载流程
1. **扫描目录**: 递归扫描master目录下的所有CSV文件
2. **分类处理**: 根据文件大小分类为小文件和大文件
3. **编码检测**: 自动检测文件编码 (UTF-8, Shift-JIS, CP932)
4. **分批读取**: 大文件使用分批读取机制
5. **数据验证**: 检查数据完整性和一致性

### 5.2 参数计算流程
1. **输入验证**: 验证用户输入参数的有效性
2. **变量替换**: 根据define.csv进行变量替换
3. **计算执行**: 执行calc.csv中定义的计算逻辑
4. **关系验证**: 验证relation.csv中定义的关系条件
5. **结果生成**: 生成最终的宏变量值

## 6. 文件编码处理

### 6.1 编码问题文件列表
- `ini.csv`: 958字节，编码问题
- `math.csv`: 1.08KB，编码问题  
- `cntrl.csv`: 1.38KB，编码问题
- `switch.csv`: 106字节，编码问题

### 6.2 编码处理策略
```python
def detect_encoding(file_path: str) -> str:
    encodings = ['utf-8', 'shift_jis', 'cp932', 'latin1']
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as f:
                f.read()
            return encoding
        except UnicodeDecodeError:
            continue
    return 'unknown'
```

## 7. 性能优化策略

### 7.1 大文件处理优化
- **分批读取**: 使用pandas的chunksize参数
- **内存管理**: 及时释放不需要的数据
- **缓存机制**: 缓存频繁访问的数据

### 7.2 计算优化
- **预编译**: 预编译计算表达式
- **并行处理**: 使用多线程处理独立计算
- **结果缓存**: 缓存重复计算结果

## 8. 错误处理机制

### 8.1 数据验证错误
- 文件不存在错误
- 编码错误处理
- 数据格式错误
- 完整性检查失败

### 8.2 计算错误
- 除零错误处理
- 变量未定义错误
- 关系验证失败
- 程序生成错误

## 9. 部署和配置

### 9.1 环境要求
- Python 3.8+
- pandas >= 1.3.0
- PyQt5/PySide6
- 操作系统: Windows 10/11

### 9.2 配置文件
```ini
[system]
data_directory = ./data/master
log_level = INFO
batch_size = 1000

[encoding]
default_encoding = utf-8
fallback_encodings = shift_jis,cp932,latin1
```

## 10. 测试策略

### 10.1 单元测试
- 数据加载测试
- 计算逻辑测试
- 程序生成测试
- 错误处理测试

### 10.2 集成测试
- 端到端流程测试
- 性能测试
- 兼容性测试

## 12. 技术架构设计

### 12.1 核心类设计 - 基于VB.NET源码分析

#### 12.1.1 主窗体类 (Frm_main)
```python
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.control_manager = ControlManager()
        self.data_manager = DataManager()
        self.calculation_engine = CalculationEngine()
        self.communication_manager = CommunicationManager()
        
        # 基于VB.NET Frm_main.vb的初始化逻辑
        self._initialize_ui()
        self._load_master_data()
        self._setup_communication()
    
    def _initialize_ui(self):
        """初始化用户界面 - 基于VB.NET Frm_main_Load"""
        # 创建8种控件系统
        self._create_load_controls()
        self._create_input_controls()
        self._create_calc_controls()
        self._create_relation_controls()
        self._create_define_controls()
        self._create_select_controls()
        self._create_switch_controls()
        self._create_preset_controls()
        
        # 设置窗体属性
        self.setWindowTitle("DNC系统")
        self.resize(1024, 768)
    
    def _create_load_controls(self):
        """创建Load控件 - 基于makeCntrlLoad"""
        # 实现Load控件创建逻辑
        pass
    
    def _create_input_controls(self):
        """创建Input控件 - 基于makeCntrlInput"""
        # 实现Input控件创建逻辑
        pass
```

#### 12.1.2 计算引擎类 (CalculationEngine)
```python
class CalculationEngine:
    def __init__(self):
        self.expression_calculator = ExpressionCalculator()
        self.relation_judge = RelationJudge()
        self.precision_controller = PrecisionController()
    
    def calculate_parameters(self, input_data: Dict) -> Dict:
        """计算参数 - 基于getCalcResult"""
        results = {}
        
        # 执行calc.csv中定义的计算
        for calc_name, calc_expression in self.calc_definitions.items():
            result = self.expression_calculator.calculate(calc_expression, input_data)
            results[calc_name] = self.precision_controller.round_value(result)
        
        return results
    
    def validate_relations(self, calculated_data: Dict) -> bool:
        """验证关系 - 基于judgeRelation"""
        for relation_name, relation_condition in self.relation_definitions.items():
            if not self.relation_judge.judge(relation_condition, calculated_data):
                return False
        return True
```

#### 12.1.3 通信管理器类 (CommunicationManager)
```python
class CommunicationManager:
    def __init__(self):
        self.named_pipe_client = NamedPipeClient("DNC_Pipe")
        self.protocol_handler = NCProtocolHandler("rexroth")
        self.connection_manager = ConnectionManager()
    
    async def send_to_nc_machine(self, program_data: str):
        """发送数据到NC机 - 基于makeSendTxt"""
        formatted_message = self.protocol_handler.format_message("PROGRAM", program_data)
        await self.named_pipe_client.send_data(formatted_message)
    
    def handle_connection_change(self, connection_id: str, status: str):
        """处理连接状态变更 - 基于ConnectionChange"""
        self.connection_manager.notify_connection_change(connection_id, status)
```

### 12.2 系统架构图 - 基于8种控件系统

```
┌─────────────────────────────────────────────────────────────────┐
│                        DNC系统架构图                            │
├─────────────────┬─────────────────┬─────────────────┬───────────┤
│   用户界面层     │   业务逻辑层     │   数据处理层     │  通信层    │
│                 │                 │                 │           │
│  - 主窗口       │  - 计算引擎     │  - CSV加载器    │  - 命名管道│
│  - 8种控件系统  │  - 关系验证     │  - 数据验证     │  - NC协议  │
│  - 事件处理     │  - 程序生成     │  - 编码处理     │  - 连接管理│
│                 │  - 精度控制     │  - 缓存管理     │           │
└─────────────────┴─────────────────┴─────────────────┴───────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                        数据存储层                                │
│                                                                 │
│  - Master数据文件 (CSV格式)                                     │
│  - 配置文件 (INI格式)                                          │
│  - 日志文件                                                    │
└─────────────────────────────────────────────────────────────────┘
```

### 12.3 动态控件管理技术细节

#### 12.3.1 控件生命周期管理
```python
class DynamicControlManager:
    def __init__(self):
        self.controls = {}
        self.control_templates = {}
        self.control_groups = {}
    
    def create_control(self, control_type: str, control_id: str, 
                      properties: Dict) -> QWidget:
        """动态创建控件 - 基于VB.NET控件创建方法"""
        if control_type == "TextBox":
            return self._create_text_box(control_id, properties)
        elif control_type == "Label":
            return self._create_label(control_id, properties)
        elif control_type == "Button":
            return self._create_button(control_id, properties)
        # 其他控件类型...
    
    def _create_text_box(self, control_id: str, properties: Dict) -> QLineEdit:
        """创建文本框 - 基于makeTextBox"""
        text_box = QLineEdit()
        text_box.setObjectName(control_id)
        text_box.setGeometry(properties.get('x', 0), 
                           properties.get('y', 0),
                           properties.get('width', 100),
                           properties.get('height', 25))
        
        # 绑定事件处理
        text_box.textChanged.connect(
            lambda text: self._handle_text_change(control_id, text)
        )
        
        self.controls[control_id] = text_box
        return text_box
    
    def manage_control_group(self, group_name: str, control_ids: List[str]):
        """管理控件组 - 基于控件分组逻辑"""
        self.control_groups[group_name] = control_ids
    
    def enable_control_group(self, group_name: str, enabled: bool):
        """启用/禁用控件组"""
        if group_name in self.control_groups:
            for control_id in self.control_groups[group_name]:
                if control_id in self.controls:
                    self.controls[control_id].setEnabled(enabled)
```

#### 12.3.2 事件处理系统
```python
class EventSystem:
    def __init__(self):
        self.event_handlers = {}
        self.text_change_handlers = {}
    
    def register_text_change_handler(self, control_id: str, handler: Callable):
        """注册文本变更处理器 - 基于txt_change"""
        self.text_change_handlers[control_id] = handler
    
    def _handle_text_change(self, control_id: str, new_text: str):
        """处理文本变更事件"""
        if control_id in self.text_change_handlers:
            handler = self.text_change_handlers[control_id]
            handler(new_text)
        
        # 触发计算引擎
        self._trigger_calculation(control_id, new_text)
    
    def _trigger_calculation(self, control_id: str, value: str):
        """触发计算 - 基于文本变更后的计算逻辑"""
        # 更新变量值
        self.variables[control_id] = value
        
        # 执行相关计算
        affected_calculations = self._get_affected_calculations(control_id)
        for calc_id in affected_calculations:
            self.calculation_engine.calculate(calc_id, self.variables)
```

## 13. 数据处理流程

### 13.1 基于VB.NET业务流程的完整处理流程

#### 13.1.1 Master数据加载流程
```python
class MasterDataLoader:
    def __init__(self):
        self.csv_loader = CSVLoader()
        self.encoding_detector = EncodingDetector()
        self.data_validator = DataValidator()
    
    def load_master_data(self) -> Dict[str, pd.DataFrame]:
        """加载Master数据 - 基于VB.NET数据加载流程"""
        master_data = {}
        
        # 1. 扫描master目录
        master_files = self._scan_master_directory()
        
        # 2. 分类处理文件
        for file_path in master_files:
            file_name = os.path.basename(file_path)
            
            # 3. 检测编码
            encoding = self.encoding_detector.detect_encoding(file_path)
            
            # 4. 分批读取大文件
            if self._is_large_file(file_path):
                data = self._batch_read_large_csv(file_path, encoding)
            else:
                data = pd.read_csv(file_path, encoding=encoding)
            
            # 5. 数据验证
            if self.data_validator.validate_data(data, file_name):
                master_data[file_name] = data
        
        return master_data
    
    def _scan_master_directory(self) -> List[str]:
        """扫描master目录 - 基于VB.NET目录扫描逻辑"""
        master_dir = "./data/master"
        csv_files = []
        
        for root, dirs, files in os.walk(master_dir):
            for file in files:
                if file.endswith('.csv'):
                    csv_files.append(os.path.join(root, file))
        
        return csv_files
    
    def _batch_read_large_csv(self, file_path: str, encoding: str, 
                             batch_size: int = 1000) -> pd.DataFrame:
        """分批读取大CSV文件"""
        chunks = []
        for chunk in pd.read_csv(file_path, encoding=encoding, chunksize=batch_size):
            chunks.append(chunk)
        
        return pd.concat(chunks, ignore_index=True)
```

#### 13.1.2 实时计算流程
```python
class RealTimeCalculationFlow:
    def __init__(self):
        self.calculation_engine = CalculationEngine()
        self.variable_manager = VariableManager()
        self.relation_validator = RelationValidator()
    
    def process_input_change(self, control_id: str, new_value: str):
        """处理输入变更 - 基于实时计算流程"""
        # 1. 输入验证
        if not self._validate_input(control_id, new_value):
            return
        
        # 2. 变量替换
        processed_value = self._apply_variable_substitution(control_id, new_value)
        
        # 3. 更新变量管理器
        self.variable_manager.update_variable(control_id, processed_value)
        
        # 4. 执行计算
        calculation_results = self.calculation_engine.calculate_all(
            self.variable_manager.get_all_variables()
        )
        
        # 5. 关系验证
        validation_passed = self.relation_validator.validate_all_relations(
            calculation_results
        )
        
        # 6. 更新显示
        if validation_passed:
            self._update_display(calculation_results)
        else:
            self._show_validation_errors()
    
    def _validate_input(self, control_id: str, value: str) -> bool:
        """验证输入 - 基于chkTxtIsNumeric等验证方法"""
        validation_rules = self._get_validation_rules(control_id)
        
        for rule in validation_rules:
            if not rule(value):
                return False
        
        return True
    
    def _apply_variable_substitution(self, control_id: str, value: str) -> Any:
        """应用变量替换 - 基于define.csv逻辑"""
        substitution_rules = self._get_substitution_rules(control_id)
        
        for before, after in substitution_rules.items():
            value = value.replace(before, after)
        
        return value
```

### 13.2 数据流详细说明

#### 13.2.1 输入到输出完整数据流
```
用户输入
    ↓
输入验证 (chkTxtIsNumeric, chkAddControls)
    ↓
变量替换 (define.csv逻辑)
    ↓
计算执行 (calc.csv表达式计算)
    ↓
关系验证 (relation.csv条件判断)
    ↓
精度控制 (四舍五入处理)
    ↓
程序生成 (prg.csv模板应用)
    ↓
NC协议格式化 (makeSendTxt)
    ↓
命名管道传输
    ↓
NC机接收执行
```

#### 13.2.2 错误处理流程
```python
class ErrorHandlingFlow:
    def __init__(self):
        self.error_handler = ValidationErrorHandler()
        self.logger = logging.getLogger(__name__)
    
    def handle_data_loading_error(self, file_path: str, error: Exception):
        """处理数据加载错误"""
        self.logger.error(f"数据加载失败: {file_path}, 错误: {error}")
        
        # 尝试修复编码问题
        if isinstance(error, UnicodeDecodeError):
            fixed_data = self._fix_encoding_issue(file_path)
            if fixed_data is not None:
                return fixed_data
        
        # 记录错误并返回空数据
        self.error_handler.add_error("data_loading", f"文件加载失败: {file_path}")
        return pd.DataFrame()
    
    def handle_calculation_error(self, expression: str, error: Exception):
        """处理计算错误"""
        self.logger.error(f"计算错误: {expression}, 错误: {error}")
        
        # 记录计算错误
        self.error_handler.add_error("calculation", f"表达式计算失败: {expression}")
        
        # 返回默认值
        return 0.0
    
    def _fix_encoding_issue(self, file_path: str) -> Optional[pd.DataFrame]:
        """修复编码问题"""
        encodings_to_try = ['shift_jis', 'cp932', 'latin1', 'iso-8859-1']
        
        for encoding in encodings_to_try:
            try:
                return pd.read_csv(file_path, encoding=encoding)
            except UnicodeDecodeError:
                continue
        
        return None
```

### 13.3 性能优化数据处理

#### 13.3.1 缓存机制
```python
class DataCache:
    def __init__(self, max_size: int = 1000):
        self.cache = {}
        self.max_size = max_size
        self.access_count = {}
    
    def get(self, key: str) -> Optional[Any]:
        """获取缓存数据"""
        if key in self.cache:
            self.access_count[key] = self.access_count.get(key, 0) + 1
            return self.cache[key]
        return None
    
    def set(self, key: str, value: Any):
        """设置缓存数据"""
        if len(self.cache) >= self.max_size:
            self._evict_least_used()
        
        self.cache[key] = value
        self.access_count[key] = 1
    
    def _evict_least_used(self):
        """淘汰最少使用的缓存项"""
        if not self.access_count:
            return
        
        min_key = min(self.access_count.items(), key=lambda x: x[1])[0]
        del self.cache[min_key]
        del self.access_count[min_key]
```

#### 13.3.2 预编译优化
```python
class ExpressionPrecompiler:
    def __init__(self):
        self.compiled_expressions = {}
    
    def precompile_expression(self, expression: str) -> Callable:
        """预编译表达式"""
        if expression in self.compiled_expressions:
            return self.compiled_expressions[expression]
        
        try:
            # 安全编译表达式
            compiled = compile(expression, '<string>', 'eval')
            self.compiled_expressions[expression] = compiled
            return compiled
        except Exception as e:
            logger.warning(f"表达式预编译失败: {expression}, 错误: {e}")
            return None
```

## 14. 部署和配置

### 14.1 系统配置管理

#### 14.1.1 配置文件结构
```ini
[system]
data_directory = ./data/master
log_level = INFO
batch_size = 1000
max_cache_size = 1000
default_encoding = utf-8

[communication]
pipe_name = DNC_Pipe
protocol_type = rexroth
timeout_seconds = 30

[calculation]
decimal_places = 4
enable_precompilation = true
enable_caching = true

[ui]
window_width = 1024
window_height = 768
theme = default
```

#### 14.1.2 环境配置检查
```python
class EnvironmentChecker:
    def check_system_requirements(self) -> Dict[str, bool]:
        """检查系统要求"""
        requirements = {
            'python_version': self._check_python_version(),
            'pandas_installed': self._check_pandas(),
            'pyqt_installed': self._check_pyqt(),
            'data_directory_exists': self._check_data_directory(),
            'master_files_exist': self._check_master_files()
        }
        return requirements
    
    def _check_python_version(self) -> bool:
        """检查Python版本"""
        import sys
        return sys.version_info >= (3, 8)
    
    def _check_data_directory(self) -> bool:
        """检查数据目录"""
        return os.path.exists('./data/master')
```

## 15. 测试策略

### 15.1 基于VB.NET功能的测试用例

#### 15.1.1 控件系统测试
```python
class ControlSystemTests:
    def test_load_control_creation(self):
        """测试Load控件创建"""
        control_manager = ControlManager()
        load_control = control_manager.create_control("Load", "test
# DNC系统开发详细文档

## 1. 项目概述

### 1.1 系统简介
DNC（Direct Numerical Control）系统是一个数控设备参数管理软件，用于从电脑直接传送参数到NC机的宏变量系统。该系统解决了传统NC机手动输入参数的时间和错误问题。

### 1.2 系统架构 - 基于VB.NET源码分析
- **原系统**: VB.NET DNC2.05 (基于Frm_main.vb主窗体)
- **新系统**: Python重写版本 (基于VB.NET源码完整重构)
- **系统构成**: PC + NC机 + LAN线 + DNC软件 + 命名管道通信
- **数据格式**: CSV文件存储Master数据 + 动态控件系统
- **核心架构**: 8种控件系统 + 计算引擎 + 通信模块 + 数据处理

## 2. 系统功能模块

### 2.1 核心功能模块

#### 2.1.1 产品型号管理
- 产品类型定义 (type_define.csv)
- 程序类型映射 (type_prg.csv)
- 产品参数配置 (load.csv)

#### 2.1.2 参数计算引擎
- 几何参数计算 (calc.csv)
- 关系验证逻辑 (relation.csv)
- 变量定义管理 (define.csv)

#### 2.1.3 程序生成器
- 程序定义 (prg.csv)
- 控制参数 (cntrl_rex.csv)
- 选择逻辑 (select.csv)

### 2.2 数据流处理

#### 2.2.1 输入处理
```python
输入 → 参数验证 → 计算引擎 → 程序生成 → 输出
```

#### 2.2.2 宏变量映射
- #500-#600: 系统参数
- #1-#100: 用户参数
- 特殊变量: 计算中间值

## 3. 数据结构详细说明

### 3.1 核心数据文件

#### 3.1.1 type_define.csv (产品类型定义)
- **文件大小**: 988.60 KB
- **数据结构**:
  - NO: 序号
  - TYPE: 产品型号 (如: GPA18GT15040-A)
  - DEFINE1: 定义1
  - DEFINE2: 定义2

#### 3.1.2 type_prg.csv (程序类型映射)
- **文件大小**: 480.92 KB
- **数据结构**:
  - NO: 序号
  - prg1: 程序1编号
  - prg2: 程序2编号

#### 3.1.3 load.csv (主数据文件)
- **文件大小**: 8.5 MB
- **数据结构**:
  - NO: 序号
  - TYPE: 产品型号
  - DRAWING: 图纸文件
  - DISPFLG: 显示标志
  - #1-#12: 定义变量
  - #500-#550: 系统参数
  - #602-#603: 开关控制

#### 3.1.4 cntrl_rex.csv (参数控制)
- **文件大小**: 1.10 KB
- **数据结构**:
  - PARAMETER: 参数名称 (如: Work_plan, Teeth_num)
  - DATATYPE: 数据类型 (int, real, boolean)
  - MACRO: 宏变量映射 (如: #510, #511)

### 3.2 计算逻辑文件

#### 3.2.1 calc.csv (计算定义)
```csv
DEFINE,1,2,3,4,5,6,7,8,9,10,11,12,13
calcABC,=,#528,-,#510,*,2,NaN,NaN,NaN,NaN,NaN,NaN,NaN
calcABCD,=,(,#528,-,#513,),/,2.0,NaN,NaN,NaN,NaN,NaN
```

#### 3.2.2 relation.csv (关系验证)
```csv
DEFINE,VALUE,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28
relationHPN,#1,and,#1,>,0.0,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN
```

#### 3.2.3 define.csv (变量定义)
```csv
DEFINE,STR,BEFORE,AFTER,CHNGVL,CALC
defineP,P,P0,0,NaN,NaN
defineH,H,H0,0,NaN,NaN
```

## 4. 技术架构设计

### 4.1 系统架构图

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   用户界面层     │    │   业务逻辑层     │    │   数据访问层     │
│                 │    │                 │    │                 │
│  - 主窗口       │◄──►│  - 参数计算     │◄──►│  - CSV处理器    │
│  - 输入表单     │    │  - 程序生成     │    │  - 数据验证     │
│  - 结果显示     │    │  - 关系验证     │    │  - 编码处理     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 4.2 核心类设计

#### 4.2.1 DataManager (数据管理器)
```python
class DataManager:
    def load_master_data(self) -> Dict[str, pd.DataFrame]
    def batch_read_large_csv(self, file_path: str, batch_size: int = 1000)
    def validate_data_integrity(self) -> bool
    def fix_encoding_issues(self, file_path: str) -> pd.DataFrame
```

#### 4.2.2 CalculationEngine (计算引擎)
```python
class CalculationEngine:
    def calculate_parameters(self, input_data: Dict) -> Dict
    def validate_relations(self, calculated_data: Dict) -> bool
    def generate_macro_variables(self, params: Dict) -> List[str]
```

#### 4.2.3 ProgramGenerator (程序生成器)
```python
class ProgramGenerator:
    def generate_nc_program(self, product_type: str, params: Dict) -> str
    def apply_program_template(self, template: str, variables: Dict) -> str
    def validate_program_syntax(self, program: str) -> bool
```

## 5. 数据处理流程

### 5.1 数据加载流程
1. **扫描目录**: 递归扫描master目录下的所有CSV文件
2. **分类处理**: 根据文件大小分类为小文件和大文件
3. **编码检测**: 自动检测文件编码 (UTF-8, Shift-JIS, CP932)
4. **分批读取**: 大文件使用分批读取机制
5. **数据验证**: 检查数据完整性和一致性

### 5.2 参数计算流程
1. **输入验证**: 验证用户输入参数的有效性
2. **变量替换**: 根据define.csv进行变量替换
3. **计算执行**: 执行calc.csv中定义的计算逻辑
4. **关系验证**: 验证relation.csv中定义的关系条件
5. **结果生成**: 生成最终的宏变量值

## 6. 文件编码处理

### 6.1 编码问题文件列表
- `ini.csv`: 958字节，编码问题
- `math.csv`: 1.08KB，编码问题  
- `cntrl.csv`: 1.38KB，编码问题
- `switch.csv`: 106字节，编码问题

### 6.2 编码处理策略
```python
def detect_encoding(file_path: str) -> str:
    encodings = ['utf-8', 'shift_jis', 'cp932', 'latin1']
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as f:
                f.read()
            return encoding
        except UnicodeDecodeError:
            continue
    return 'unknown'
```

## 7. 性能优化策略

### 7.1 大文件处理优化
- **分批读取**: 使用pandas的chunksize参数
- **内存管理**: 及时释放不需要的数据
- **缓存机制**: 缓存频繁访问的数据

### 7.2 计算优化
- **预编译**: 预编译计算表达式
- **并行处理**: 使用多线程处理独立计算
- **结果缓存**: 缓存重复计算结果

## 8. 错误处理机制

### 8.1 数据验证错误
- 文件不存在错误
- 编码错误处理
- 数据格式错误
- 完整性检查失败

### 8.2 计算错误
- 除零错误处理
- 变量未定义错误
- 关系验证失败
- 程序生成错误

## 9. 部署和配置

### 9.1 环境要求
- Python 3.8+
- pandas >= 1.3.0
- PyQt5/PySide6
- 操作系统: Windows 10/11

### 9.2 配置文件
```ini
[system]
data_directory = ./data/master
log_level = INFO
batch_size = 1000

[encoding]
default_encoding = utf-8
fallback_encodings = shift_jis,cp932,latin1
```

## 10. 测试策略

### 10.1 单元测试
- 数据加载测试
- 计算逻辑测试
- 程序生成测试
- 错误处理测试

### 10.2 集成测试
- 端到端流程测试
- 性能测试
- 兼容性测试

## 11. 功能模块详细设计

### 11.1 控件系统详细设计

#### 11.1.1 8种核心控件类型实现

**Load控件 (makeCntrlLoad)**
```python
class LoadControl:
    def __init__(self, data_source: str, field_mapping: Dict):
        self.data_source = data_source
        self.field_mapping = field_mapping
        self.data_table = None
    
    def load_data(self) -> pd.DataFrame:
        """从CSV文件加载数据"""
        try:
            self.data_table = pd.read_csv(self.data_source, encoding='utf-8')
            return self.data_table
        except Exception as e:
            logger.error(f"加载数据失败: {e}")
            return None
    
    def validate_data(self) -> bool:
        """验证数据完整性"""
        required_fields = ['NO', 'TYPE', 'DRAWING']
        return all(field in self.data_table.columns for field in required_fields)
```

**Input控件 (makeCntrlInput)**
```python
class InputControl:
    def __init__(self, control_id: str, data_type: str, validation_rules: Dict):
        self.control_id = control_id
        self.data_type = data_type
        self.validation_rules = validation_rules
        self.value = None
    
    def handle_text_change(self, new_value: str):
        """处理文本变更事件"""
        if self.validate_input(new_value):
            self.value = self.convert_value(new_value)
            self.trigger_calculation()
    
    def validate_input(self, value: str) -> bool:
        """验证输入值"""
        if self.data_type == 'numeric':
            return self._validate_numeric(value)
        elif self.data_type == 'string':
            return self._validate_string(value)
        return False
```

#### 11.1.2 基础控件创建方法Python实现

**文本框创建 (makeTextBox)**
```python
def create_text_box(name: str, location: Tuple[int, int], size: Tuple[int, int], 
                   text_change_handler: Callable) -> QLineEdit:
    """创建文本框控件"""
    text_box = QLineEdit()
    text_box.setObjectName(name)
    text_box.setGeometry(location[0], location[1], size[0], size[1])
    text_box.textChanged.connect(text_change_handler)
    return text_box
```

**标签创建 (makeLabel)**
```python
def create_label(name: str, text: str, location: Tuple[int, int], 
                size: Tuple[int, int]) -> QLabel:
    """创建标签控件"""
    label = QLabel(text)
    label.setObjectName(name)
    label.setGeometry(location[0], location[1], size[0], size[1])
    return label
```

#### 11.1.3 动态控件管理技术细节

**控件生命周期管理**
```python
class ControlManager:
    def __init__(self):
        self.controls = {}
        self.control_groups = {}
    
    def add_control(self, control_id: str, control: QWidget):
        """添加控件到管理器"""
        self.controls[control_id] = control
    
    def remove_control(self, control_id: str):
        """移除控件"""
        if control_id in self.controls:
            self.controls[control_id].deleteLater()
            del self.controls[control_id]
    
    def enable_controls(self, control_ids: List[str], enabled: bool):
        """批量启用/禁用控件"""
        for control_id in control_ids:
            if control_id in self.controls:
                self.controls[control_id].setEnabled(enabled)
```

### 11.2 计算引擎详细设计

#### 11.2.1 表达式计算具体算法

**表达式解析器 (getCalcResult)**
```python
class ExpressionCalculator:
    def __init__(self):
        self.variables = {}
        self.functions = {
            'MAX': max,
            'MIN': min,
            'ROUND': round,
            'ABS': abs
        }
    
    def calculate(self, expression: str, variables: Dict) -> float:
        """计算表达式值"""
        try:
            # 变量替换
            expr = self._replace_variables(expression, variables)
            # 表达式求值
            result = eval(expr, {"__builtins__": None}, self.functions)
            return float(result)
        except Exception as e:
            logger.error(f"表达式计算错误: {expression}, 错误: {e}")
            return 0.0
    
    def _replace_variables(self, expression: str, variables: Dict) -> str:
        """替换表达式中的变量"""
        for var_name, var_value in variables.items():
            expression = expression.replace(f"@{var_name}", str(var_value))
        return expression
```

#### 11.2.2 条件判断系统实现逻辑

**关系判断引擎 (judgeRelation)**
```python
class RelationJudge:
    def judge(self, condition: str, left_value: Any, right_value: Any) -> bool:
        """判断关系条件"""
        operators = {
            '=': lambda x, y: x == y,
            '<>': lambda x, y: x != y,
            '>': lambda x, y: x > y,
            '<': lambda x, y: x < y,
            '>=': lambda x, y: x >= y,
            '<=': lambda x, y: x <= y
        }
        
        for op, func in operators.items():
            if op in condition:
                return func(left_value, right_value)
        
        return False
```

#### 11.2.3 精度控制技术方案

**数值精度管理**
```python
class PrecisionController:
    def __init__(self, decimal_places: int = 4):
        self.decimal_places = decimal_places
    
    def round_value(self, value: float) -> float:
        """四舍五入处理"""
        return round(value, self.decimal_places)
    
    def format_display(self, value: float) -> str:
        """格式化显示值"""
        return f"{value:.{self.decimal_places}f}".rstrip('0').rstrip('.')
```

### 11.3 数据处理模块详细设计

#### 11.3.1 文件加载系统实现细节

**CSV文件加载器 (LoadFileToTBL)**
```python
class CSVLoader:
    def __init__(self, encoding_detector: EncodingDetector):
        self.encoding_detector = encoding_detector
    
    def load_file(self, file_path: str) -> pd.DataFrame:
        """加载CSV文件"""
        encoding = self.encoding_detector.detect_encoding(file_path)
        
        try:
            df = pd.read_csv(file_path, encoding=encoding)
            return self._clean_data(df)
        except Exception as e:
            logger.error(f"文件加载失败: {file_path}, 错误: {e}")
            return pd.DataFrame()
    
    def _clean_data(self, df: pd.DataFrame) -> pd.DataFrame:
        """数据清理"""
        # 移除空行
        df = df.dropna(how='all')
        # 处理NaN值
        df = df.fillna('')
        return df
```

#### 11.3.2 数据搜索功能算法设计

**表搜索引擎 (searchT_relation)**
```python
class TableSearcher:
    def __init__(self, data_tables: Dict[str, pd.DataFrame]):
        self.data_tables = data_tables
        self.search_cache = {}
    
    def search_table(self, table_name: str, search_criteria: Dict) -> pd.DataFrame:
        """搜索数据表"""
        cache_key = f"{table_name}_{str(search_criteria)}"
        if cache_key in self.search_cache:
            return self.search_cache[cache_key]
        
        if table_name not in self.data_tables:
            return pd.DataFrame()
        
        table = self.data_tables[table_name]
        result = table.copy()
        
        for column, value in search_criteria.items():
            if column in table.columns:
                result = result[result[column] == value]
        
        self.search_cache[cache_key] = result
        return result
```

#### 11.3.3 数据操作技术实现

**数据转换器 (searchT_ChngValue)**
```python
class DataConverter:
    def __init__(self, conversion_rules: Dict):
        self.conversion_rules = conversion_rules
    
    def convert_value(self, value: Any, conversion_type: str) -> Any:
        """转换数据值"""
        if conversion_type in self.conversion_rules:
            rule = self.conversion_rules[conversion_type]
            return rule(value)
        return value
    
    def add_conversion_rule(self, conversion_type: str, rule: Callable):
        """添加转换规则"""
        self.conversion_rules[conversion_type] = rule
```

### 11.4 通信模块详细设计

#### 11.4.1 通信协议支持技术实现

**NC通信协议处理器 (makeSendTxt)**
```python
class NCProtocolHandler:
    def __init__(self, protocol_type: str):
        self.protocol_type = protocol_type
        self.message_formatters = {
            'rexroth': self._format_rexroth_message,
            'brother': self._format_brother_message
        }
    
    def format_message(self, command: str, parameters: Dict) -> str:
        """格式化NC命令消息"""
        if self.protocol_type in self.message_formatters:
            return self.message_formatters[self.protocol_type](command, parameters)
        return command
    
    def _format_rexroth_message(self, command: str, parameters: Dict) -> str:
        """格式化Rexroth协议消息"""
        # Rexroth协议特定格式化逻辑
        return f"{command} {self._format_parameters(parameters)}"
    
    def _format_brother_message(self, command: str, parameters: Dict) -> str:
        """格式化Brother协议消息"""
        # Brother协议特定格式化逻辑
        return f"{command};{self._format_parameters(parameters)}"
```

#### 11.4.2 进程间通信机制设计

**连接状态管理器 (ConnectionChange)**
```python
class ConnectionManager:
    def __init__(self):
        self.connections = {}
        self.connection_callbacks = []
    
    def add_connection(self, connection_id: str, connection: object):
        """添加连接"""
        self.connections[connection_id] = connection
        self._notify_connection_change(connection_id, 'connected')
    
    def remove_connection(self, connection_id: str):
        """移除连接"""
        if connection_id in self.connections:
            del self.connections[connection_id]
            self._notify_connection_change(connection_id, 'disconnected')
    
    def _notify_connection_change(self, connection_id: str, status: str):
        """通知连接状态变更"""
        for callback in self.connection_callbacks:
            callback(connection_id, status)
```

#### 11.4.3 命名管道通信具体实现

**异步命名管道客户端 (NamedPipeAsyncClient)**
```python
class NamedPipeClient:
    def __init__(self, pipe_name: str):
        self.pipe_name = pipe_name
        self.connected = False
        self.data_received_callbacks = []
    
    async def connect(self):
        """异步连接命名管道"""
        try:
            # Windows命名管道连接实现
            self.connected = True
            await self._start_listening()
        except Exception as e:
            logger.error(f"命名管道连接失败: {e}")
            self.connected = False
    
    async def send_data(self, data: str):
        """异步发送数据"""
        if self.connected:
            # 实现数据发送逻辑
            pass
    
    def add_data_received_callback(self, callback: Callable):
        """添加数据接收回调"""
        self.data_received_callbacks.append(callback)
```

### 11.5 用户界面交互详细设计

#### 11.5.1 事件处理系统架构设计

**事件分发器**
```python
class EventDispatcher:
    def __init__(self):
        self.event_handlers = {}
    
    def register_handler(self, event_type: str, handler: Callable):
        """注册事件处理器"""
        if event_type not in self.event_handlers:
            self.event_handlers[event_type] = []
        self.event_handlers[event_type].append(handler)
    
    def dispatch_event(self, event_type: str, event_data: Dict):
        """分发事件"""
        if event_type in self.event_handlers:
            for handler in self.event_handlers[event_type]:
                try:
                    handler(event_data)
                except Exception as e:
                    logger.error(f"事件处理错误: {e}")
```

#### 11.5.2 输入处理技术实现

**文本变更处理器 (txt_change)**
```python
class TextChangeHandler:
    def __init__(self, validation_rules: Dict, calculation_trigger: Callable):
        self.validation_rules = validation_rules
        self.calculation_trigger = calculation_trigger
        self.change_event_flag = False
    
    def handle_text_change(self, control_id: str, new_text: str):
        """处理文本变更"""
        if self.change_event_flag:
            return
        
        self.change_event_flag = True
        
        try:
            # 数据验证
            if self._validate_text(control_id, new_text):
                # 触发计算
                self.calculation_trigger(control_id, new_text)
        finally:
            self.change_event_flag = False
    
    def _validate_text(self, control_id: str, text: str) -> bool:
        """验证文本内容"""
        if control_id in self.validation_rules:
            rule = self.validation_rules[control_id]
            return rule(text)
        return True
```

#### 11.5.3 操作员管理功能设计

**操作员管理器 (TB_OpeID_TextChanged)**
```python
class OperatorManager:
    def __init__(self):
        self.current_operator = None
        self.operator_database = {}
    
    def set_operator(self, operator_id: str):
        """设置当前操作员"""
        if operator_id in self.operator_database:
            self.current_operator = self.operator_database[operator_id]
            logger.info(f"操作员已切换: {self.current_operator.name}")
        else:
            logger.warning(f"未知操作员ID: {operator_id}")
    
    def get_operator_name(self, operator_id: str) -> str:
        """获取操作员名称"""
        if operator_id in self.operator_database:
            return self.operator_database[operator_id].name
        return "未知操作员"
```

### 11.6 数据验证模块详细设计

#### 11.6.1 验证方法具体实现

**数值验证器 (chkTxtIsNumeric)**
```python
class NumericValidator:
    def validate(self, text: str, min_value: float = None, 
                max_value: float = None, decimal_places: int = None) -> bool:
        """验证数值文本"""
        try:
            value = float(text)
            
            if min_value is not None and value < min_value:
                return False
            
            if max_value is not None and value > max_value:
                return False
            
            if decimal_places is not None:
                # 检查小数位数
                decimal_part = str(value).split('.')
                if len(decimal_part) > 1 and len(decimal_part[1]) > decimal_places:
                    return False
            
            return True
        except ValueError:
            return False
```

#### 11.6.2 验证规则技术设计

**业务规则验证器 (chkAddControls)**
```python
class BusinessRuleValidator:
    def __init__(self, validation_rules: Dict):
        self.validation_rules = validation_rules
    
    def validate_controls(self, control_values: Dict) -> Dict[str, str]:
        """验证控件组业务规则"""
        errors = {}
        
        for rule_name, rule in self.validation_rules.items():
            if not rule(control_values):
                errors[rule_name] = f"业务规则验证失败: {rule_name}"
        
        return errors
    
    def add_validation_rule(self, rule_name: str, rule: Callable):
        """添加验证规则"""
        self.validation_rules[rule_name] = rule
```

#### 11.6.3 错误处理机制

**验证错误处理器**
```python
class ValidationErrorHandler:
    def __init__(self):
        self.error_messages = {}
    
    def add_error(self, control_id: str, message: str):
        """添加错误信息"""
        if control_id not in self.error_messages:
            self.error_messages[control_id] = []
        self.error_messages[control_id].append(message)
    
    def clear_errors(self, control_id: str = None):
        """清除错误信息"""
        if control_id:
            if control_id in self.error_messages:
                del self.error_messages[control_id]
        else:
            self.error_messages.clear()
    
    def has_errors(self) -> bool:
        """检查是否有错误"""
        return len(self.error_messages) > 0
```

### 11.7 系统管理模块详细设计

#### 11.7.1 初始化系统技术实现

**系统初始化器 (Frm_main_Load)**
```python
class SystemInitializer:
    def __init__(self, config_manager: ConfigManager, data_manager: DataManager):
        self.config_manager = config_manager
        self.data_manager = data_manager
        self.initialization_steps = [
            self._load_configuration,
            self._load_master_data,
            self._initialize_ui,
            self._setup_communication
        ]
    
    async def initialize_system(self):
        """异步初始化系统"""
        for step in self.initialization_steps:
            try:
                await step()
            except Exception as e:
                logger.error(f"初始化步骤失败: {e}")
                raise
    
    async def _load_configuration(self):
        """加载系统配置"""
        self.config = await self.config_manager.load_config()
    
    async def _load_master_data(self):
        """加载Master数据"""
        self.master_data = await self.data_manager.load_master_data()
    
    async def _initialize_ui(self):
        """初始化用户界面"""
        # 创建主窗口和控件
        pass
    
    async def _setup_communication(self):
        """设置通信连接"""
        # 初始化NC通信和命名管道
        pass
```

#### 11.7.2 显示管理功能设计

**控件状态管理器 (ControlStateManager)**
```python
class ControlStateManager:
    def __init__(self):
        self.control_states = {}
        self.control_groups = {}
    
    def set_controls_enabled(self, control_ids: List[str], enabled: bool):
        """设置控件启用状态"""
        for control_id in control_ids:
            if control_id in self.control_states:
                self.control_states[control_id].setEnabled(enabled)
    
    def set_controls_visible(self, control_ids: List[str], visible: bool):
        """设置控件可见性"""
        for control_id in control_ids:
            if control_id in self.control_states:
                self.control_states[control_id].setVisible(visible)
    
    def add_control_group(self, group_name: str, control_ids: List[str]):
        """添加控件组"""
        self.control_groups[group_name] = control_ids
    
    def set_group_enabled(self, group_name: str, enabled: bool):
        """设置控件组启用状态"""
        if group_name in self.control_groups:
            self.set_controls_enabled(self.control_groups[group_name], enabled)
```

#### 11.7.3 配置管理技术方案

**INI配置管理器 (IniConfigManager)**
```python
class IniConfigManager:
    def __init__(self, ini_file_path: str):
        self.ini_file_path = ini_file_path
        self.config = {}
    
    def load_config(self) -> Dict:
        """加载INI配置文件"""
        config = configparser.ConfigParser()
        config.read(self.ini_file_path, encoding='utf-8')
        
        for section in config.sections():
            self.config[section] = dict(config.items(section))
        
        return self.config
    
    def save_config(self, config: Dict):
        """保存INI配置文件"""
        config_parser = configparser.ConfigParser()
        
        for section, options in config.items():
            config_parser[section] = options
        
        with open(self.ini_file_path, 'w', encoding='utf-8') as f:
            config_parser.write(f)
    
    def get_value(self, section: str, key: str, default=None):
        """获取配置值"""
        return self.config.get(section, {}).get(key, default)
```

### 11.8 工具方法详细设计

#### 11.8.1 字符串处理技术实现

**字符串工具类 (StringUtils)**
```python
class StringUtils:
    @staticmethod
    def len_b(text: str) -> int:
        """计算字符串字节长度（兼容VB.NET的LenB函数）"""
        return len(text.encode('utf-8'))
    
    @staticmethod
    def make_format_str(format_pattern: str, *args) -> str:
        """创建格式化字符串"""
        try:
            return format_pattern.format(*args)
        except Exception as e:
            logger.error(f"字符串格式化失败: {e}")
            return format_pattern
    
    @staticmethod
    def to_half_adjust(value: float, decimal_places: int = 0) -> float:
        """四舍五入处理（兼容VB.NET的ToHalfAdjust）"""
        factor = 10 ** decimal_places
        return round(value * factor) / factor
    
    @staticmethod
    def get_operator_name(operator_id: str) -> str:
        """获取操作员名称"""
        operator_map = {
            '001': '操作员A',
            '002': '操作员B',
            '003': '操作员C'
        }
        return operator_map.get(operator_id, '未知操作员')
```

#### 11.8.2 系统工具功能设计

**系统工具类 (SystemUtils)**
```python
class SystemUtils:
    @staticmethod
    def get_all_controls(parent_widget: QWidget) -> List[QWidget]:
        """获取所有子控件"""
        controls = []
        
        def collect_controls(widget):
            for child in widget.children():
                if isinstance(child, QWidget):
                    controls.append(child)
                    collect_controls(child)
        
        collect_controls(parent_widget)
        return controls
    
    @staticmethod
    def change_form_size(form: QWidget, width: int, height: int):
        """改变窗体大小"""
        form.resize(width, height)
    
    @staticmethod
    def show_info_form(title: str, message: str):
        """显示信息窗体"""
        msg_box = QMessageBox()
        msg_box.setWindowTitle(title)
        msg_box.setText(message)
        msg_box.setIcon(QMessageBox.Information)
        msg_box.exec_()
```

#### 11.8.3 数值处理工具

**公差计算器 (ToleranceCalculator)**
```python
class ToleranceCalculator:
    @staticmethod
    def get_shafts_tolerance(diameter: float, tolerance_class: str) -> Tuple[float, float]:
        """获取轴公差"""
        tolerance_tables = {
            'h6': {10: (-0.009, 0), 18: (-0.011, 0), 30: (-0.013, 0)},
            'h7': {10: (-0.015, 0), 18: (-0.018, 0), 30: (-0.021, 0)},
            'h8': {10: (-0.022, 0), 18: (-0.027, 0), 30: (-0.033, 0)}
        }
        
        for max_diameter, tolerance in tolerance_tables.get(tolerance_class, {}).items():
            if diameter <= max_diameter:
                return tolerance
        
        return (0, 0)
    
    @staticmethod
    def get_length_tolerance(length: float, tolerance_class: str) -> Tuple[float, float]:
        """获取长度公差"""
        tolerance_tables = {
            'fine': {100: (-0.1, 0.1), 400: (-0.2, 0.2), 1000: (-0.3, 0.3)},
            'medium': {100: (-0.2, 0.2), 400: (-0.4, 0.4), 1000: (-0.6, 0.6)},
            'coarse': {100: (-0.4, 0.4), 400: (-0.8, 0.8), 1000: (-1.2, 1.2)}
        }
        
        for max_length, tolerance in tolerance_tables.get(tolerance_class, {}).items():
            if length <= max_length:
                return tolerance
        
        return (0, 0)
```

## 12. 技术架构设计

### 12.1 核心类设计 - 基于VB.NET源码分析

#### 12.1.1 主窗体类 (Frm_main)
```python
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.control_manager = ControlManager()
        self.data_manager = DataManager()
        self.calculation_engine = CalculationEngine()
        self.communication_manager = CommunicationManager()
        
        # 基于VB.NET Frm_main.vb的初始化逻辑
        self._initialize_ui()
        self._load_master_data()
        self._setup_communication()
    
    def _initialize_ui(self):
        """初始化用户界面 - 基于VB.NET Frm_main_Load"""
        # 创建8种控件系统
        self._create_load_controls()
        self._create_input_controls()
        self._create_calc_controls()
        self._create_relation_controls()
        self._create_define_controls()
        self._create_select_controls()
        self._create_switch_controls()
        self._create_preset_controls()
        
        # 设置窗体属性
        self.setWindowTitle("DNC系统")
        self.resize(1024, 768)
    
    def _create_load_controls(self):
        """创建Load控件 - 基于makeCntrlLoad"""
        # 实现Load控件创建逻辑
        pass
    
    def _create_input_controls(self):
        """创建Input控件 - 基于makeCntrlInput"""
        # 实现Input控件创建逻辑
        pass
```

#### 12.1.2 计算引擎类 (CalculationEngine)
```python
class CalculationEngine:
    def __init__(self):
        self.expression_calculator = ExpressionCalculator()
        self.relation_judge = RelationJudge()
        self.precision_controller = PrecisionController()
    
    def calculate_parameters(self, input_data: Dict) -> Dict:
        """计算参数 - 基于getCalcResult"""
        results = {}
        
        # 执行calc.csv中定义的计算
        for calc_name, calc_expression in self.calc_definitions.items():
            result = self.expression_calculator.calculate(calc_expression, input_data)
            results[calc_name] = self.precision_controller.round_value(result)
        
        return results
    
    def validate_relations(self, calculated_data: Dict) -> bool:
        """验证关系 - 基于judgeRelation"""
        for relation_name, relation_condition in self.relation_definitions.items():
            if not self.relation_judge.judge(relation_condition, calculated_data):
                return False
        return True
```

#### 12.1.3 通信管理器类 (CommunicationManager)
```python
class CommunicationManager:
    def __init__(self):
        self.named_pipe_client = NamedPipeClient("DNC_Pipe")
        self.protocol_handler = NCProtocolHandler("rexroth")
        self.connection_manager = ConnectionManager()
    
    async def send_to_nc_machine(self, program_data: str):
        """发送数据到NC机 - 基于makeSendTxt"""
        formatted_message = self.protocol_handler.format_message("PROGRAM", program_data)
        await self.named_pipe_client.send_data(formatted_message)
    
    def handle_connection_change(self, connection_id: str, status: str):
        """处理连接状态变更 - 基于ConnectionChange"""
        self.connection_manager.notify_connection_change(connection_id, status)
```

### 12.2 系统架构图 - 基于8种控件系统

```
┌─────────────────────────────────────────────────────────────────┐
│                        DNC系统架构图                            │
├─────────────────┬─────────────────┬─────────────────┬───────────┤
│   用户界面层     │   业务逻辑层     │   数据处理层     │  通信层    │
│                 │                 │                 │           │
│  - 主窗口       │  - 计算引擎     │  - CSV加载器    │  - 命名管道│
│  - 8种控件系统  │  - 关系验证     │  - 数据验证     │  - NC协议  │
│  - 事件处理     │  - 程序生成     │  - 编码处理     │  - 连接管理│
│                 │  - 精度控制     │  - 缓存管理     │           │
└─────────────────┴─────────────────┴─────────────────┴───────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                        数据存储层                                │
│                                                                 │
│  - Master数据文件 (CSV格式)                                     │
│  - 配置文件 (INI格式)                                          │
│  - 日志文件                                                    │
└─────────────────────────────────────────────────────────────────┘
```

### 12.3 动态控件管理技术细节

#### 12.3.1 控件生命周期管理
```python
class DynamicControlManager:
    def __init__(self):
        self.controls = {}
        self.control_templates = {}
        self.control_groups = {}
    
    def create_control(self, control_type: str, control_id: str, 
                      properties: Dict) -> QWidget:
        """动态创建控件 - 基于VB.NET控件创建方法"""
        if control_type == "TextBox":
            return self._create_text_box(control_id, properties)
        elif control_type == "Label":
            return self._create_label(control_id, properties)
        elif control_type == "Button":
            return self._create_button(control_id, properties)
        # 其他控件类型...
    
    def _create_text_box(self, control_id: str, properties: Dict) -> QLineEdit:
        """创建文本框 - 基于makeTextBox"""
        text_box = QLineEdit()
        text_box.setObjectName(control_id)
        text_box.setGeometry(properties.get('x', 0), 
                           properties.get('y', 0),
                           properties.get('width', 100),
                           properties.get('height', 25))
        
        # 绑定事件处理
        text_box.textChanged.connect(
            lambda text: self._handle_text_change(control_id, text)
        )
        
        self.controls[control_id] = text_box
        return text_box
    
    def manage_control_group(self, group_name: str, control_ids: List[str]):
        """管理控件组 - 基于控件分组逻辑"""
        self.control_groups[group_name] = control_ids
    
    def enable_control_group(self, group_name: str, enabled: bool):
        """启用/禁用控件组"""
        if group_name in self.control_groups:
            for control_id in self.control_groups[group_name]:
                if control_id in self.controls:
                    self.controls[control_id].setEnabled(enabled)
```

#### 12.3.2 事件处理系统
```python
class EventSystem:
    def __init__(self):
        self.event_handlers = {}
        self.text_change_handlers = {}
    
    def register_text_change_handler(self, control_id: str, handler: Callable):
        """注册文本变更处理器 - 基于txt_change"""
        self.text_change_handlers[control_id] = handler
    
    def _handle_text_change(self, control_id: str, new_text: str):
        """处理文本变更事件"""
        if control_id in self.text_change_handlers:
            handler = self.text_change_handlers[control_id]
            handler(new_text)
        
        # 触发计算引擎
        self._trigger_calculation(control_id, new_text)
    
    def _trigger_calculation(self, control_id: str, value: str):
        """触发计算 - 基于文本变更后的计算逻辑"""
        # 更新变量值
        self.variables[control_id] = value
        
        # 执行相关计算
        affected_calculations = self._get_affected_calculations(control_id)
        for calc_id in affected_calculations:
            self.calculation_engine.calculate(calc_id, self.variables)
```

## 13. 数据处理流程

### 13.1 基于VB.NET业务流程的完整处理流程

#### 13.1.1 Master数据加载流程
```python
class MasterDataLoader:
    def __init__(self):
        self.csv_loader = CSVLoader()
        self.encoding_detector = EncodingDetector()
        self.data_validator = DataValidator()
    
    def load_master_data(self) -> Dict[str, pd.DataFrame]:
        """加载Master数据 - 基于VB.NET数据加载流程"""
        master_data = {}
        
        # 1. 扫描master目录
        master_files = self._scan_master_directory()
        
        # 2. 分类处理文件
        for file_path in master_files:
            file_name = os.path.basename(file_path)
            
            # 3. 检测编码
            encoding = self.encoding_detector.detect_encoding(file_path)
            
            # 4. 分批读取大文件
            if self._is_large_file(file_path):
                data = self._batch_read_large_csv(file_path, encoding)
            else:
                data = pd.read_csv(file_path, encoding=encoding)
            
            # 5. 数据验证
            if self.data_validator.validate_data(data, file_name):
                master_data[file_name] = data
        
        return master_data
    
    def _scan_master_directory(self) -> List[str]:
        """扫描master目录 - 基于VB.NET目录扫描逻辑"""
        master_dir = "./data/master"
        csv_files = []
        
        for root, dirs, files in os.walk(master_dir):
            for file in files:
                if file.endswith('.csv'):
                    csv_files.append(os.path.join(root, file))
        
        return csv_files
    
    def _batch_read_large_csv(self, file_path: str, encoding: str, 
                             batch_size: int = 1000) -> pd.DataFrame:
        """分批读取大CSV文件"""
        chunks = []
        for chunk in pd.read_csv(file_path, encoding=encoding, chunksize=batch_size):
            chunks.append(chunk)
        
        return pd.concat(chunks, ignore_index=True)
```

#### 13.1.2 实时计算流程
```python
class RealTimeCalculationFlow:
    def __init__(self):
        self.calculation_engine = CalculationEngine()
        self.variable_manager = VariableManager()
        self.relation_validator = RelationValidator()
    
    def process_input_change(self, control_id: str, new_value: str):
        """处理输入变更 - 基于实时计算流程"""
        # 1. 输入验证
        if not self._validate_input(control_id, new_value):
            return
        
        # 2. 变量替换
        processed_value = self._apply_variable_substitution(control_id, new_value)
        
        # 3. 更新变量管理器
        self.variable_manager.update_variable(control_id, processed_value)
        
        # 4. 执行计算
        calculation_results = self.calculation_engine.calculate_all(
            self.variable_manager.get_all_variables()
        )
        
        # 5. 关系验证
        validation_passed = self.relation_validator.validate_all_relations(
            calculation_results
        )
        
        # 6. 更新显示
        if validation_passed:
            self._update_display(calculation_results)
        else:
            self._show_validation_errors()
    
    def _validate_input(self, control_id: str, value: str) -> bool:
        """验证输入 - 基于chkTxtIsNumeric等验证方法"""
        validation_rules = self._get_validation_rules(control_id)
        
        for rule in validation_rules:
            if not rule(value):
                return False
        
        return True
    
    def _apply_variable_substitution(self, control_id: str, value: str) -> Any:
        """应用变量替换 - 基于define.csv逻辑"""
        substitution_rules = self._get_substitution_rules(control_id)
        
        for before, after in substitution_rules.items():
            value = value.replace(before, after)
        
        return value
```

### 13.2 数据流详细说明

#### 13.2.1 输入到输出完整数据流
```
用户输入
    ↓
输入验证 (chkTxtIsNumeric, chkAddControls)
    ↓
变量替换 (define.csv逻辑)
    ↓
计算执行 (calc.csv表达式计算)
    ↓
关系验证 (relation.csv条件判断)
    ↓
精度控制 (四舍五入处理)
    ↓
程序生成 (prg.csv模板应用)
    ↓
NC协议格式化 (makeSendTxt)
    ↓
命名管道传输
    ↓
NC机接收执行
```

#### 13.2.2 错误处理流程
```python
class ErrorHandlingFlow:
    def __init__(self):
        self.error_handler = ValidationErrorHandler()
        self.logger = logging.getLogger(__name__)
    
    def handle_data_loading_error(self, file_path: str, error: Exception):
        """处理数据加载错误"""
        self.logger.error(f"数据加载失败: {file_path}, 错误: {error}")
        
        # 尝试修复编码问题
        if isinstance(error, UnicodeDecodeError):
            fixed_data = self._fix_encoding_issue(file_path)
            if fixed_data is not None:
                return fixed_data
        
        # 记录错误并返回空数据
        self.error_handler.add_error("data_loading", f"文件加载失败: {file_path}")
        return pd.DataFrame()
    
    def handle_calculation_error(self, expression: str, error: Exception):
        """处理计算错误"""
        self.logger.error(f"计算错误: {expression}, 错误: {error}")
        
        # 记录计算错误
        self.error_handler.add_error("calculation", f"表达式计算失败: {expression}")
        
        # 返回默认值
        return 0.0
    
    def _fix_encoding_issue(self, file_path: str) -> Optional[pd.DataFrame]:
        """修复编码问题"""
        encodings_to_try = ['shift_jis', 'cp932', 'latin1', 'iso-8859-1']
        
        for encoding in encodings_to_try:
            try:
                return pd.read_csv(file_path, encoding=encoding)
            except UnicodeDecodeError:
                continue
        
        return None
```

### 13.3 性能优化数据处理

#### 13.3.1 缓存机制
```python
class DataCache:
    def __init__(self, max_size: int = 1000):
        self.cache = {}
        self.max_size = max_size
        self.access_count = {}
    
    def get(self, key: str) -> Optional[Any]:
        """获取缓存数据"""
        if key in self.cache:
            self.access_count[key] = self.access_count.get(key, 0) + 1
            return self.cache[key]
        return None
    
    def set(self, key: str, value: Any):
        """设置缓存数据"""
        if len(self.cache) >= self.max_size:
            self._evict_least_used()
        
        self.cache[key] = value
        self.access_count[key] = 1
    
    def _evict_least_used(self):
        """淘汰最少使用的缓存项"""
        if not self.access_count:
            return
        
        min_key = min(self.access_count.items(), key=lambda x: x[1])[0]
        del self.cache[min_key]
        del self.access_count[min_key]
```

#### 13.3.2 预编译优化
```python
class ExpressionPrecompiler:
    def __init__(self):
        self.compiled_expressions = {}
    
    def precompile_expression(self, expression: str) -> Callable:
        """预编译表达式"""
        if expression in self.compiled_expressions:
            return self.compiled_expressions[expression]
        
        try:
            # 安全编译表达式
            compiled = compile(expression, '<string>', 'eval')
            self.compiled_expressions[expression] = compiled
            return compiled
        except Exception as e:
            logger.warning(f"表达式预编译失败: {expression}, 错误: {e}")
            return None
```

## 14. 部署和配置

### 14.1 系统配置管理

#### 14.1.1 配置文件结构
```ini
[system]
data_directory = ./data/master
log_level = INFO
batch_size = 1000
max_cache_size = 1000
default_encoding = utf-8

[communication]
pipe_name = DNC_Pipe
protocol_type = rexroth
timeout_seconds = 30

[calculation]
decimal_places = 4
enable_precompilation = true
enable_caching = true

[ui]
window_width = 1024
window_height = 768
theme = default
```

#### 14.1.2 环境配置检查
```python
class EnvironmentChecker:
    def check_system_requirements(self) -> Dict[str, bool]:
        """检查系统要求"""
        requirements = {
            'python_version': self._check_python_version(),
            'pandas_installed': self._check_pandas(),
            'pyqt_installed': self._check_pyqt(),
            'data_directory_exists': self._check_data_directory(),
            'master_files_exist': self._check_master_files()
        }
        return requirements
    
    def _check_python_version(self) -> bool:
        """检查Python版本"""
        import sys
        return sys.version_info >= (3, 8)
    
    def _check_data_directory(self) -> bool:
        """检查数据目录"""
        return os.path.exists('./data/master')
```

## 15. 测试策略

### 15.1 基于VB.NET功能的测试用例

#### 15.1.1 控件系统测试
```python
class ControlSystemTests:
    def test_load_control_creation(self):
        """测试Load控件创建"""
        control_manager = ControlManager()
        load_control = control_manager.create_control("Load", "test_load", {})
        assert isinstance(load_control, LoadControl)
    
    def test_input_control_validation(self):
        """测试Input控件验证"""
        input_control = InputControl("test_input", "numeric", {})
        assert input_control.validate_input("123.45") == True
        assert input_control.validate_input
# DNC系统开发详细文档

## 1. 项目概述

### 1.1 系统简介
DNC（Direct Numerical Control）系统是一个数控设备参数管理软件，用于从电脑直接传送参数到NC机的宏变量系统。该系统解决了传统NC机手动输入参数的时间和错误问题。

### 1.2 系统架构 - 基于VB.NET源码分析
- **原系统**: VB.NET DNC2.05 (基于Frm_main.vb主窗体)
- **新系统**: Python重写版本 (基于VB.NET源码完整重构)
- **系统构成**: PC + NC机 + LAN线 + DNC软件 + 命名管道通信
- **数据格式**: CSV文件存储Master数据 + 动态控件系统
- **核心架构**: 8种控件系统 + 计算引擎 + 通信模块 + 数据处理

## 2. 系统功能模块

### 2.1 核心功能模块

#### 2.1.1 产品型号管理
- 产品类型定义 (type_define.csv)
- 程序类型映射 (type_prg.csv)
- 产品参数配置 (load.csv)

#### 2.1.2 参数计算引擎
- 几何参数计算 (calc.csv)
- 关系验证逻辑 (relation.csv)
- 变量定义管理 (define.csv)

#### 2.1.3 程序生成器
- 程序定义 (prg.csv)
- 控制参数 (cntrl_rex.csv)
- 选择逻辑 (select.csv)

### 2.2 数据流处理

#### 2.2.1 输入处理
```python
输入 → 参数验证 → 计算引擎 → 程序生成 → 输出
```

#### 2.2.2 宏变量映射
- #500-#600: 系统参数
- #1-#100: 用户参数
- 特殊变量: 计算中间值

## 3. 数据结构详细说明

### 3.1 核心数据文件

#### 3.1.1 type_define.csv (产品类型定义)
- **文件大小**: 988.60 KB
- **数据结构**:
  - NO: 序号
  - TYPE: 产品型号 (如: GPA18GT15040-A)
  - DEFINE1: 定义1
  - DEFINE2: 定义2

#### 3.1.2 type_prg.csv (程序类型映射)
- **文件大小**: 480.92 KB
- **数据结构**:
  - NO: 序号
  - prg1: 程序1编号
  - prg2: 程序2编号

#### 3.1.3 load.csv (主数据文件)
- **文件大小**: 8.5 MB
- **数据结构**:
  - NO: 序号
  - TYPE: 产品型号
  - DRAWING: 图纸文件
  - DISPFLG: 显示标志
  - #1-#12: 定义变量
  - #500-#550: 系统参数
  - #602-#603: 开关控制

#### 3.1.4 cntrl_rex.csv (参数控制)
- **文件大小**: 1.10 KB
- **数据结构**:
  - PARAMETER: 参数名称 (如: Work_plan, Teeth_num)
  - DATATYPE: 数据类型 (int, real, boolean)
  - MACRO: 宏变量映射 (如: #510, #511)

### 3.2 计算逻辑文件

#### 3.2.1 calc.csv (计算定义)
```csv
DEFINE,1,2,3,4,5,6,7,8,9,10,11,12,13
calcABC,=,#528,-,#510,*,2,NaN,NaN,NaN,NaN,NaN,NaN,NaN
calcABCD,=,(,#528,-,#513,),/,2.0,NaN,NaN,NaN,NaN,NaN
```

#### 3.2.2 relation.csv (关系验证)
```csv
DEFINE,VALUE,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28
relationHPN,#1,and,#1,>,0.0,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN
```

#### 3.2.3 define.csv (变量定义)
```csv
DEFINE,STR,BEFORE,AFTER,CHNGVL,CALC
defineP,P,P0,0,NaN,NaN
defineH,H,H0,0,NaN,NaN
```

## 4. 技术架构设计

### 4.1 系统架构图

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   用户界面层     │    │   业务逻辑层     │    │   数据访问层     │
│                 │    │                 │    │                 │
│  - 主窗口       │◄──►│  - 参数计算     │◄──►│  - CSV处理器    │
│  - 输入表单     │    │  - 程序生成     │    │  - 数据验证     │
│  - 结果显示     │    │  - 关系验证     │    │  - 编码处理     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 4.2 核心类设计

#### 4.2.1 DataManager (数据管理器)
```python
class DataManager:
    def load_master_data(self) -> Dict[str, pd.DataFrame]
    def batch_read_large_csv(self, file_path: str, batch_size: int = 1000)
    def validate_data_integrity(self) -> bool
    def fix_encoding_issues(self, file_path: str) -> pd.DataFrame
```

#### 4.2.2 CalculationEngine (计算引擎)
```python
class CalculationEngine:
    def calculate_parameters(self, input_data: Dict) -> Dict
    def validate_relations(self, calculated_data: Dict) -> bool
    def generate_macro_variables(self, params: Dict) -> List[str]
```

#### 4.2.3 ProgramGenerator (程序生成器)
```python
class ProgramGenerator:
    def generate_nc_program(self, product_type: str, params: Dict) -> str
    def apply_program_template(self, template: str, variables: Dict) -> str
    def validate_program_syntax(self, program: str) -> bool
```

## 5. 数据处理流程

### 5.1 数据加载流程
1. **扫描目录**: 递归扫描master目录下的所有CSV文件
2. **分类处理**: 根据文件大小分类为小文件和大文件
3. **编码检测**: 自动检测文件编码 (UTF-8, Shift-JIS, CP932)
4. **分批读取**: 大文件使用分批读取机制
5. **数据验证**: 检查数据完整性和一致性

### 5.2 参数计算流程
1. **输入验证**: 验证用户输入参数的有效性
2. **变量替换**: 根据define.csv进行变量替换
3. **计算执行**: 执行calc.csv中定义的计算逻辑
4. **关系验证**: 验证relation.csv中定义的关系条件
5. **结果生成**: 生成最终的宏变量值

## 6. 文件编码处理

### 6.1 编码问题文件列表
- `ini.csv`: 958字节，编码问题
- `math.csv`: 1.08KB，编码问题  
- `cntrl.csv`: 1.38KB，编码问题
- `switch.csv`: 106字节，编码问题

### 6.2 编码处理策略
```python
def detect_encoding(file_path: str) -> str:
    encodings = ['utf-8', 'shift_jis', 'cp932', 'latin1']
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as f:
                f.read()
            return encoding
        except UnicodeDecodeError:
            continue
    return 'unknown'
```

## 7. 性能优化策略

### 7.1 大文件处理优化
- **分批读取**: 使用pandas的chunksize参数
- **内存管理**: 及时释放不需要的数据
- **缓存机制**: 缓存频繁访问的数据

### 7.2 计算优化
- **预编译**: 预编译计算表达式
- **并行处理**: 使用多线程处理独立计算
- **结果缓存**: 缓存重复计算结果

## 8. 错误处理机制

### 8.1 数据验证错误
- 文件不存在错误
- 编码错误处理
- 数据格式错误
- 完整性检查失败

### 8.2 计算错误
- 除零错误处理
- 变量未定义错误
- 关系验证失败
- 程序生成错误

## 9. 部署和配置

### 9.1 环境要求
- Python 3.8+
- pandas >= 1.3.0
- PyQt5/PySide6
- 操作系统: Windows 10/11

### 9.2 配置文件
```ini
[system]
data_directory = ./data/master
log_level = INFO
batch_size = 1000

[encoding]
default_encoding = utf-8
fallback_encodings = shift_jis,cp932,latin1
```

## 10. 测试策略

### 10.1 单元测试
- 数据加载测试
- 计算逻辑测试
- 程序生成测试
- 错误处理测试

### 10.2 集成测试
- 端到端流程测试
- 性能测试
- 兼容性测试

## 11. 功能模块详细设计

### 11.1 控件系统详细设计

#### 11.1.1 8种核心控件类型实现

**Load控件 (makeCntrlLoad)**
```python
class LoadControl:
    def __init__(self, data_source: str, field_mapping: Dict):
        self.data_source = data_source
        self.field_mapping = field_mapping
        self.data_table = None
    
    def load_data(self) -> pd.DataFrame:
        """从CSV文件加载数据"""
        try:
            self.data_table = pd.read_csv(self.data_source, encoding='utf-8')
            return self.data_table
        except Exception as e:
            logger.error(f"加载数据失败: {e}")
            return None
    
    def validate_data(self) -> bool:
        """验证数据完整性"""
        required_fields = ['NO', 'TYPE', 'DRAWING']
        return all(field in self.data_table.columns for field in required_fields)
```

**Input控件 (makeCntrlInput)**
```python
class InputControl:
    def __init__(self, control_id: str, data_type: str, validation_rules: Dict):
        self.control_id = control_id
        self.data_type = data_type
        self.validation_rules = validation_rules
        self.value = None
    
    def handle_text_change(self, new_value: str):
        """处理文本变更事件"""
        if self.validate_input(new_value):
            self.value = self.convert_value(new_value)
            self.trigger_calculation()
    
    def validate_input(self, value: str) -> bool:
        """验证输入值"""
        if self.data_type == 'numeric':
            return self._validate_numeric(value)
        elif self.data_type == 'string':
            return self._validate_string(value)
        return False
```

#### 11.1.2 基础控件创建方法Python实现

**文本框创建 (makeTextBox)**
```python
def create_text_box(name: str, location: Tuple[int, int], size: Tuple[int, int], 
                   text_change_handler: Callable) -> QLineEdit:
    """创建文本框控件"""
    text_box = QLineEdit()
    text_box.setObjectName(name)
    text_box.setGeometry(location[0], location[1], size[0], size[1])
    text_box.textChanged.connect(text_change_handler)
    return text_box
```

**标签创建 (makeLabel)**
```python
def create_label(name: str, text: str, location: Tuple[int, int], 
                size: Tuple[int, int]) -> QLabel:
    """创建标签控件"""
    label = QLabel(text)
    label.setObjectName(name)
    label.setGeometry(location[0], location[1], size[0], size[1])
    return label
```

#### 11.1.3 动态控件管理技术细节

**控件生命周期管理**
```python
class ControlManager:
    def __init__(self):
        self.controls = {}
        self.control_groups = {}
    
    def add_control(self, control_id: str, control: QWidget):
        """添加控件到管理器"""
        self.controls[control_id] = control
    
    def remove_control(self, control_id: str):
        """移除控件"""
        if control_id in self.controls:
            self.controls[control_id].deleteLater()
            del self.controls[control_id]
    
    def enable_controls(self, control_ids: List[str], enabled: bool):
        """批量启用/禁用控件"""
        for control_id in control_ids:
            if control_id in self.controls:
                self.controls[control_id].setEnabled(enabled)
```

### 11.2 计算引擎详细设计

#### 11.2.1 表达式计算具体算法

**表达式解析器 (getCalcResult)**
```python
class ExpressionCalculator:
    def __init__(self):
        self.variables = {}
        self.functions = {
            'MAX': max,
            'MIN': min,
            'ROUND': round,
            'ABS': abs
        }
    
    def calculate(self, expression: str, variables: Dict) -> float:
        """计算表达式值"""
        try:
            # 变量替换
            expr = self._replace_variables(expression, variables)
            # 表达式求值
            result = eval(expr, {"__builtins__": None}, self.functions)
            return float(result)
        except Exception as e:
            logger.error(f"表达式计算错误: {expression}, 错误: {e}")
            return 0.0
    
    def _replace_variables(self, expression: str, variables: Dict) -> str:
        """替换表达式中的变量"""
        for var_name, var_value in variables.items():
            expression = expression.replace(f"@{var_name}", str(var_value))
        return expression
```

#### 11.2.2 条件判断系统实现逻辑

**关系判断引擎 (judgeRelation)**
```python
class RelationJudge:
    def judge(self, condition: str, left_value: Any, right_value: Any) -> bool:
        """判断关系条件"""
        operators = {
            '=': lambda x, y: x == y,
            '<>': lambda x, y: x != y,
            '>': lambda x, y: x > y,
            '<': lambda x, y: x < y,
            '>=': lambda x, y: x >= y,
            '<=': lambda x, y: x <= y
        }
        
        for op, func in operators.items():
            if op in condition:
                return func(left_value, right_value)
        
        return False
```

#### 11.2.3 精度控制技术方案

**数值精度管理**
```python
class PrecisionController:
    def __init__(self, decimal_places: int = 4):
        self.decimal_places = decimal_places
    
    def round_value(self, value: float) -> float:
        """四舍五入处理"""
        return round(value, self.decimal_places)
    
    def format_display(self, value: float) -> str:
        """格式化显示值"""
        return f"{value:.{self.decimal_places}f}".rstrip('0').rstrip('.')
```

### 11.3 数据处理模块详细设计

#### 11.3.1 文件加载系统实现细节

**CSV文件加载器 (LoadFileToTBL)**
```python
class CSVLoader:
    def __init__(self, encoding_detector: EncodingDetector):
        self.encoding_detector = encoding_detector
    
    def load_file(self, file_path: str) -> pd.DataFrame:
        """加载CSV文件"""
        encoding = self.encoding_detector.detect_encoding(file_path)
        
        try:
            df = pd.read_csv(file_path, encoding=encoding)
            return self._clean_data(df)
        except Exception as e:
            logger.error(f"文件加载失败: {file_path}, 错误: {e}")
            return pd.DataFrame()
    
    def _clean_data(self, df: pd.DataFrame) -> pd.DataFrame:
        """数据清理"""
        # 移除空行
        df = df.dropna(how='all')
        # 处理NaN值
        df = df.fillna('')
        return df
```

#### 11.3.2 数据搜索功能算法设计

**表搜索引擎 (searchT_relation)**
```python
class TableSearcher:
    def __init__(self, data_tables: Dict[str, pd.DataFrame]):
        self.data_tables = data_tables
        self.search_cache = {}
    
    def search_table(self, table_name: str, search_criteria: Dict) -> pd.DataFrame:
        """搜索数据表"""
        cache_key = f"{table_name}_{str(search_criteria)}"
        if cache_key in self.search_cache:
            return self.search_cache[cache_key]
        
        if table_name not in self.data_tables:
            return pd.DataFrame()
        
        table = self.data_tables[table_name]
        result = table.copy()
        
        for column, value in search_criteria.items():
            if column in table.columns:
                result = result[result[column] == value]
        
        self.search_cache[cache_key] = result
        return result
```

#### 11.3.3 数据操作技术实现

**数据转换器 (searchT_ChngValue)**
```python
class DataConverter:
    def __init__(self, conversion_rules: Dict):
        self.conversion_rules = conversion_rules
    
    def convert_value(self, value: Any, conversion_type: str) -> Any:
        """转换数据值"""
        if conversion_type in self.conversion_rules:
            rule = self.conversion_rules[conversion_type]
            return rule(value)
        return value
    
    def add_conversion_rule(self, conversion_type: str, rule: Callable):
        """添加转换规则"""
        self.conversion_rules[conversion_type] = rule
```

### 11.4 通信模块详细设计

#### 11.4.1 通信协议支持技术实现

**NC通信协议处理器 (makeSendTxt)**
```python
class NCProtocolHandler:
    def __init__(self, protocol_type: str):
        self.protocol_type = protocol_type
        self.message_formatters = {
            'rexroth': self._format_rexroth_message,
            'brother': self._format_brother_message
        }
    
    def format_message(self, command: str, parameters: Dict) -> str:
        """格式化NC命令消息"""
        if self.protocol_type in self.message_formatters:
            return self.message_formatters[self.protocol_type](command, parameters)
        return command
    
    def _format_rexroth_message(self, command: str, parameters: Dict) -> str:
        """格式化Rexroth协议消息"""
        # Rexroth协议特定格式化逻辑
        return f"{command} {self._format_parameters(parameters)}"
    
    def _format_brother_message(self, command: str, parameters: Dict) -> str:
        """格式化Brother协议消息"""
        # Brother协议特定格式化逻辑
        return f"{command};{self._format_parameters(parameters)}"
```

#### 11.4.2 进程间通信机制设计

**连接状态管理器 (ConnectionChange)**
```python
class ConnectionManager:
    def __init__(self):
        self.connections = {}
        self.connection_callbacks = []
    
    def add_connection(self, connection_id: str, connection: object):
        """添加连接"""
        self.connections[connection_id] = connection
        self._notify_connection_change(connection_id, 'connected')
    
    def remove_connection(self, connection_id: str):
        """移除连接"""
        if connection_id in self.connections:
            del self.connections[connection_id]
            self._notify_connection_change(connection_id, 'disconnected')
    
    def _notify_connection_change(self, connection_id: str, status: str):
        """通知连接状态变更"""
        for callback in self.connection_callbacks:
            callback(connection_id, status)
```

#### 11.4.3 命名管道通信具体实现

**异步命名管道客户端 (NamedPipeAsyncClient)**
```python
class NamedPipeClient:
    def __init__(self, pipe_name: str):
        self.pipe_name = pipe_name
        self.connected = False
        self.data_received_callbacks = []
    
    async def connect(self):
        """异步连接命名管道"""
        try:
            # Windows命名管道连接实现
            self.connected = True
            await self._start_listening()
        except Exception as e:
            logger.error(f"命名管道连接失败: {e}")
            self.connected = False
    
    async def send_data(self, data: str):
        """异步发送数据"""
        if self.connected:
            # 实现数据发送逻辑
            pass
    
    def add_data_received_callback(self, callback: Callable):
        """添加数据接收回调"""
        self.data_received_callbacks.append(callback)
```

### 11.5 用户界面交互详细设计

#### 11.5.1 事件处理系统架构设计

**事件分发器**
```python
class EventDispatcher:
    def __init__(self):
        self.event_handlers = {}
    
    def register_handler(self, event_type: str, handler: Callable):
        """注册事件处理器"""
        if event_type not in self.event_handlers:
            self.event_handlers[event_type] = []
        self.event_handlers[event_type].append(handler)
    
    def dispatch_event(self, event_type: str, event_data: Dict):
        """分发事件"""
        if event_type in self.event_handlers:
            for handler in self.event_handlers[event_type]:
                try:
                    handler(event_data)
                except Exception as e:
                    logger.error(f"事件处理错误: {e}")
```

#### 11.5.2 输入处理技术实现

**文本变更处理器 (txt_change)**
```python
class TextChangeHandler:
    def __init__(self, validation_rules: Dict, calculation_trigger: Callable):
        self.validation_rules = validation_rules
        self.calculation_trigger = calculation_trigger
        self.change_event_flag = False
    
    def handle_text_change(self, control_id: str, new_text: str):
        """处理文本变更"""
        if self.change_event_flag:
            return
        
        self.change_event_flag = True
        
        try:
            # 数据验证
            if self._validate_text(control_id, new_text):
                # 触发计算
                self.calculation_trigger(control_id, new_text)
        finally:
            self.change_event_flag = False
    
    def _validate_text(self, control_id: str, text: str) -> bool:
        """验证文本内容"""
        if control_id in self.validation_rules:
            rule = self.validation_rules[control_id]
            return rule(text)
        return True
```

#### 11.5.3 操作员管理功能设计

**操作员管理器 (TB_OpeID_TextChanged)**
```python
class OperatorManager:
    def __init__(self):
        self.current_operator = None
        self.operator_database = {}
    
    def set_operator(self, operator_id: str):
        """设置当前操作员"""
        if operator_id in self.operator_database:
            self.current_operator = self.operator_database[operator_id]
            logger.info(f"操作员已切换: {self.current_operator.name}")
        else:
            logger.warning(f"未知操作员ID: {operator_id}")
    
    def get_operator_name(self, operator_id: str) -> str:
        """获取操作员名称"""
        if operator_id in self.operator_database:
            return self.operator_database[operator_id].name
        return "未知操作员"
```

### 11.6 数据验证模块详细设计

#### 11.6.1 验证方法具体实现

**数值验证器 (chkTxtIsNumeric)**
```python
class NumericValidator:
    def validate(self, text: str, min_value: float = None, 
                max_value: float = None, decimal_places: int = None) -> bool:
        """验证数值文本"""
        try:
            value = float(text)
            
            if min_value is not None and value < min_value:
                return False
            
            if max_value is not None and value > max_value:
                return False
            
            if decimal_places is not None:
                # 检查小数位数
                decimal_part = str(value).split('.')
                if len(decimal_part) > 1 and len(decimal_part[1]) > decimal_places:
                    return False
            
            return True
        except ValueError:
            return False
```

#### 11.6.2 验证规则技术设计

**业务规则验证器 (chkAddControls)**
```python
class BusinessRuleValidator:
    def __init__(self, validation_rules: Dict):
        self.validation_rules = validation_rules
    
    def validate_controls(self, control_values: Dict) -> Dict[str, str]:
        """验证控件组业务规则"""
        errors = {}
        
        for rule_name, rule in self.validation_rules.items():
            if not rule(control_values):
                errors[rule_name] = f"业务规则验证失败: {rule_name}"
        
        return errors
    
    def add_validation_rule(self, rule_name: str, rule: Callable):
        """添加验证规则"""
        self.validation_rules[rule_name] = rule
```

#### 11.6.3 错误处理机制

**验证错误处理器**
```python
class ValidationErrorHandler:
    def __init__(self):
        self.error_messages = {}
    
    def add_error(self, control_id: str, message: str):
        """添加错误信息"""
        if control_id not in self.error_messages:
            self.error_messages[control_id] = []
        self.error_messages[control_id].append(message)
    
    def clear_errors(self, control_id: str = None):
        """清除错误信息"""
        if control_id:
            if control_id in self.error_messages:
                del self.error_messages[control_id]
        else:
            self.error_messages.clear()
    
    def has_errors(self) -> bool:
        """检查是否有错误"""
        return len(self.error_messages) > 0
```

### 11.7 系统管理模块详细设计

#### 11.7.1 初始化系统技术实现

**系统初始化器 (Frm_main_Load)**
```python
class SystemInitializer:
    def __init__(self, config_manager: ConfigManager, data_manager: DataManager):
        self.config_manager = config_manager
        self.data_manager = data_manager
        self.initialization_steps = [
            self._load_configuration,
            self._load_master_data,
            self._initialize_ui,
            self._setup_communication
        ]
    
    async def initialize_system(self):
        """异步初始化系统"""
        for step in self.initialization_steps:
            try:
                await step()
            except Exception as e:
                logger.error(f"初始化步骤失败: {e}")
                raise
    
    async def _load_configuration(self):
        """加载系统配置"""
        self.config = await self.config_manager.load_config()
    
    async def _load_master_data(self):
        """加载Master数据"""
        self.master_data = await self.data_manager.load_master_data()
    
    async def _initialize_ui(self):
        """初始化用户界面"""
        # 创建主窗口和控件
        pass
    
    async def _setup_communication(self):
        """设置通信连接"""
        # 初始化NC通信和命名管道
        pass
```

#### 11.7.2 显示管理功能设计

**控件状态管理器 (ControlStateManager)**
```python
class ControlStateManager:
    def __init__(self):
        self.control_states = {}
        self.control_groups = {}
    
    def set_controls_enabled(self, control_ids: List[str], enabled: bool):
        """设置控件启用状态"""
        for control_id in control_ids:
            if control_id in self.control_states:
                self.control_states[control_id].setEnabled(enabled)
    
    def set_controls_visible(self, control_ids: List[str], visible: bool):
        """设置控件可见性"""
        for control_id in control_ids:
            if control_id in self.control_states:
                self.control_states[control_id].setVisible(visible)
    
    def add_control_group(self, group_name: str, control_ids: List[str]):
        """添加控件组"""
        self.control_groups[group_name] = control_ids
    
    def set_group_enabled(self, group_name: str, enabled: bool):
        """设置控件组启用状态"""
        if group_name in self.control_groups:
            self.set_controls_enabled(self.control_groups[group_name], enabled)
```

#### 11.7.3 配置管理技术方案

**INI配置管理器 (IniConfigManager)**
```python
class IniConfigManager:
    def __init__(self, ini_file_path: str):
        self.ini_file_path = ini_file_path
        self.config = {}
    
    def load_config(self) -> Dict:
        """加载INI配置文件"""
        config = configparser.ConfigParser()
        config.read(self.ini_file_path, encoding='utf-8')
        
        for section in config.sections():
            self.config[section] = dict(config.items(section))
        
        return self.config
    
    def save_config(self, config: Dict):
        """保存INI配置文件"""
        config_parser = configparser.ConfigParser()
        
        for section, options in config.items():
            config_parser[section] = options
        
        with open(self.ini_file_path, 'w', encoding='utf-8') as f:
            config_parser.write(f)
    
    def get_value(self, section: str, key: str, default=None):
        """获取配置值"""
        return self.config.get(section, {}).get(key, default)
```

### 11.8 工具方法详细设计

#### 11.8.1 字符串处理技术实现

**字符串工具类 (StringUtils)**
```python
class StringUtils:
    @staticmethod
    def len_b(text: str) -> int:
        """计算字符串字节长度（兼容VB.NET的LenB函数）"""
        return len(text.encode('utf-8'))
    
    @staticmethod
    def make_format_str(format_pattern: str, *args) -> str:
        """创建格式化字符串"""
        try:
            return format_pattern.format(*args)
        except Exception as e:
            logger.error(f"字符串格式化失败: {e}")
            return format_pattern
    
    @staticmethod
    def to_half_adjust(value: float, decimal_places: int = 0) -> float:
        """四舍五入处理（兼容VB.NET的ToHalfAdjust）"""
        factor = 10 ** decimal_places
        return round(value * factor) / factor
    
    @staticmethod
    def get_operator_name(operator_id: str) -> str:
        """获取操作员名称"""
        operator_map = {
            '001': '操作员A',
            '002': '操作员B',
            '003': '操作员C'
        }
        return operator_map.get(operator_id, '未知操作员')
```

#### 11.8.2 系统工具功能设计

**系统工具类 (SystemUtils)**
```python
class SystemUtils:
    @staticmethod
    def get_all_controls(parent_widget: QWidget) -> List[QWidget]:
        """获取所有子控件"""
        controls = []
        
        def collect_controls(widget):
            for child in widget.children():
                if isinstance(child, QWidget):
                    controls.append(child)
                    collect_controls(child)
        
        collect_controls(parent_widget)
        return controls
    
    @staticmethod
    def change_form_size(form: QWidget, width: int, height: int):
        """改变窗体大小"""
        form.resize(width, height)
    
    @staticmethod
    def show_info_form(title: str, message: str):
        """显示信息窗体"""
        msg_box = QMessageBox()
        msg_box.setWindowTitle(title)
        msg_box.setText(message)
        msg_box.setIcon(QMessageBox.Information)
        msg_box.exec_()
```

#### 11.8.3 数值处理工具

**公差计算器 (ToleranceCalculator)**
```python
class ToleranceCalculator:
    @staticmethod
    def get_shafts_tolerance(diameter: float, tolerance_class: str) -> Tuple[float, float]:
        """获取轴公差"""
        tolerance_tables = {
            'h6': {10: (-0.009, 0), 18: (-0.011, 0), 30: (-0.013, 0)},
            'h7': {10: (-0.015, 0), 18: (-0.018, 0), 30: (-0.021, 0)},
            'h8': {10: (-0.022, 0), 18: (-0.027, 0), 30: (-0.033, 0)}
        }
        
        for max_diameter, tolerance in tolerance_tables.get(tolerance_class, {}).items():
            if diameter <= max_diameter:
                return tolerance
        
        return (0, 0)
    
    @staticmethod
    def get_length_tolerance(length: float, tolerance_class: str) -> Tuple[float, float]:
        """获取长度公差"""
        tolerance_tables = {
            'fine': {100: (-0.1, 0.1), 400: (-0.2, 0.2), 1000: (-0.3, 0.3)},
            'medium': {100: (-0.2, 0.2), 400: (-0.4, 0.4), 1000: (-0.6, 0.6)},
            'coarse': {100: (-0.4, 0.4), 400: (-0.8, 0.8), 1000: (-1.2, 1.2)}
        }
        
        for max_length, tolerance in tolerance_tables.get(tolerance_class, {}).items():
            if length <= max_length:
                return tolerance
        
        return (0, 0)
```

## 12. 技术架构设计

### 12.1 核心类设计
# DNC系统开发详细文档

## 1. 项目概述

### 1.1 系统简介
DNC（Direct Numerical Control）系统是一个数控设备参数管理软件，用于从电脑直接传送参数到NC机的宏变量系统。该系统解决了传统NC机手动输入参数的时间和错误问题。

### 1.2 系统架构 - 基于VB.NET源码分析
- **原系统**: VB.NET DNC2.05 (基于Frm_main.vb主窗体)
- **新系统**: Python重写版本 (基于VB.NET源码完整重构)
- **系统构成**: PC + NC机 + LAN线 + DNC软件 + 命名管道通信
- **数据格式**: CSV文件存储Master数据 + 动态控件系统
- **核心架构**: 8种控件系统 + 计算引擎 + 通信模块 + 数据处理

## 2. 系统功能模块

### 2.1 核心功能模块

#### 2.1.1 产品型号管理
- 产品类型定义 (type_define.csv)
- 程序类型映射 (type_prg.csv)
- 产品参数配置 (load.csv)

#### 2.1.2 参数计算引擎
- 几何参数计算 (calc.csv)
- 关系验证逻辑 (relation.csv)
- 变量定义管理 (define.csv)

#### 2.1.3 程序生成器
- 程序定义 (prg.csv)
- 控制参数 (cntrl_rex.csv)
- 选择逻辑 (select.csv)

### 2.2 数据流处理

#### 2.2.1 输入处理
```python
输入 → 参数验证 → 计算引擎 → 程序生成 → 输出
```

#### 2.2.2 宏变量映射
- #500-#600: 系统参数
- #1-#100: 用户参数
- 特殊变量: 计算中间值

## 3. 数据结构详细说明

### 3.1 核心数据文件

#### 3.1.1 type_define.csv (产品类型定义)
- **文件大小**: 988.60 KB
- **数据结构**:
  - NO: 序号
  - TYPE: 产品型号 (如: GPA18GT15040-A)
  - DEFINE1: 定义1
  - DEFINE2: 定义2

#### 3.1.2 type_prg.csv (程序类型映射)
- **文件大小**: 480.92 KB
- **数据结构**:
  - NO: 序号
  - prg1: 程序1编号
  - prg2: 程序2编号

#### 3.1.3 load.csv (主数据文件)
- **文件大小**: 8.5 MB
- **数据结构**:
  - NO: 序号
  - TYPE: 产品型号
  - DRAWING: 图纸文件
  - DISPFLG: 显示标志
  - #1-#12: 定义变量
  - #500-#550: 系统参数
  - #602-#603: 开关控制

#### 3.1.4 cntrl_rex.csv (参数控制)
- **文件大小**: 1.10 KB
- **数据结构**:
  - PARAMETER: 参数名称 (如: Work_plan, Teeth_num)
  - DATATYPE: 数据类型 (int, real, boolean)
  - MACRO: 宏变量映射 (如: #510, #511)

### 3.2 计算逻辑文件

#### 3.2.1 calc.csv (计算定义)
```csv
DEFINE,1,2,3,4,5,6,7,8,9,10,11,12,13
calcABC,=,#528,-,#510,*,2,NaN,NaN,NaN,NaN,NaN,NaN,NaN
calcABCD,=,(,#528,-,#513,),/,2.0,NaN,NaN,NaN,NaN,NaN
```

#### 3.2.2 relation.csv (关系验证)
```csv
DEFINE,VALUE,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28
relationHPN,#1,and,#1,>,0.0,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN
```

#### 3.2.3 define.csv (变量定义)
```csv
DEFINE,STR,BEFORE,AFTER,CHNGVL,CALC
defineP,P,P0,0,NaN,NaN
defineH,H,H0,0,NaN,NaN
```

## 4. 技术架构设计

### 4.1 系统架构图

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   用户界面层     │    │   业务逻辑层     │    │   数据访问层     │
│                 │    │                 │    │                 │
│  - 主窗口       │◄──►│  - 参数计算     │◄──►│  - CSV处理器    │
│  - 输入表单     │    │  - 程序生成     │    │  - 数据验证     │
│  - 结果显示     │    │  - 关系验证     │    │  - 编码处理     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 4.2 核心类设计

#### 4.2.1 DataManager (数据管理器)
```python
class DataManager:
    def load_master_data(self) -> Dict[str, pd.DataFrame]
    def batch_read_large_csv(self, file_path: str, batch_size: int = 1000)
    def validate_data_integrity(self) -> bool
    def fix_encoding_issues(self, file_path: str) -> pd.DataFrame
```

#### 4.2.2 CalculationEngine (计算引擎)
```python
class CalculationEngine:
    def calculate_parameters(self, input_data: Dict) -> Dict
    def validate_relations(self, calculated_data: Dict) -> bool
    def generate_macro_variables(self, params: Dict) -> List[str]
```

#### 4.2.3 ProgramGenerator (程序生成器)
```python
class ProgramGenerator:
    def generate_nc_program(self, product_type: str, params: Dict) -> str
    def apply_program_template(self, template: str, variables: Dict) -> str
    def validate_program_syntax(self, program: str) -> bool
```

## 5. 数据处理流程

### 5.1 数据加载流程
1. **扫描目录**: 递归扫描master目录下的所有CSV文件
2. **分类处理**: 根据文件大小分类为小文件和大文件
3. **编码检测**: 自动检测文件编码 (UTF-8, Shift-JIS, CP932)
4. **分批读取**: 大文件使用分批读取机制
5. **数据验证**: 检查数据完整性和一致性

### 5.2 参数计算流程
1. **输入验证**: 验证用户输入参数的有效性
2. **变量替换**: 根据define.csv进行变量替换
3. **计算执行**: 执行calc.csv中定义的计算逻辑
4. **关系验证**: 验证relation.csv中定义的关系条件
5. **结果生成**: 生成最终的宏变量值

## 6. 文件编码处理

### 6.1 编码问题文件列表
- `ini.csv`: 958字节，编码问题
- `math.csv`: 1.08KB，编码问题  
- `cntrl.csv`: 1.38KB，编码问题
- `switch.csv`: 106字节，编码问题

### 6.2 编码处理策略
```python
def detect_encoding(file_path: str) -> str:
    encodings = ['utf-8', 'shift_jis', 'cp932', 'latin1']
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as f:
                f.read()
            return encoding
        except UnicodeDecodeError:
            continue
    return 'unknown'
```

## 7. 性能优化策略

### 7.1 大文件处理优化
- **分批读取**: 使用pandas的chunksize参数
- **内存管理**: 及时释放不需要的数据
- **缓存机制**: 缓存频繁访问的数据

### 7.2 计算优化
- **预编译**: 预编译计算表达式
- **并行处理**: 使用多线程处理独立计算
- **结果缓存**: 缓存重复计算结果

## 8. 错误处理机制

### 8.1 数据验证错误
- 文件不存在错误
- 编码错误处理
- 数据格式错误
- 完整性检查失败

### 8.2 计算错误
- 除零错误处理
- 变量未定义错误
- 关系验证失败
- 程序生成错误

## 9. 部署和配置

### 9.1 环境要求
- Python 3.8+
- pandas >= 1.3.0
- PyQt5/PySide6
- 操作系统: Windows 10/11

### 9.2 配置文件
```ini
[system]
data_directory = ./data/master
log_level = INFO
batch_size = 1000

[encoding]
default_encoding = utf-8
fallback_encodings = shift_jis,cp932,latin1
```

## 10. 测试策略

### 10.1 单元测试
- 数据加载测试
- 计算逻辑测试
- 程序生成测试
- 错误处理测试

### 10.2 集成测试
- 端到端流程测试
- 性能测试
- 兼容性测试

## 11. 功能模块详细设计

### 11.1 控件系统详细设计

#### 11.1.1 8种核心控件类型实现

**Load控件 (makeCntrlLoad)**
```python
class LoadControl:
    def __init__(self, data_source: str, field_mapping: Dict):
        self.data_source = data_source
        self.field_mapping = field_mapping
        self.data_table = None
    
    def load_data(self) -> pd.DataFrame:
        """从CSV文件加载数据"""
        try:
            self.data_table = pd.read_csv(self.data_source, encoding='utf-8')
            return self.data_table
        except Exception as e:
            logger.error(f"加载数据失败: {e}")
            return None
    
    def validate_data(self) -> bool:
        """验证数据完整性"""
        required_fields = ['NO', 'TYPE', 'DRAWING']
        return all(field in self.data_table.columns for field in required_fields)
```

**Input控件 (makeCntrlInput)**
```python
class InputControl:
    def __init__(self, control_id: str, data_type: str, validation_rules: Dict):
        self.control_id = control_id
        self.data_type = data_type
        self.validation_rules = validation_rules
        self.value = None
    
    def handle_text_change(self, new_value: str):
        """处理文本变更事件"""
        if self.validate_input(new_value):
            self.value = self.convert_value(new_value)
            self.trigger_calculation()
    
    def validate_input(self, value: str) -> bool:
        """验证输入值"""
        if self.data_type == 'numeric':
            return self._validate_numeric(value)
        elif self.data_type == 'string':
            return self._validate_string(value)
        return False
```

#### 11.1.2 基础控件创建方法Python实现

**文本框创建 (makeTextBox)**
```python
def create_text_box(name: str, location: Tuple[int, int], size: Tuple[int, int], 
                   text_change_handler: Callable) -> QLineEdit:
    """创建文本框控件"""
    text_box = QLineEdit()
    text_box.setObjectName(name)
    text_box.setGeometry(location[0], location[1], size[0], size[1])
    text_box.textChanged.connect(text_change_handler)
    return text_box
```

**标签创建 (makeLabel)**
```python
def create_label(name: str, text: str, location: Tuple[int, int], 
                size: Tuple[int, int]) -> QLabel:
    """创建标签控件"""
    label = QLabel(text)
    label.setObjectName(name)
    label.setGeometry(location[0], location[1], size[0], size[1])
    return label
```

#### 11.1.3 动态控件管理技术细节

**控件生命周期管理**
```python
class ControlManager:
    def __init__(self):
        self.controls = {}
        self.control_groups = {}
    
    def add_control(self, control_id: str, control: QWidget):
        """添加控件到管理器"""
        self.controls[control_id] = control
    
    def remove_control(self, control_id: str):
        """移除控件"""
        if control_id in self.controls:
            self.controls[control_id].deleteLater()
            del self.controls[control_id]
    
    def enable_controls(self, control_ids: List[str], enabled: bool):
        """批量启用/禁用控件"""
        for control_id in control_ids:
            if control_id in self.controls:
                self.controls[control_id].setEnabled(enabled)
```

### 11.2 计算引擎详细设计

#### 11.2.1 表达式计算具体算法

**表达式解析器 (getCalcResult)**
```python
class ExpressionCalculator:
    def __init__(self):
        self.variables = {}
        self.functions = {
            'MAX': max,
            'MIN': min,
            'ROUND': round,
            'ABS': abs
        }
    
    def calculate(self, expression: str, variables: Dict) -> float:
        """计算表达式值"""
        try:
            # 变量替换
            expr = self._replace_variables(expression, variables)
            # 表达式求值
            result = eval(expr, {"__builtins__": None}, self.functions)
            return float(result)
        except Exception as e:
            logger.error(f"表达式计算错误: {expression}, 错误: {e}")
            return 0.0
    
    def _replace_variables(self, expression: str, variables: Dict) -> str:
        """替换表达式中的变量"""
        for var_name, var_value in variables.items():
            expression = expression.replace(f"@{var_name}", str(var_value))
        return expression
```

#### 11.2.2 条件判断系统实现逻辑

**关系判断引擎 (judgeRelation)**
```python
class RelationJudge:
    def judge(self, condition: str, left_value: Any, right_value: Any) -> bool:
        """判断关系条件"""
        operators = {
            '=': lambda x, y: x == y,
            '<>': lambda x, y: x != y,
            '>': lambda x, y: x > y,
            '<': lambda x, y: x < y,
            '>=': lambda x, y: x >= y,
            '<=': lambda x, y: x <= y
        }
        
        for op, func in operators.items():
            if op in condition:
                return func(left_value, right_value)
        
        return False
```

#### 11.2.3 精度控制技术方案

**数值精度管理**
```python
class PrecisionController:
    def __init__(self, decimal_places: int = 4):
        self.decimal_places = decimal_places
    
    def round_value(self, value: float) -> float:
        """四舍五入处理"""
        return round(value, self.decimal_places)
    
    def format_display(self, value: float) -> str:
        """格式化显示值"""
        return f"{value:.{self.decimal_places}f}".rstrip('0').rstrip('.')
```

### 11.3 数据处理模块详细设计

#### 11.3.1 文件加载系统实现细节

**CSV文件加载器 (LoadFileToTBL)**
```python
class CSVLoader:
    def __init__(self, encoding_detector: EncodingDetector):
        self.encoding_detector = encoding_detector
    
    def load_file(self, file_path: str) -> pd.DataFrame:
        """加载CSV文件"""
        encoding = self.encoding_detector.detect_encoding(file_path)
        
        try:
            df = pd.read_csv(file_path, encoding=encoding)
            return self._clean_data(df)
        except Exception as e:
            logger.error(f"文件加载失败: {file_path}, 错误: {e}")
            return pd.DataFrame()
    
    def _clean_data(self, df: pd.DataFrame) -> pd.DataFrame:
        """数据清理"""
        # 移除空行
        df = df.dropna(how='all')
        # 处理NaN值
        df = df.fillna('')
        return df
```

#### 11.3.2 数据搜索功能算法设计

**表搜索引擎 (searchT_relation)**
```python
class TableSearcher:
    def __init__(self, data_tables: Dict[str, pd.DataFrame]):
        self.data_tables = data_tables
        self.search_cache = {}
    
    def search_table(self, table_name: str, search_criteria: Dict) -> pd.DataFrame:
        """搜索数据表"""
        cache_key = f"{table_name}_{str(search_criteria)}"
        if cache_key in self.search_cache:
            return self.search_cache[cache_key]
        
        if table_name not in self.data_tables:
            return pd.DataFrame()
        
        table = self.data_tables[table_name]
        result = table.copy()
        
        for column, value in search_criteria.items():
            if column in table.columns:
                result = result[result[column] == value]
        
        self.search_cache[cache_key] = result
        return result
```

#### 11.3.3 数据操作技术实现

**数据转换器 (searchT_ChngValue)**
```python
class DataConverter:
    def __init__(self, conversion_rules: Dict):
        self.conversion_rules = conversion_rules
    
    def convert_value(self, value: Any, conversion_type: str) -> Any:
        """转换数据值"""
        if conversion_type in self.conversion_rules:
            rule = self.conversion_rules[conversion_type]
            return rule(value)
        return value
    
    def add_conversion_rule(self, conversion_type: str, rule: Callable):
        """添加转换规则"""
        self.conversion_rules[conversion_type] = rule
```

### 11.4 通信模块详细设计

#### 11.4.1 通信协议支持技术实现

**NC通信协议处理器 (makeSendTxt)**
```python
class NCProtocolHandler:
    def __init__(self, protocol_type: str):
        self.protocol_type = protocol_type
        self.message_formatters = {
            'rexroth': self._format_rexroth_message,
            'brother': self._format_brother_message
        }
    
    def format_message(self, command: str, parameters: Dict) -> str:
        """格式化NC命令消息"""
        if self.protocol_type in self.message_formatters:
            return self.message_formatters[self.protocol_type](command, parameters)
        return command
    
    def _format_rexroth_message(self, command: str, parameters: Dict) -> str:
        """格式化Rexroth协议消息"""
        # Rexroth协议特定格式化逻辑
        return f"{command} {self._format_parameters(parameters)}"
    
    def _format_brother_message(self, command: str, parameters: Dict) -> str:
        """格式化Brother协议消息"""
        # Brother协议特定格式化逻辑
        return f"{command};{self._format_parameters(parameters)}"
```

#### 11.4.2 进程间通信机制设计

**连接状态管理器 (ConnectionChange)**
```python
class ConnectionManager:
    def __init__(self):
        self.connections = {}
        self.connection_callbacks = []
    
    def add_connection(self, connection_id: str, connection: object):
        """添加连接"""
        self.connections[connection_id] = connection
        self._notify_connection_change(connection_id, 'connected')
    
    def remove_connection(self, connection_id: str):
        """移除连接"""
        if connection_id in self.connections:
            del self.connections[connection_id]
            self._notify_connection_change(connection_id, 'disconnected')
    
    def _notify_connection_change(self, connection_id: str, status: str):
        """通知连接状态变更"""
        for callback in self.connection_callbacks:
            callback(connection_id, status)
```

#### 11.4.3 命名管道通信具体实现

**异步命名管道客户端 (NamedPipeAsyncClient)**
```python
class NamedPipeClient:
    def __init__(self, pipe_name: str):
        self.pipe_name = pipe_name
        self.connected = False
        self.data_received_callbacks = []
    
    async def connect(self):
        """异步连接命名管道"""
        try:
            # Windows命名管道连接实现
            self.connected = True
            await self._start_listening()
        except Exception as e:
            logger.error(f"命名管道连接失败: {e}")
            self.connected = False
    
    async def send_data(self, data: str):
        """异步发送数据"""
        if self.connected:
            # 实现数据发送逻辑
            pass
    
    def add_data_received_callback(self, callback: Callable):
        """添加数据接收回调"""
        self.data_received_callbacks.append(callback)
```

### 11.5 用户界面交互详细设计

#### 11.5.1 事件处理系统架构设计

**事件分发器**
```python
class EventDispatcher:
    def __init__(self):
        self.event_handlers = {}
    
    def register_handler(self, event_type: str, handler: Callable):
        """注册事件处理器"""
        if event_type not in self.event_handlers:
            self.event_handlers[event_type] = []
        self.event_handlers[event_type].append(handler)
    
    def dispatch_event(self, event_type: str, event_data: Dict):
        """分发事件"""
        if event_type in self.event_handlers:
            for handler in self.event_handlers[event_type]:
                try:
                    handler(event_data)
                except Exception as e:
                    logger.error(f"事件处理错误: {e}")
```

#### 11.5.2 输入处理技术实现

**文本变更处理器 (txt_change)**
```python
class TextChangeHandler:
    def __init__(self, validation_rules: Dict, calculation_trigger: Callable):
        self.validation_rules = validation_rules
        self.calculation_trigger = calculation_trigger
        self.change_event_flag = False
    
    def handle_text_change(self, control_id: str, new_text: str):
        """处理文本变更"""
        if self.change_event_flag:
            return
        
        self.change_event_flag = True
        
        try:
            # 数据验证
            if self._validate_text(control_id, new_text):
                # 触发计算
                self.calculation_trigger(control_id, new_text)
        finally:
            self.change_event_flag = False
    
    def _validate_text(self, control_id: str, text: str) -> bool:
        """验证文本内容"""
        if control_id in self.validation_rules:
            rule = self.validation_rules[control_id]
            return rule(text)
        return True
```

#### 11.5.3 操作员管理功能设计

**操作员管理器 (TB_OpeID_TextChanged)**
```python
class OperatorManager:
    def __init__(self):
        self.current_operator = None
        self.operator_database = {}
    
    def set_operator(self, operator_id: str):
        """设置当前操作员"""
        if operator_id in self.operator_database:
            self.current_operator = self.operator_database[operator_id]
            logger.info(f"操作员已切换: {self.current_operator.name}")
        else:
            logger.warning(f"未知操作员ID: {operator_id}")
    
    def get_operator_name(self, operator_id: str) -> str:
        """获取操作员名称"""
        if operator_id in self.operator_database:
            return self.operator_database[operator_id].name
        return "未知操作员"
```

### 11.6 数据验证模块详细设计

#### 11.6.1 验证方法具体实现

**数值验证器 (chkTxtIsNumeric)**
```python
class NumericValidator:
    def validate(self, text: str, min_value: float = None, 
                max_value: float = None, decimal_places: int = None) -> bool:
        """验证数值文本"""
        try:
            value = float(text)
            
            if min_value is not None and value < min_value:
                return False
            
            if max_value is not None and value > max_value:
                return False
            
            if decimal_places is not None:
                # 检查小数位数
                decimal_part = str(value).split('.')
                if len(decimal_part) > 1 and len(decimal_part[1]) > decimal_places:
                    return False
            
            return True
        except ValueError:
            return False
```

#### 11.6.2 验证规则技术设计

**业务规则验证器 (chkAddControls)**
```python
class BusinessRuleValidator:
    def __init__(self, validation_rules: Dict):
        self.validation_rules = validation_rules
    
    def validate_controls(self, control_values: Dict) -> Dict[str, str]:
        """验证控件组业务规则"""
        errors = {}
        
        for rule_name, rule in self.validation_rules.items():
            if not rule(control_values):
                errors[rule_name] = f"业务规则验证失败: {rule_name}"
        
        return errors
    
    def add_validation_rule(self, rule_name: str, rule: Callable):
        """添加验证规则"""
        self.validation_rules[rule_name] = rule
```

#### 11.6.3 错误处理机制

**验证错误处理器**
```python
class ValidationErrorHandler:
    def __init__(self):
        self.error_messages = {}
    
    def add_error(self, control_id: str, message: str):
        """添加错误信息"""
        if control_id not in self.error_messages:
            self.error_messages[control_id] = []
        self.error_messages[control_id].append(message)
    
    def clear_errors(self, control_id: str = None):
        """清除错误信息"""
        if control_id:
            if control_id in self.error_messages:
                del self.error_messages[control_id]
        else:
            self.error_messages.clear()
    
    def has_errors(self) -> bool:
        """检查是否有错误"""
        return len(self.error_messages) > 0
```

### 11.7 系统管理模块详细设计

#### 11.7.1 初始化系统技术实现

**系统初始化器 (Frm_main_Load)**
```python
class SystemInitializer:
    def __init__(self, config_manager: ConfigManager, data_manager: DataManager):
        self.config_manager = config_manager
        self.data_manager = data_manager
        self.initialization_steps = [
            self._load_configuration,
            self._load_master_data,
            self._initialize_ui,
            self._setup_communication
        ]
    
    async def initialize_system(self):
        """异步初始化系统"""
        for step in self.initialization_steps:
            try:
                await step()
            except Exception as e:
                logger.error(f"初始化步骤失败: {e}")
                raise
    
    async def _load_configuration(self):
# DNC系统开发详细文档

## 1. 项目概述

### 1.1 系统简介
DNC（Direct Numerical Control）系统是一个数控设备参数管理软件，用于从电脑直接传送参数到NC机的宏变量系统。该系统解决了传统NC机手动输入参数的时间和错误问题。

### 1.2 系统架构 - 基于VB.NET源码分析
- **原系统**: VB.NET DNC2.05 (基于Frm_main.vb主窗体)
- **新系统**: Python重写版本 (基于VB.NET源码完整重构)
- **系统构成**: PC + NC机 + LAN线 + DNC软件 + 命名管道通信
- **数据格式**: CSV文件存储Master数据 + 动态控件系统
- **核心架构**: 8种控件系统 + 计算引擎 + 通信模块 + 数据处理

## 2. 系统功能模块

### 2.1 核心功能模块

#### 2.1.1 产品型号管理
- 产品类型定义 (type_define.csv)
- 程序类型映射 (type_prg.csv)
- 产品参数配置 (load.csv)

#### 2.1.2 参数计算引擎
- 几何参数计算 (calc.csv)
- 关系验证逻辑 (relation.csv)
- 变量定义管理 (define.csv)

#### 2.1.3 程序生成器
- 程序定义 (prg.csv)
- 控制参数 (cntrl_rex.csv)
- 选择逻辑 (select.csv)

### 2.2 数据流处理

#### 2.2.1 输入处理
```python
输入 → 参数验证 → 计算引擎 → 程序生成 → 输出
```

#### 2.2.2 宏变量映射
- #500-#600: 系统参数
- #1-#100: 用户参数
- 特殊变量: 计算中间值

## 3. 数据结构详细说明

### 3.1 核心数据文件

#### 3.1.1 type_define.csv (产品类型定义)
- **文件大小**: 988.60 KB
- **数据结构**:
  - NO: 序号
  - TYPE: 产品型号 (如: GPA18GT15040-A)
  - DEFINE1: 定义1
  - DEFINE2: 定义2

#### 3.1.2 type_prg.csv (程序类型映射)
- **文件大小**: 480.92 KB
- **数据结构**:
  - NO: 序号
  - prg1: 程序1编号
  - prg2: 程序2编号

#### 3.1.3 load.csv (主数据文件)
- **文件大小**: 8.5 MB
- **数据结构**:
  - NO: 序号
  - TYPE: 产品型号
  - DRAWING: 图纸文件
  - DISPFLG: 显示标志
  - #1-#12: 定义变量
  - #500-#550: 系统参数
  - #602-#603: 开关控制

#### 3.1.4 cntrl_rex.csv (参数控制)
- **文件大小**: 1.10 KB
- **数据结构**:
  - PARAMETER: 参数名称 (如: Work_plan, Teeth_num)
  - DATATYPE: 数据类型 (int, real, boolean)
  - MACRO: 宏变量映射 (如: #510, #511)

### 3.2 计算逻辑文件

#### 3.2.1 calc.csv (计算定义)
```csv
DEFINE,1,2,3,4,5,6,7,8,9,10,11,12,13
calcABC,=,#528,-,#510,*,2,NaN,NaN,NaN,NaN,NaN,NaN,NaN
calcABCD,=,(,#528,-,#513,),/,2.0,NaN,NaN,NaN,NaN,NaN
```

#### 3.2.2 relation.csv (关系验证)
```csv
DEFINE,VALUE,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28
relationHPN,#1,and,#1,>,0.0,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN
```

#### 3.2.3 define.csv (变量定义)
```csv
DEFINE,STR,BEFORE,AFTER,CHNGVL,CALC
defineP,P,P0,0,NaN,NaN
defineH,H,H0,0,NaN,NaN
```

## 4. 技术架构设计

### 4.1 系统架构图

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   用户界面层     │    │   业务逻辑层     │    │   数据访问层     │
│                 │    │                 │    │                 │
│  - 主窗口       │◄──►│  - 参数计算     │◄──►│  - CSV处理器    │
│  - 输入表单     │    │  - 程序生成     │    │  - 数据验证     │
│  - 结果显示     │    │  - 关系验证     │    │  - 编码处理     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 4.2 核心类设计

#### 4.2.1 DataManager (数据管理器)
```python
class DataManager:
    def load_master_data(self) -> Dict[str, pd.DataFrame]
    def batch_read_large_csv(self, file_path: str, batch_size: int = 1000)
    def validate_data_integrity(self) -> bool
    def fix_encoding_issues(self, file_path: str) -> pd.DataFrame
```

#### 4.2.2 CalculationEngine (计算引擎)
```python
class CalculationEngine:
    def calculate_parameters(self, input_data: Dict) -> Dict
    def validate_relations(self, calculated_data: Dict) -> bool
    def generate_macro_variables(self, params: Dict) -> List[str]
```

#### 4.2.3 ProgramGenerator (程序生成器)
```python
class ProgramGenerator:
    def generate_nc_program(self, product_type: str, params: Dict) -> str
    def apply_program_template(self, template: str, variables: Dict) -> str
    def validate_program_syntax(self, program: str) -> bool
```

## 5. 数据处理流程

### 5.1 数据加载流程
1. **扫描目录**: 递归扫描master目录下的所有CSV文件
2. **分类处理**: 根据文件大小分类为小文件和大文件
3. **编码检测**: 自动检测文件编码 (UTF-8, Shift-JIS, CP932)
4. **分批读取**: 大文件使用分批读取机制
5. **数据验证**: 检查数据完整性和一致性

### 5.2 参数计算流程
1. **输入验证**: 验证用户输入参数的有效性
2. **变量替换**: 根据define.csv进行变量替换
3. **计算执行**: 执行calc.csv中定义的计算逻辑
4. **关系验证**: 验证relation.csv中定义的关系条件
5. **结果生成**: 生成最终的宏变量值

## 6. 文件编码处理

### 6.1 编码问题文件列表
- `ini.csv`: 958字节，编码问题
- `math.csv`: 1.08KB，编码问题  
- `cntrl.csv`: 1.38KB，编码问题
- `switch.csv`: 106字节，编码问题

### 6.2 编码处理策略
```python
def detect_encoding(file_path: str) -> str:
    encodings = ['utf-8', 'shift_jis', 'cp932', 'latin1']
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as f:
                f.read()
            return encoding
        except UnicodeDecodeError:
            continue
    return 'unknown'
```

## 7. 性能优化策略

### 7.1 大文件处理优化
- **分批读取**: 使用pandas的chunksize参数
- **内存管理**: 及时释放不需要的数据
- **缓存机制**: 缓存频繁访问的数据

### 7.2 计算优化
- **预编译**: 预编译计算表达式
- **并行处理**: 使用多线程处理独立计算
- **结果缓存**: 缓存重复计算结果

## 8. 错误处理机制

### 8.1 数据验证错误
- 文件不存在错误
- 编码错误处理
- 数据格式错误
- 完整性检查失败

### 8.2 计算错误
- 除零错误处理
- 变量未定义错误
- 关系验证失败
- 程序生成错误

## 9. 部署和配置

### 9.1 环境要求
- Python 3.8+
- pandas >= 1.3.0
- PyQt5/PySide6
- 操作系统: Windows 10/11

### 9.2 配置文件
```ini
[system]
data_directory = ./data/master
log_level = INFO
batch_size = 1000

[encoding]
default_encoding = utf-8
fallback_encodings = shift_jis,cp932,latin1
```

## 10. 测试策略

### 10.1 单元测试
- 数据加载测试
- 计算逻辑测试
- 程序生成测试
- 错误处理测试

### 10.2 集成测试
- 端到端流程测试
- 性能测试
- 兼容性测试

## 11. 功能模块详细设计

### 11.1 控件系统详细设计

#### 11.1.1 8种核心控件类型实现

**Load控件 (makeCntrlLoad)**
```python
class LoadControl:
    def __init__(self, data_source: str, field_mapping: Dict):
        self.data_source = data_source
        self.field_mapping = field_mapping
        self.data_table = None
    
    def load_data(self) -> pd.DataFrame:
        """从CSV文件加载数据"""
        try:
            self.data_table = pd.read_csv(self.data_source, encoding='utf-8')
            return self.data_table
        except Exception as e:
            logger.error(f"加载数据失败: {e}")
            return None
    
    def validate_data(self) -> bool:
        """验证数据完整性"""
        required_fields = ['NO', 'TYPE', 'DRAWING']
        return all(field in self.data_table.columns for field in required_fields)
```

**Input控件 (makeCntrlInput)**
```python
class InputControl:
    def __init__(self, control_id: str, data_type: str, validation_rules: Dict):
        self.control_id = control_id
        self.data_type = data_type
        self.validation_rules = validation_rules
        self.value = None
    
    def handle_text_change(self, new_value: str):
        """处理文本变更事件"""
        if self.validate_input(new_value):
            self.value = self.convert_value(new_value)
            self.trigger_calculation()
    
    def validate_input(self, value: str) -> bool:
        """验证输入值"""
        if self.data_type == 'numeric':
            return self._validate_numeric(value)
        elif self.data_type == 'string':
            return self._validate_string(value)
        return False
```

#### 11.1.2 基础控件创建方法Python实现

**文本框创建 (makeTextBox)**
```python
def create_text_box(name: str, location: Tuple[int, int], size: Tuple[int, int], 
                   text_change_handler: Callable) -> QLineEdit:
    """创建文本框控件"""
    text_box = QLineEdit()
    text_box.setObjectName(name)
    text_box.setGeometry(location[0], location[1], size[0], size[1])
    text_box.textChanged.connect(text_change_handler)
    return text_box
```

**标签创建 (makeLabel)**
```python
def create_label(name: str, text: str, location: Tuple[int, int], 
                size: Tuple[int, int]) -> QLabel:
    """创建标签控件"""
    label = QLabel(text)
    label.setObjectName(name)
    label.setGeometry(location[0], location[1], size[0], size[1])
    return label
```

#### 11.1.3 动态控件管理技术细节

**控件生命周期管理**
```python
class ControlManager:
    def __init__(self):
        self.controls = {}
        self.control_groups = {}
    
    def add_control(self, control_id: str, control: QWidget):
        """添加控件到管理器"""
        self.controls[control_id] = control
    
    def remove_control(self, control_id: str):
        """移除控件"""
        if control_id in self.controls:
            self.controls[control_id].deleteLater()
            del self.controls[control_id]
    
    def enable_controls(self, control_ids: List[str], enabled: bool):
        """批量启用/禁用控件"""
        for control_id in control_ids:
            if control_id in self.controls:
                self.controls[control_id].setEnabled(enabled)
```

### 11.2 计算引擎详细设计

#### 11.2.1 表达式计算具体算法

**表达式解析器 (getCalcResult)**
```python
class ExpressionCalculator:
    def __init__(self):
        self.variables = {}
        self.functions = {
            'MAX': max,
            'MIN': min,
            'ROUND': round,
            'ABS': abs
        }
    
    def calculate(self, expression: str, variables: Dict) -> float:
        """计算表达式值"""
        try:
            # 变量替换
            expr = self._replace_variables(expression, variables)
            # 表达式求值
            result = eval(expr, {"__builtins__": None}, self.functions)
            return float(result)
        except Exception as e:
            logger.error(f"表达式计算错误: {expression}, 错误: {e}")
            return 0.0
    
    def _replace_variables(self, expression: str, variables: Dict) -> str:
        """替换表达式中的变量"""
        for var_name, var_value in variables.items():
            expression = expression.replace(f"@{var_name}", str(var_value))
        return expression
```

#### 11.2.2 条件判断系统实现逻辑

**关系判断引擎 (judgeRelation)**
```python
class RelationJudge:
    def judge(self, condition: str, left_value: Any, right_value: Any) -> bool:
        """判断关系条件"""
        operators = {
            '=': lambda x, y: x == y,
            '<>': lambda x, y: x != y,
            '>': lambda x, y: x > y,
            '<': lambda x, y: x < y,
            '>=': lambda x, y: x >= y,
            '<=': lambda x, y: x <= y
        }
        
        for op, func in operators.items():
            if op in condition:
                return func(left_value, right_value)
        
        return False
```

#### 11.2.3 精度控制技术方案

**数值精度管理**
```python
class PrecisionController:
    def __init__(self, decimal_places: int = 4):
        self.decimal_places = decimal_places
    
    def round_value(self, value: float) -> float:
        """四舍五入处理"""
        return round(value, self.decimal_places)
    
    def format_display(self, value: float) -> str:
        """格式化显示值"""
        return f"{value:.{self.decimal_places}f}".rstrip('0').rstrip('.')
```

### 11.3 数据处理模块详细设计

#### 11.3.1 文件加载系统实现细节

**CSV文件加载器 (LoadFileToTBL)**
```python
class CSVLoader:
    def __init__(self, encoding_detector: EncodingDetector):
        self.encoding_detector = encoding_detector
    
    def load_file(self, file_path: str) -> pd.DataFrame:
        """加载CSV文件"""
        encoding = self.encoding_detector.detect_encoding(file_path)
        
        try:
            df = pd.read_csv(file_path, encoding=encoding)
            return self._clean_data(df)
        except Exception as e:
            logger.error(f"文件加载失败: {file_path}, 错误: {e}")
            return pd.DataFrame()
    
    def _clean_data(self, df: pd.DataFrame) -> pd.DataFrame:
        """数据清理"""
        # 移除空行
        df = df.dropna(how='all')
        # 处理NaN值
        df = df.fillna('')
        return df
```

#### 11.3.2 数据搜索功能算法设计

**表搜索引擎 (searchT_relation)**
```python
class TableSearcher:
    def __init__(self, data_tables: Dict[str, pd.DataFrame]):
        self.data_tables = data_tables
        self.search_cache = {}
    
    def search_table(self, table_name: str, search_criteria: Dict) -> pd.DataFrame:
        """搜索数据表"""
        cache_key = f"{table_name}_{str(search_criteria)}"
        if cache_key in self.search_cache:
            return self.search_cache[cache_key]
        
        if table_name not in self.data_tables:
            return pd.DataFrame()
        
        table = self.data_tables[table_name]
        result = table.copy()
        
        for column, value in search_criteria.items():
            if column in table.columns:
                result = result[result[column] == value]
        
        self.search_cache[cache_key] = result
        return result
```

#### 11.3.3 数据操作技术实现

**数据转换器 (searchT_ChngValue)**
```python
class DataConverter:
    def __init__(self, conversion_rules: Dict):
        self.conversion_rules = conversion_rules
    
    def convert_value(self, value: Any, conversion_type: str) -> Any:
        """转换数据值"""
        if conversion_type in self.conversion_rules:
            rule = self.conversion_rules[conversion_type]
            return rule(value)
        return value
    
    def add_conversion_rule(self, conversion_type: str, rule: Callable):
        """添加转换规则"""
        self.conversion_rules[conversion_type] = rule
```

### 11.4 通信模块详细设计

#### 11.4.1 通信协议支持技术实现

**NC通信协议处理器 (makeSendTxt)**
```python
class NCProtocolHandler:
    def __init__(self, protocol_type: str):
        self.protocol_type = protocol_type
        self.message_formatters = {
            'rexroth': self._format_rexroth_message,
            'brother': self._format_brother_message
        }
    
    def format_message(self, command: str, parameters: Dict) -> str:
        """格式化NC命令消息"""
        if self.protocol_type in self.message_formatters:
            return self.message_formatters[self.protocol_type](command, parameters)
        return command
    
    def _format_rexroth_message(self, command: str, parameters: Dict) -> str:
        """格式化Rexroth协议消息"""
        # Rexroth协议特定格式化逻辑
        return f"{command} {self._format_parameters(parameters)}"
    
    def _format_brother_message(self, command: str, parameters: Dict) -> str:
        """格式化Brother协议消息"""
        # Brother协议特定格式化逻辑
        return f"{command};{self._format_parameters(parameters)}"
```

#### 11.4.2 进程间通信机制设计

**连接状态管理器 (ConnectionChange)**
```python
class ConnectionManager:
    def __init__(self):
        self.connections = {}
        self.connection_callbacks = []
    
    def add_connection(self, connection_id: str, connection: object):
        """添加连接"""
        self.connections[connection_id] = connection
        self._notify_connection_change(connection_id, 'connected')
    
    def remove_connection(self, connection_id: str):
        """移除连接"""
        if connection_id in self.connections:
            del self.connections[connection_id]
            self._notify_connection_change(connection_id, 'disconnected')
    
    def _notify_connection_change(self, connection_id: str, status: str):
        """通知连接状态变更"""
        for callback in self.connection_callbacks:
            callback(connection_id, status)
```

#### 11.4.3 命名管道通信具体实现

**异步命名管道客户端 (NamedPipeAsyncClient)**
```python
class NamedPipeClient:
    def __init__(self, pipe_name: str):
        self.pipe_name = pipe_name
        self.connected = False
        self.data_received_callbacks = []
    
    async def connect(self):
        """异步连接命名管道"""
        try:
            # Windows命名管道连接实现
            self.connected = True
            await self._start_listening()
        except Exception as e:
            logger.error(f"命名管道连接失败: {e}")
            self.connected = False
    
    async def send_data(self, data: str):
        """异步发送数据"""
        if self.connected:
            # 实现数据发送逻辑
            pass
    
    def add_data_received_callback(self, callback: Callable):
        """添加数据接收回调"""
        self.data_received_callbacks.append(callback)
```

### 11.5 用户界面交互详细设计

#### 11.5.1 事件处理系统架构设计

**事件分发器**
```python
class EventDispatcher:
    def __init__(self):
        self.event_handlers = {}
    
    def register_handler(self, event_type: str, handler: Callable):
        """注册事件处理器"""
        if event_type not in self.event_handlers:
            self.event_handlers[event_type] = []
        self.event_handlers[event_type].append(handler)
    
    def dispatch_event(self, event_type: str, event_data: Dict):
        """分发事件"""
        if event_type in self.event_handlers:
            for handler in self.event_handlers[event_type]:
                try:
                    handler(event_data)
                except Exception as e:
                    logger.error(f"事件处理错误: {e}")
```

#### 11.5.2 输入处理技术实现

**文本变更处理器 (txt_change)**
```python
class TextChangeHandler:
    def __init__(self, validation_rules: Dict, calculation_trigger: Callable):
        self.validation_rules = validation_rules
        self.calculation_trigger = calculation_trigger
        self.change_event_flag = False
    
    def handle_text_change(self, control_id: str, new_text: str):
        """处理文本变更"""
        if self.change_event_flag:
            return
        
        self.change_event_flag = True
        
        try:
            # 数据验证
            if self._validate_text(control_id, new_text):
                # 触发计算
                self.calculation_trigger(control_id, new_text)
        finally:
            self.change_event_flag = False
    
    def _validate_text(self, control_id: str, text: str) -> bool:
        """验证文本内容"""
        if control_id in self.validation_rules:
            rule = self.validation_rules[control_id]
            return rule(text)
        return True
```

#### 11.5.3 操作员管理功能设计

**操作员管理器 (TB_OpeID_TextChanged)**
```python
class OperatorManager:
    def __init__(self):
        self.current_operator = None
        self.operator_database = {}
    
    def set_operator(self, operator_id: str):
        """设置当前操作员"""
        if operator_id in self.operator_database:
            self.current_operator = self.operator_database[operator_id]
            logger.info(f"操作员已切换: {self.current_operator.name}")
        else:
            logger.warning(f"未知操作员ID: {operator_id}")
    
    def get_operator_name(self, operator_id: str) -> str:
        """获取操作员名称"""
        if operator_id in self.operator_database:
            return self.operator_database[operator_id].name
        return "未知操作员"
```

### 11.6 数据验证模块详细设计

#### 11.6.1 验证方法具体实现

**数值验证器 (chkTxtIsNumeric)**
```python
class NumericValidator:
    def validate(self, text: str, min_value: float = None, 
                max_value: float = None, decimal_places: int = None) -> bool:
        """验证数值文本"""
        try:
            value = float(text)
            
            if min_value is not None and value < min_value:
                return False
            
            if max_value is not None and value > max_value:
                return False
            
            if decimal_places is not None:
                # 检查小数位数
                decimal_part = str(value).split('.')
                if len(decimal_part) > 1 and len(decimal_part[1]) > decimal_places:
                    return False
            
            return True
        except ValueError:
            return False
```

#### 11.6.2 验证规则技术设计

**业务规则验证器 (chkAddControls)**
```python
class BusinessRuleValidator:
    def __init__(self, validation_rules: Dict):
        self.validation_rules = validation_rules
    
    def validate_controls(self, control_values: Dict) -> Dict[str, str]:
        """验证控件组业务规则"""
        errors = {}
        
        for rule_name, rule in self.validation_rules.items():
            if not rule(control_values):
                errors[rule_name] = f"业务规则验证失败: {rule_name}"
        
        return errors
    
    def add_validation_rule(self, rule_name: str, rule: Callable):
        """添加验证规则"""
        self.validation_rules[rule_name] = rule
```

#### 11.6.3 错误处理机制

**验证错误处理器**
```python
class ValidationErrorHandler:
    def __init__(self):
        self.error_messages = {}
    
    def add_error(self, control_id: str, message: str):
        """添加错误信息"""
        if control_id not in self.error_messages:
            self.error_messages[control_id] = []
        self.error_messages[control_id].append(message)
    
    def clear_errors(self, control_id: str = None):
        """清除错误信息"""
        if control_id:
            if control_id in self.error_messages:
                del self.error_messages[control_id]
        else:
            self.error_messages.clear()
    
    def has_errors(self) -> bool:
        """检查是否有错误"""
        return len(self.error_messages) > 0
```

### 11.7 系统管理模块详细设计

#### 11.7.1 初始化系统技术实现

**系统初始化器 (Frm_main_Load)**
```python
class SystemInitializer:
    def __init__(self, config_manager: ConfigManager, data_manager: DataManager):
        self.config_manager = config_manager
        self.data_manager = data_manager
        self.initialization_steps = [
            self._load_configuration,
            self._load_master_data,
            self._initialize_ui,
            self._setup_communication
        ]
    
    async def initialize_system(self):
        """异步初始化系统"""
        for step in self.initialization_steps:
            try:
                await step()
            except Exception as e:
                logger.error(f"初始化步骤失败: {e}")
                raise
    
    async def _load_configuration(self):
        """加载系统配置"""
        self.config = await self.config_manager.load_config()
    
    async def _load_master_data(self):
        """加载Master数据"""
        self.master_data = await self.data_manager.load_master_data()
    
    async def _initialize_ui(self):
        """初始化用户界面"""
        # 创建主窗口和控件
        pass
    
    async def _setup_communication(self):
        """设置通信连接"""
        # 初始化NC通信和命名管道
        pass
```

#### 11.7.2 显示管理功能设计

**控件状态管理器 (ControlStateManager)**
```python
class ControlStateManager:
    def __init__(self):
        self.control_states = {}
        self.control_groups = {}
    
    def set_controls_enabled(self, control_ids: List[str], enabled: bool):
        """设置控件启用状态"""
        for control_id in control_ids:
            if control_id in self.control_states:
                self.control_states[control_id].setEnabled(enabled)
    
    def set_controls_visible(self, control_ids: List[str], visible: bool):
        """设置控件可见性"""
        for control_id in control_ids:
            if control_id in self.control_states:
                self.control_states[control_id].setVisible(visible)
    
    def add_control_group(self, group_name: str, control_ids: List[str]):
        """添加控件组"""
        self.control_groups[group_name] = control_ids
    
    def set_group_enabled(self, group_name: str, enabled: bool):
        """设置控件组启用状态"""
        if group_name in self.control_groups:
            self.set_controls_enabled(self.control_groups[group_name], enabled)
```

#### 11.7.3 配置管理技术方案

**INI配置管理器 (IniConfigManager)**
```python
class IniConfigManager:
    def __init__(self, ini_file_path: str):
        self.ini_file_path = ini_file_path
        self.config = {}
    
    def load_config(self) -> Dict:
        """加载INI配置文件"""
        config = configparser.ConfigParser()
        config.read(self.ini_file_path, encoding='utf-8')
        
        for section in config.sections():
            self.config[section] = dict(config.items(section))
        
        return self.config
    
    def save_config(self, config: Dict):
        """保存INI配置文件"""
        config_parser = configparser.ConfigParser()
        
        for section, options in config.items():
            config_parser[section] = options
        
        with open(self.ini_file_path, 'w', encoding='utf-8') as f:
            config_parser.write(f)
    
    def get_value(self, section: str, key: str, default=None):
        """获取配置值"""
        return self.config.get(section, {}).get(key, default)
```

### 11.8 工具方法详细设计

#### 11.8.1 字符串处理技术实现

**字符串工具类 (StringUtils)**
```python
class StringUtils:
    @staticmethod
    def len_b(text: str) -> int:
        """计算字符串字节长度（兼容VB.NET的LenB函数）"""
        return len(text.encode('utf-8'))
    
    @staticmethod
    def make_format_str(format_pattern: str, *args) -> str:
        """创建格式化字符串"""
        try:
            return format_pattern.format(*args)
        except Exception as e:
            logger.error(f"字符串格式化失败: {e}")
            return format_pattern
    
    @staticmethod
    def to_half_adjust(value: float, decimal_places: int = 0) -> float:
        """四舍五入处理（兼容VB.NET的ToHalfAdjust）"""
        factor = 10 ** decimal_places
        return round(value * factor) / factor
    
    @staticmethod
    def get_operator_name(operator_id: str) -> str:
        """获取操作员名称"""
        operator_map = {
            '001': '操作员A',
            '002': '操作员B',
            '003': '操作员C'
        }
        return operator_map.get(operator_id, '未知操作员')
```

#### 11.8.2 系统工具功能设计

**系统工具类 (SystemUtils)**
```python
class SystemUtils:
    @staticmethod
    def get_all_controls(parent_widget: QWidget) -> List[QWidget]:
        """获取所有子控件"""
        controls = []
        
        def collect_controls(widget):
            for child in widget.children():
                if isinstance(child, QWidget):
                    controls.append(child)
                    collect_controls(child)
        
        collect_controls(parent_widget)
        return controls
    
    @staticmethod
    def change_form_size(form: QWidget, width: int, height: int):
        """改变窗体大小"""
        form.resize(width, height)
    
    @staticmethod
    def show_info_form(title: str, message: str):
        """显示信息窗体"""
        msg_box = QMessageBox()
        msg_box.setWindowTitle(title)
        msg_box.setText(message)
        msg_box.setIcon(QMessageBox.Information)
        msg_box.exec_()
```

#### 11.8.3 数值处理工具

**公差计算器 (ToleranceCalculator)**
```python
class ToleranceCalculator:
    @staticmethod
    def get_shafts_tolerance(diameter: float, tolerance_class: str) -> Tuple[float, float]:
        """获取轴公差"""
        tolerance_tables = {
            'h6': {10: (-0.009, 0), 18: (-0.011, 0), 30: (-0.013, 0)},
            'h7': {10: (-0.015, 0), 18: (-0.018, 0), 30: (-0.021, 0)},
            'h8': {10: (-0.022, 0), 18: (-0.027, 0), 30: (-0.033, 0)}
        }
        
        for max_diameter, tolerance in tolerance_tables.get(tolerance_class, {}).items():
            if diameter <= max_diameter:
                return tolerance
        
        return (0, 0)
    
    @staticmethod
    def get_length_tolerance(length: float, tolerance_class: str) -> Tuple[float, float]:
        """获取长度公差"""
        tolerance_tables = {
            'fine': {100: (-0.1, 0.1), 400: (-0.2, 0.2), 1000: (-0.3, 0.3)},
            'medium': {100: (-0.2, 0.2), 400: (-0.4, 0.4), 1000: (-0.6, 0.6)},
            'coarse': {100: (-0.4, 0.4), 400: (-0.8, 0.8), 1000: (-1.2, 1.2)}
        }
        
        for max_length, tolerance in tolerance_tables.get(tolerance_class, {}).items():
            if length <= max_length:
                return tolerance
        
        return (0, 0)
```

## 12. 技术架构设计

### 12.1 核心类设计
# DNC系统开发详细文档

## 1. 项目概述

### 1.1 系统简介
DNC（Direct Numerical Control）系统是一个数控设备参数管理软件，用于从电脑直接传送参数到NC机的宏变量系统。该系统解决了传统NC机手动输入参数的时间和错误问题。

### 1.2 系统架构 - 基于VB.NET源码分析
- **原系统**: VB.NET DNC2.05 (基于Frm_main.vb主窗体)
- **新系统**: Python重写版本 (基于VB.NET源码完整重构)
- **系统构成**: PC + NC机 + LAN线 + DNC软件 + 命名管道通信
- **数据格式**: CSV文件存储Master数据 + 动态控件系统
- **核心架构**: 8种控件系统 + 计算引擎 + 通信模块 + 数据处理

## 2. 系统功能模块

### 2.1 核心功能模块

#### 2.1.1 产品型号管理
- 产品类型定义 (type_define.csv)
- 程序类型映射 (type_prg.csv)
- 产品参数配置 (load.csv)

#### 2.1.2 参数计算引擎
- 几何参数计算 (calc.csv)
- 关系验证逻辑 (relation.csv)
- 变量定义管理 (define.csv)

#### 2.1.3 程序生成器
- 程序定义 (prg.csv)
- 控制参数 (cntrl_rex.csv)
- 选择逻辑 (select.csv)

### 2.2 数据流处理

#### 2.2.1 输入处理
```python
输入 → 参数验证 → 计算引擎 → 程序生成 → 输出
```

#### 2.2.2 宏变量映射
- #500-#600: 系统参数
- #1-#100: 用户参数
- 特殊变量: 计算中间值

## 3. 数据结构详细说明

### 3.1 核心数据文件

#### 3.1.1 type_define.csv (产品类型定义)
- **文件大小**: 988.60 KB
- **数据结构**:
  - NO: 序号
  - TYPE: 产品型号 (如: GPA18GT15040-A)
  - DEFINE1: 定义1
  - DEFINE2: 定义2

#### 3.1.2 type_prg.csv (程序类型映射)
- **文件大小**: 480.92 KB
- **数据结构**:
  - NO: 序号
  - prg1: 程序1编号
  - prg2: 程序2编号

#### 3.1.3 load.csv (主数据文件)
- **文件大小**: 8.5 MB
- **数据结构**:
  - NO: 序号
  - TYPE: 产品型号
  - DRAWING: 图纸文件
  - DISPFLG: 显示标志
  - #1-#12: 定义变量
  - #500-#550: 系统参数
  - #602-#603: 开关控制

#### 3.1.4 cntrl_rex.csv (参数控制)
- **文件大小**: 1.10 KB
- **数据结构**:
  - PARAMETER: 参数名称 (如: Work_plan, Teeth_num)
  - DATATYPE: 数据类型 (int, real, boolean)
  - MACRO: 宏变量映射 (如: #510, #511)

### 3.2 计算逻辑文件

#### 3.2.1 calc.csv (计算定义)
```csv
DEFINE,1,2,3,4,5,6,7,8,9,10,11,12,13
calcABC,=,#528,-,#510,*,2,NaN,NaN,NaN,NaN,NaN,NaN,NaN
calcABCD,=,(,#528,-,#513,),/,2.0,NaN,NaN,NaN,NaN,NaN
```

#### 3.2.2 relation.csv (关系验证)
```csv
DEFINE,VALUE,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28
relationHPN,#1,and,#1,>,0.0,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN
```

#### 3.2.3 define.csv (变量定义)
```csv
DEFINE,STR,BEFORE,AFTER,CHNGVL,CALC
defineP,P,P0,0,NaN,NaN
defineH,H,H0,0,NaN,NaN
```

## 4. 技术架构设计

### 4.1 系统架构图

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   用户界面层     │    │   业务逻辑层     │    │   数据访问层     │
│                 │    │                 │    │                 │
│  - 主窗口       │◄──►│  - 参数计算     │◄──►│  - CSV处理器    │
│  - 输入表单     │    │  - 程序生成     │    │  - 数据验证     │
│  - 结果显示     │    │  - 关系验证     │    │  - 编码处理     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 4.2 核心类设计

#### 4.2.1 DataManager (数据管理器)
```python
class DataManager:
    def load_master_data(self) -> Dict[str, pd.DataFrame]
    def batch_read_large_csv(self, file_path: str, batch_size: int = 1000)
    def validate_data_integrity(self) -> bool
    def fix_encoding_issues(self, file_path: str) -> pd.DataFrame
```

#### 4.2.2 CalculationEngine (计算引擎)
```python
class CalculationEngine:
    def calculate_parameters(self, input_data: Dict) -> Dict
    def validate_relations(self, calculated_data: Dict) -> bool
    def generate_macro_variables(self, params: Dict) -> List[str]
```

#### 4.2.3 ProgramGenerator (程序生成器)
```python
class ProgramGenerator:
    def generate_nc_program(self, product_type: str, params: Dict) -> str
    def apply_program_template(self, template: str, variables: Dict) -> str
    def validate_program_syntax(self, program: str) -> bool
```

## 5. 数据处理流程

### 5.1 数据加载流程
1. **扫描目录**: 递归扫描master目录下的所有CSV文件
2. **分类处理**: 根据文件大小分类为小文件和大文件
3. **编码检测**: 自动检测文件编码 (UTF-8, Shift-JIS, CP932)
4. **分批读取**: 大文件使用分批读取机制
5. **数据验证**: 检查数据完整性和一致性

### 5.2 参数计算流程
1. **输入验证**: 验证用户输入参数的有效性
2. **变量替换**: 根据define.csv进行变量替换
3. **计算执行**: 执行calc.csv中定义的计算逻辑
4. **关系验证**: 验证relation.csv中定义的关系条件
5. **结果生成**: 生成最终的宏变量值

## 6. 文件编码处理

### 6.1 编码问题文件列表
- `ini.csv`: 958字节，编码问题
- `math.csv`: 1.08KB，编码问题  
- `cntrl.csv`: 1.38KB，编码问题
- `switch.csv`: 106字节，编码问题

### 6.2 编码处理策略
```python
def detect_encoding(file_path: str) -> str:
    encodings = ['utf-8', 'shift_jis', 'cp932', 'latin1']
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as f:
                f.read()
            return encoding
        except UnicodeDecodeError:
            continue
    return 'unknown'
```

## 7. 性能优化策略

### 7.1 大文件处理优化
- **分批读取**: 使用pandas的chunksize参数
- **内存管理**: 及时释放不需要的数据
- **缓存机制**: 缓存频繁访问的数据

### 7.2 计算优化
- **预编译**: 预编译计算表达式
- **并行处理**: 使用多线程处理独立计算
- **结果缓存**: 缓存重复计算结果

## 8. 错误处理机制

### 8.1 数据验证错误
- 文件不存在错误
- 编码错误处理
- 数据格式错误
- 完整性检查失败

### 8.2 计算错误
- 除零错误处理
- 变量未定义错误
- 关系验证失败
- 程序生成错误

## 9. 部署和配置

### 9.1 环境要求
- Python 3.8+
- pandas >= 1.3.0
- PyQt5/PySide6
- 操作系统: Windows 10/11

### 9.2 配置文件
```ini
[system]
data_directory = ./data/master
log_level = INFO
batch_size = 1000

[encoding]
default_encoding = utf-8
fallback_encodings = shift_jis,cp932,latin1
```

## 10. 测试策略

### 10.1 单元测试
- 数据加载测试
- 计算逻辑测试
- 程序生成测试
- 错误处理测试

### 10.2 集成测试
- 端到端流程测试
- 性能测试
- 兼容性测试

## 11. 维护和扩展

### 11.1 数据维护
- 定期备份Master数据
- 数据完整性检查
- 版本控制支持

### 11.2 功能扩展
- 支持新的产品类型
- 添加新的计算逻辑
- 扩展程序模板

---

**文档版本**: 1.0  
**最后更新**: 2025/10/23  
**维护者**: DNC开发团队
